*********************************************************************
*
* Choose Door Character.
*
* Used by the routine at #R$C7C0.
*
* The characters available on a particular level are determined by #R$CE1F.
* #TABLE(default,centre,centre)
* { =h Initialisation Routine | =h Door }
* { #R$CE42 | Door 1 }
* { #R$CE8D | Door 2 }
* { #R$D18A | Door 3 }
* TABLE#
* ix=door flags (door_1_flags, door_2_flags, door_3_flags)
* hl=door routine (door_1_routine, door_2_routine, door_3_routine)
*
character_chooser:                     ; ce21
       .proc
*      Wait 3 times before letting us in
       li   hl,chooser_countdown       ; LD HL,$CE1E       ; {Decrease #R$CE1E by one.
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ;
                                       ; LD (HL),A         ; }
       jne  character_chooser_2        ; RET NZ            ; Return if not zero.
       movb @chooser_countdown_init,*hl ; LD A,($CE1B)      ; {Copies #R$CE1B into #R$CE1E.
                                       ; LD (HL),A         ; }
*      Door also has a count-down
                                       ; LD A,(IX+$09)     ; {Decrease ????? by one.
       sb   one,@9(ix)                 ; DEC A             ; #TABLE(default,centre,centre)
                                       ; LD (IX+$09),A     ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       jne  character_chooser_2        ; RET NZ            ; Return if not zero.
*      Reset door count-down to random value
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,31*256                   ; AND $1F           ; Keep bits 0-4 (so 0-31).
       socb @bytes+8,a                 ; OR $08            ; {Set bit 3 and write the resulting value to;
       movb a,@9(ix)                   ; LD (IX+$09),A     ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       mov  @chooser_routine_ptr,hl    ; LD HL,($CE1F)     ; {Jump to the memory address contained at #R$CE1F.
       b    *hl                        ; JP (HL)           ; .
character_chooser_2:
       .endproc

*********************************************************************
* Handles choosing one of the initial "default" characters. A
* character is always chosen here, so this is the end of the
* choosing routine.
choose_default_set:                    ; ce42
       bl   @random_number_x           ; CALL $DAEF        ; Call #R$DAEF.
       andi a,3*256                    ; AND $03           ; Keep only bits 0 and 1 (which determine the type of
                                                           ; character).
       jeq  init_bandit_open         ; JR Z,$CEB8        ; 0 {Determines which character initialisation to run;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre,centre)
       jeq  init_bowie                 ; JP Z,$CEFC        ; 1 { =h #REGa | =h Initialisation Routine }
       sb   one,a                      ; DEC A             ; { $00 | #R$CEB8 }
       jne  !                          ; JP Z,$CF5E        ; { $01 | #R$CEFC }
       b    @init_customer_daisy       ;                   ; 2
!
       sb   one,a                      ; DEC A             ; { $02 | #R$CF5E }
       b    @init_customer_jordan      ; JP $CF2B          ; 3 { $03 | #R$CF2B }
                                                           ; TABLE#}
* Handles whether or not to choose Julius.
choose_julius:                         ; ce55
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,12*256                   ; AND $0C           ; {Keep only bits 2 and 3. Jump to the next character "test" if
       jne  choose_bandit_2            ; JR NZ,$CE5F       ; this is a non-zero number at #R$CE5F.}
       b    @init_julius_open          ; JP $CFB7          ; Jump to #R$CFB7.
* Handles whether or not to choose Bandit 2.
choose_bandit_2:                       ; ce5f
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,152*256                  ; AND $98           ; {Keep only bits 3, 4 and 7. Jump to the next character "test" if
       jne  choose_bandit_3            ; JR NZ,$CE6F       ; this is a non-zero number at #R$CE6F.}
       li   hl,bandit_2_source         ; LD HL,$D119       ; Set source character data to #R$D119.
       li   de,bandit_2_buffer         ; LD DE,$D124       ; Set target character buffer to #R$D124.
       b    @init_bandit_draw          ; JP $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 3.
choose_bandit_3:                       ; ce6f
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,49*256                   ; AND $31           ; {Keep only bits 0, 4 and 5. Jump to the next character "test" if
       jne  choose_default_set         ; JR NZ,$CE42       ; this is a non-zero number then jump back to the #R$CE42.
                                                           ; }
       li   hl,bandit_3_source         ; LD HL,$D0C1       ; Set source character data to #R$D0C1.
       li   de,bandit_3_buffer         ; LD DE,$D0CC       ; Set target character buffer to #R$D0CC.
       jmp  init_bandit_draw           ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 4.
choose_bandit_4:                       ; ce7e
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,131*256                  ; AND $83           ; {Keep only bits 0, 1 and 7. Jump to the next character "test" if
       jne  choose_julius              ; JR NZ,$CE55       ; this is a non-zero number #R$CE55.}
       li   hl,bandit_4_source         ; LD HL,$D0D7       ; Set source character data to #R$D0D7.
       li   de,bandit_4_buffer         ; LD DE,$D0E2       ; Set target character buffer to #R$D0E2.
       jmp  init_bandit_draw           ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 5.
choose_bandit_5:                       ; ce8d
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,88*256                   ; AND $58           ; {Keep only bits 3, 4 and 6. Jump to the next character "test" if
       jne  choose_bandit_4            ; JR NZ,$CE7E       ; this is a non-zero number #R$CE7E.}
       li   hl,bandit_5_source         ; LD HL,$D0ED       ; Set source character data to #R$D0ED.
       li   de,bandit_5_buffer         ; LD DE,$D0F8       ; Set target character buffer to #R$D0F8.
       jmp  init_bandit_draw           ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 6.
choose_bandit_6:                       ; ce9c
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,113*256                  ; AND $71           ; {Keep only bits 0, 4, 5 and 6. Jump to the next character "test" if
       jne  choose_bandit_5            ; JR NZ,$CE8D       ; this is a non-zero number #R$CE8D.}
       li   hl,bandit_6_source         ; LD HL,$D103       ; Set source character data to #R$D103.
       li   de,bandit_6_buffer         ; LD DE,$D10E       ; Set target character buffer to #R$D10E.

*********************************************************************
* Character Initialisations.
*
* Stashes the chosen character source/ buffer to the door state buffer.
init_bandit_draw:                      ; cea9
       mov  hl,@12(ix)                 ; LD (IX+$0C),L     ; {Writes the character source memory address to one of the following (depending on which door is currently
                                       ; LD (IX+$0D),H     ; being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D171 | Door 1 }
                                                           ; { #R$D17F | Door 2 }
                                                           ; { #R$D18D | Door 3 }
                                                           ; TABLE#}
       mov  de,@10(ix)                 ; LD (IX+$0A),E     ; {Writes the character target/ buffer memory address to one of the following (depending on which door is
                                       ; LD (IX+$0B),D     ; currently being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#}
       b    @init_bandit_draw_open     ; JP $D019          ; Jump to #R$D019.

*********************************************************************
* Used by the routines at #R$CE21 and #R$D48F.
*
* Writes a "bandit opening the door" to the door flags/ cache.
call_init_bandit_open:                ; ceb8
       .proc
init_bandit_open:                      ; ceb8
       li   de,prep_bandit_open        ; LD DE,$D192       ; {Writes #R$D192 to the address contained
*      Set hl = pointer to pointer to door routine
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
*      Set pointer to door routine to prep_bandit_open
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
*      Set hl = pointer to bandit data
       li   hl,bandit_open_source      ; LD HL,$D076       ; {Handles copying $0007 bytes of data from the address contained
*      Set de = pointer to door source data
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
*      Copy 7 bytes from bandit data to door source data
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D076.}
*      Set the flag
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F and return.
                                       ; LD ($D18F),A      ;
       .endproc                        ; RET               ; }

*********************************************************************
* Writes a "bandit closing the door" to the door flags/ cache.
init_bandit_shot:                     ; ced8
       li   de,prep_bandit_shot       ; LD DE,$D1B7       ; {Writes #R$D1B7 to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov de,*hl                      ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,bandit_shot_source       ; LD HL,$D07D       ; {Handles copying $0007 bytes of data from the address contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D07D.}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F.
                                       ; LD ($D18F),A      ; }
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; Score?
       .ret                            ; RET               ;

*********************************************************************
* Writes "Bowie" to the door flags/ cache.
init_bowie:                            ; cefc
       li   de,prep_bowie              ; LD DE,$D1DC       ; {Writes #R$D1DC to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number             ; CALL $D8B0        ;
       andi a,8*256                    ; AND $08           ;
       li   hl,bowie_source            ; LD HL,$D084       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  init_bowie_set_flag        ; JR Z,$CF16        ;
       movb one,*hl                    ; LD (HL),$01       ;
init_bowie_set_flag:                   ; cf16
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>0009                   ; LD BC,$0009       ;
       .ldir                           ; LDIR              ;
       li   de,bowie_shot_action       ; LD DE,$D863       ;
       mov  de,@4(ix)                  ; LD (IX+$04),E     ;
                                       ; LD (IX+$05),D     ;
       .ret                            ; RET               ;

*********************************************************************
* Writes a "customer opening the door" to the door flags/ cache.
init_customer_jordan:                  ; cf2b
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number             ; CALL $D8B0        ;
       andi a,130*256                  ; AND $82           ;
       li   hl,jordan_source_2         ; LD HL,$D0A1       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_jordan_set_flag  ; JR NZ,$CF45       ;
       movb one,*hl                    ; LD (HL),$01       ;
init_cust_jordan_set_flag:             ; cf45
       li   hl,jordan_source_1         ; LD HL,$D09C       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ;
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ;
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ;
       .ret                            ;
!
       .ldir                           ; LDIR              ;
       .ret                            ; RET               ;

*********************************************************************
*
init_customer_daisy:                   ; cf5e
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number_x           ; CALL $D8B0        ;
       andi a,65*256                   ; AND $41           ;
       li   hl,daisy_source_2          ; LD HL,$D092       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_daisy_set_flag   ; JR NZ,$CF78       ;
       movb one,*hl                    ; LD (HL),$01       ;
init_cust_daisy_set_flag:              ; cf78
       li   hl,daisy_source_1          ; LD HL,$D08D       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ;
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ;
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ;
       .ret                            ;
!
       .ldir                           ; LDIR              ;
       .ret                            ; RET               ;

*********************************************************************
* Writes a "customer being shot" to the door flags/ cache.
init_customer_shot:                    ; cf91
       li   de,prep_customer_shot      ; LD DE,$D226       ; {Writes #R$D226 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; {Loads e.g. #R$D167 (depending on which door is currently
                                       ; LD D,(IX+$03)     ; being actioned) into #REGde.}
       li   hl,customer_shot_source    ; LD HL,$D0AB       ; #REGhl=#R$D0AB.
       ai   de,6                       ; INC DE            ; {Increase #REGde by $06.
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ; }
       li   bc,>0003                   ; LD BC,$0003       ; {Copies three sequential bytes of data from #REGhl to
       .ldir                           ; LDIR              ; #REGde.}
       li   hl,copy_char_data_flag     ; LD HL,$D18F       ; {Writes $01 to #R$D18F and return.
       movb one,*hl                    ; LD (HL),$01       ;
       .ret                            ; RET               ; }

*********************************************************************
* Writes "Julius opening the door" to the door flags/ cache.
init_julius_open:                      ; cfb7
       li   de,prep_julius_open        ; LD DE,$D241       ; {Writes #R$D241 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_open_source      ; LD HL,$D0AE       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       bl   @random_number             ; CALL $D8B0        ;
       andi a,32*256                   ; AND $20           ;
       jne  init_julius_open_set_flag  ; JR NZ,$CFD1       ;
       movb one,*hl                    ; LD (HL),$01       ;
init_julius_open_set_flag:             ; cfd1
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000a                   ; LD BC,$000A       ;
       .ldir                           ; LDIR              ;
       .ret                            ; RET               ;

*********************************************************************
* Writes "Julius closing the door" to the door flags/ cache.
init_julius_shot:                      ; cfdd
       movb one,@julius_close_source   ; LD A,$01          ; Inderectly sets julius_flag {Writes $01 to #R$D0B8.
                                       ; LD ($D0B8),A      ; }
init_julius_shot_2:                    ; cfe2
       li   de,prep_julius_close       ; LD DE,$D265       ; {Writes #R$D265 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_close_source     ; LD HL,$D0B8       ; {Handles copying $0009 bytes of data from the address (plus 1) contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       inc  de                         ; INC DE            ; { =h Address | =h Door }
       li   bc,>0009                   ; LD BC,$0009       ; { #R$D167 | Door 1 }
       .ldir                           ; LDIR              ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D0B8.}
       movb one,@copy_char_data_flag   ; LD A,$01          ;
                                       ; LD ($D18F),A      ;
       li   hl,julius_close_source     ; LD HL,$D0B8       ;
       movb *hl,a                      ; LD A,(HL)         ;
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ;
       movb a,a                        ; AND A             ;
       jeq  init_julius_shot_1         ; RET Z             ;
       sb   a,a                        ; XOR A             ;
       movb a,@7(ix)                   ; LD (IX+$07),A     ;
       movb a,@6(ix)                   ; LD (IX+$06),A     ;
       movb a,*hl                      ; LD (HL),A         ;
init_julius_shot_1:
       .ret                            ; RET               ;

*********************************************************************
* Routine at D019
*
* Used by the routine at #R$CE21.
init_bandit_draw_open:                 ; d019
       li   de,prep_bandit_draw_open   ; LD DE,$D289       ; {Writes #R$D289 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @12(ix),hl                 ; LD L,(IX+$0C)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0D)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D171 | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17F | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18D | #R$D183 | Door 3 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

*********************************************************************
* Routine at D037
init_bandit_draw_shot_1:               ; d037
       movb one,a                      ; LD A,$01          ; {Writes $01 to the address contained
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       movb a,*hl                      ; LD (HL),A         ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; This is the first byte of character state data.}
init_bandit_draw_shot_2:                ; d040
       li   de,prep_bandit_draw_shot   ; LD DE,$D2AD       ; {Writes #R$D2AD to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#
                                                           ; This is copying the actual source data into the cache where it can be manipulated by the game events.
                                                           ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D16F | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17D | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18B | #R$D183 | Door 3 }
                                                           ; TABLE#}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Initialise #R$D18F (writes $01 to it).
                                       ; LD ($D18F),A      ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Loads #REGa with the flag from the address contained
                                       ; LD H,(IX+$0B)     ; at (depending on which door is currently being actioned);
       movb *hl,a                      ; LD A,(HL)         ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; As per #R$D037, this should be $01.}
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       ; AND A                         ; AND A             ;
       movb a,a
       jne  !                          ; RET Z             ;
       .ret                            ;
!
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; Score?
       sb   *hl,*hl                    ; LD (HL),$00       ;
       .ret                            ; RET               ; Return.

*********************************************************************
* Copy Source Character Data To Character State Data.
*
* Handles copying a "normal" bandit into the bandit state cache at #R$D71E.
prep_bandit_open:                      ; d192
*      Set hl = pointer to door source data
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
*      Copy 7 bytes from door source data to bandit state
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       bl   @bandit_open_routing       ; CALL $D725        ; Call #R$D725 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP DE            ;
       .pop de                         ; POP HL            ; }
                                       ; EX DE,HL          ; Swap the source and target. Use pop hl pop de
*      If flag is set then reset and copy state data back to door source data
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}

*********************************************************************
prep_bandit_shot:                      ; d1b7
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       bl   @bandit_shot_routing       ; CALL $D771        ; Call #R$D771 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP DE            ;
       .pop de                         ; POP HL            ; }
                                       ; EX DE,HL          ; Swap the source and target. Use pop hl pop de
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}

*********************************************************************
* Handles copying Bowie state data into the state cache at #R$D7C5.
prep_bowie:                            ; d1dc
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0009 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bowie_good_bad          ; LD DE,$D7C5       ; #TABLE(default,centre,centre)
       li   bc,>0009                   ; LD BC,$0009       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D7C5.}
       bl   @bowie_routing             ; CALL $D7CE        ; Call #R$D7CE to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP DE            ;
       .pop de                         ; POP HL            ; }
                                       ; EX DE,HL          ; Swap the source and target. Use pop hl pop de
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}

*********************************************************************
* Handles copying customer state data into the state cache at #R$D48F.
prep_customer:                         ; d201
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       bl   @customer_routing          ; CALL $D49E        ; Call #R$D49E to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP DE            ;
       .pop de                         ; POP HL            ; }
                                       ; EX DE,HL          ; Swap the source and target. Use pop hl pop de
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}

*********************************************************************
* Handles copying customer "is shot" state data into the state cache at
* #R$D48F.
prep_customer_shot:                    ; d226
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       bl   @customer_shot             ; CALL $D57B        ; Call #R$D57B.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP DE            ;
       .pop de                         ; POP HL            ; }
                                       ; EX DE,HL          ; Swap the source and target. Use pop hl pop de
       .ldir                           ; LDIR              ; {Copy the (swapped) source back to the new target and
       .ret                            ; RET               ; return.}

*********************************************************************
* Handles copying Julius state data into the state cache at #R$D8E5.
prep_julius_open:                      ; d241
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       bl   @julius_open_routing      ; CALL $D8EF        ; Call #R$D8EF.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jne  prep_julius_open_1         ; RET NZ            ; }
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
prep_julius_open_1:
       .ret                            ; RET               ; }

*********************************************************************
* And copying a successful Julius encounter to close the door.
prep_julius_close:                     ; d265
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       bl   @julius_close_routing      ; CALL $D997        ; Call #R$D997.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jne  prep_julius_close_1        ; RET NZ            ; }
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
prep_julius_close_1:
       .ret                            ; RET               ; }

*********************************************************************
* Handles copying a "drawing bandit" into the bandit state cache at #R$DA0C.
prep_bandit_draw_open:                 ; d289
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       bl   @bandit_draw_open_routing ; CALL $DA17        ; Call #R$DA17.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }

*********************************************************************
* And copying a successful "drawing bandit" encounter to close the door.
prep_bandit_draw_shot:                 ; d2ad
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       bl   @bandit_draw_shot_routing  ; CALL $DA85        ; Call #R$DA85.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. If it wasn't zero then
       ; AND A                         ; AND A             ; return.
*      HERE
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ; *** Suspicious that flag was not set to 0
*      HERE
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
customer_routing:                      ; d49e
       .proc
       li   hl,customer_state_ref      ; LD HL,$D495       ; {#REGa=#R$D495.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  customer_open_1            ; JR Z,$D4BD        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  customer_open_2            ; JR Z,$D4CD        ; { $01 | #R$D4BD }
       sb   one,a                      ; DEC A             ; { $02 | #R$D4CD }
       jeq  customer_open_3            ; JR Z,$D4DD        ; { $03 | #R$D4DD }
       sb   one,a                      ; DEC A             ; { $04 | #R$D4ED }
       jeq  customer_open_4            ; JR Z,$D4ED        ; { $05 | #R$D524 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D540 }
       jeq  customer_uncover           ; JP Z,$D524        ; { $07 | #R$D559 }
       sb   one,a                      ; DEC A             ; { $08 | #R$D56C }
       jeq  customer_close_3           ; JP Z,$D540        ; TABLE#
       sb   one,a                      ; DEC A             ;
       jeq  customer_close_2           ; JP Z,$D559        ;
       jmp  customer_close_1           ; JP $D56C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
customer_open_1:                       ; d4bd
                                       ; LD A,($D496)      ; {Decrease #R$D496 by one, return if result is not
       sb   one,@customer_1_timer      ; DEC A             ; zero.
                                       ; LD ($D496),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       jmp  customer_routing_end       ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
customer_open_2:                       ; d4cd
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Call #R$D6DF and return.
       jmp  customer_routing_end       ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
customer_open_3:                       ; d4dd
                                       ; LD A,($D498)      ; {Decrease #R$D498 by one, return if result is not
       sb   one,@customer_3_timer      ; DEC A             ; zero.
                                       ; LD ($D498),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  customer_routing_end       ; RET               ; }
* Handle door frame 4 timer...
customer_open_4:                       ; d4ed
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D499)      ; {Decrease #R$D499 by one, return if result is not
       sb   one,@customer_4_timer      ; DEC A             ; zero.
                                       ; LD ($D499),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       movb @customer_flag_uncover,a   ; LD A,($D494)      ; {Jump to #R$D516 if #R$D494 is not zero.
       ; AND A                         ; AND A             ;
       jne  customer_hands_up          ; JR NZ,$D516       ; }
       movb @bytes+7,*hl               ; LD (HL),$07       ; Set #R$D495 to use state $07 (#R$D559 on the next call
                                                           ; to #R$D49E).
       movb @customer_frame_1,a        ; LD A,($D48F)      ; {Call #R$D6DF using the character frame index from
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D48F.}
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; Issue 500 points (by writing $05 to the high order
                                                           ; byte of, e.g. #R$D16B).
                                       ; LD A,$01          ; {Register this as a deposit (by writing $01 to e.g.
       movb one,@8(ix)                 ; LD (IX+$08),A     ; #R$D16D).}
       movb one,@deposit_flag          ; LD ($D190),A      ; Writes $01 to #R$D190.
       jmp  customer_routing_end       ; RET               ; Return.
* Handle customer putting their hands up.
customer_hands_up:                     ; d516
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_2,a        ; LD A,($D490)      ; Grab the character frame index from #R$D490.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  customer_routing_end       ; RET               ; }
* Handles customer uncovering a "hidden" bandit action.
customer_uncover:                      ; d524
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D49A)      ; {Decrease #R$D49A by one, return if result is not
       sb   one,@customer_5_timer      ; DEC A             ; zero.
                                       ; LD ($D49A),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_3,a        ; LD A,($D491)      ; Grab the character frame index from #R$D491.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  customer_routing_end       ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
customer_close_3:                      ; d540
                                       ; LD A,($D49B)      ; {Decrease #R$D49B by one, return if result is not
       sb   one,@customer_6_timer      ; DEC A             ; zero.
                                       ; LD ($D49B),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       bl   @call_init_bandit_open         ; CALL $CEB8         ; Call #R$CEB8.
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Load, e.g. #R$D167 (bandit source data) into #REGhl, and
                                       ; LD H,(IX+$03)     ; write $03 to the address contained in it.
       movb @bytes+3,*hl+              ; LD (HL),$03       ; }
       inct hl                         ; INC HL            ; {Increase the pointer to the bandit source data by 3 and
                                       ; INC HL            ; write $04 to this byte.
                                       ; INC HL            ;
       movb @bytes+4,*hl               ; LD (HL),$04       ; }
       jmp  customer_routing_end       ; RET               ; Return.
* Handle door frame 3 countdown/ transition to door frame 2.
customer_close_2:                      ; d559
                                       ; LD A,($D49C)      ; {Decrease #R$D49C by one, return if result is not
       sb   one,@customer_7_timer      ; DEC A             ; zero.
                                       ; LD ($D49C),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       li   hl,customer_state_ref      ; LD HL,$D495       ; {Increase #R$D495 by one.
       ab   one,*hl                    ; INC (HL)          ; }
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       jmp  customer_routing_end       ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
customer_close_1:                      ; d56c
                                       ; LD A,($D49D)      ; {Decrease #R$D49D by one, return if result is not
       sb   one,@customer_8_timer      ; DEC A             ; zero.
                                       ; LD ($D49D),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; {Call #R$D8A1 and return.
       jmp  customer_routing_end       ; RET               ; }

* Handles customer being shot.
customer_shot:                         ; d57b
       .proc
       li   hl,customer_state_ref      ; LD HL,$D495       ; {If #R$D495 is zero then jump to #R$D584 else jump to
       movb *hl,a                      ; LD A,(HL)         ; #R$D58C.
       sb   one,a                      ; DEC A             ;
       jeq  customer_shot_midair       ; JR Z,$D584        ;
       jmp  customer_shot_floor        ; JR $D58C          ; }
customer_shot_midair:                  ; d584
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_4,a        ; LD A,($D492)      ; Grab the character frame index from #R$D492.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  customer_routing_end       ; RET               ; }
customer_shot_floor:                   ; d58c
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jne  customer_routing_end       ; RET NZ            ; }
       movb @customer_frame_5,a        ; LD A,($D493)      ; Grab the character frame index from #R$D493.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; Call #R$D6ED.
                                       ; LD A,$02          ; {Writes $02 to #R$D2FE.
       movb @bytes+2,@player_died_status ; LD ($D2FE),A      ; }
       bl   @reset_door_routine        ; CALL $D8A1        ; {Call #R$D8A1 and return.
customer_routing_end:
       .endproc                        ; RET               ; }

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_open_routing:                   ; d725
       .proc
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_open_1              ; JR Z,$D734        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_open_2              ; JR Z,$D741        ; { $01 | #R$D734 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D741 }
       jeq  bandit_open_3              ; JR Z,$D74E        ; { $03 | #R$D74E }
       jmp  bandit_open_4              ; JR $D75B          ; { $04 | #R$D75B }
                                                           ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_open_1:                         ; d734
                                       ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,@bandit_1_timer                                ; DEC A             ;
                                       ; LD ($D71F),A      ;
       jne  bandit_open_5              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Pass character frame index (#R$6800(draw | $00)) to
       jmp  bandit_open_5              ; RET               ; #R$D6D1 and return.}
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_open_2:                         ; d741
                                       ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,@bandit_2_timer        ; DEC A             ;
                                       ; LD ($D720),A      ;
       jne  bandit_open_5              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Pass character frame index (#R$6800(draw | $00)) to
       jmp  bandit_open_5              ; RET               ; #R$D6DF and return.}
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_open_3:                         ; d74e
                                       ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,@bandit_3_timer        ; DEC A             ;
                                       ; LD ($D721),A      ;
       jne  bandit_open_5              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Pass character frame index (#R$6800(draw | $00)) to
       jmp  bandit_open_5              ; RET               ; #R$D6ED and return.}
* Handle door frame 4 timer...
bandit_open_4:                         ; d75b
       li   de,init_bandit_shot        ; LD DE,$CED8       ; {Calls #R$D5A3 with #REGde=$CED8.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,@bandit_4_timer        ; DEC A             ;
                                       ; LD ($D722),A      ;
       jne  bandit_open_5              ; RET NZ            ; }
                                       ; INC A             ; {Writes $01 to #R$D2FE.
       movb one,@player_died_status    ; LD ($D2FE),A      ; }
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
bandit_open_5:
       .endproc                            ; RET               ; Return.

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_shot_routing:                  ; d771
       .proc
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_shot_1              ; JR Z,$D783        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_shot_2              ; JR Z,$D789        ; { $01 | #R$D783 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D789 }
       jeq  bandit_shot_3              ; JR Z,$D798        ; { $03 | #R$D798 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D7A7 }
       jeq  bandit_shot_4              ; JR Z,$D7A7        ; { $05 | #R$D7B6 }
       jmp  bandit_shot_5              ; JR $D7B6          ; TABLE#}
* Handles the transition to the (#R$6A10(shot | $01)) frame in the open
* doorway.
bandit_shot_1:                         ; d783
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       ab   one,a                      ; INC A             ; Move onto next character frame (i.e. #R$6A10(shot |
                                                           ; $01)).
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  bandit_shot_return         ; RET               ; }
* Handle "floor frame in open doorway" countdown.
bandit_shot_2:                        ; d789
                                       ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,@bandit_1_timer        ; DEC A             ;
                                       ; LD ($D71F),A      ;
       jne  bandit_shot_return         ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)) to
       bl   @draw_door_frame_4         ; CALL $D6ED        ; #R$D6ED and return.
       jmp  bandit_shot_return         ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_shot_3:                         ; d798
                                       ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,@bandit_2_timer        ; DEC A             ;
                                       ; LD ($D720),A      ;
       jne  bandit_shot_return          ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_3         ; CALL $D6DF        ; it to #R$D6DF and return.
       jmp  bandit_shot_return         ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_shot_4:                        ; d7a7
                                       ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,@bandit_3_timer        ; DEC A             ;
                                       ; LD ($D721),A      ;
       jne  bandit_shot_return         ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_2         ; CALL $D6D1        ; it to #R$D6D1 and return.
       jmp  bandit_shot_return         ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_shot_5:                        ; d7b6
                                       ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,@bandit_4_timer        ; DEC A             ;
                                       ; LD ($D722),A      ;
       jne  bandit_shot_return         ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
bandit_shot_return:
       .ret                            ; RET               ; Return.

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
bowie_routing:                         ; d7ce
       .proc
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {#REGa=#R$D7C7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to jump to based on the current state.
       jeq  bowie_open_1               ; JR Z,$D7E3        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bowie_open_2               ; JR Z,$D7F2        ; { $01 | #R$D7E3 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D7F2 }
       jeq  bowie_open_3               ; JR Z,$D801        ; { $03 | #R$D801 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D810 }
       jeq  bowie_open_4               ; JR Z,$D810        ; { $05 | #R$D82C }
       sb   one,a                      ; DEC A             ; { $06 | #R$D83C }
       jeq  bowie_close_2              ; JR Z,$D82C        ; TABLE#
       jmp  bowie_close_1              ; JR $D83C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
bowie_open_1:                          ; d7e3
                                       ; LD A,($D7C8)      ; {Decrease #R$D7C8 by one, return if result is not
       sb   one,@bowie_1_timer         ; DEC A             ; zero.
                                       ; LD ($D7C8),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6D1 and
       bl   @draw_door_frame_2         ; CALL $D6D1        ; return.
       jmp  bowie_routing_end          ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bowie_open_2:                          ; d7f2
                                       ; LD A,($D7C9)      ; {Decrease #R$D7C9 by one, return if result is not
       sb   one,@bowie_2_timer         ; DEC A             ; zero.
                                       ; LD ($D7C9),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6DF and
       bl   @draw_door_frame_3         ; CALL $D6DF        ; return.
       jmp  bowie_routing_end          ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bowie_open_3:                          ; d801
                                       ; LD A,($D7CA)      ; {Decrease #R$D7CA by one, return if result is not
       sb   one,@bowie_3_timer         ; DEC A             ; zero.
                                       ; LD ($D7CA),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character frame index #R$9FB0($1B) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       jmp  bowie_routing_end          ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bowie_open_4:                          ; d810
       mov  @4(ix),de                  ; LD E,(IX+$04)     ; {Call #R$D5A3 with a callback to either #R$D84B or
                                       ; LD D,(IX+$05)     ; #R$D85D.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D7CB)      ; {Decrease #R$D7CB by one, return if result is not
       sb   one,@bowie_4_timer         ; DEC A             ; zero.
                                       ; LD ($D7CB),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
bowie_close_3:                         ; d821
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {Move onto next character state (#R$D7C7).
       ab   one,*hl                    ; INC (HL)          ; }
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_3         ; CALL $D6DF        ; to #R$D6DF and return.
       jmp  bowie_routing_end          ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bowie_close_2:                         ; d82c
                                       ; LD A,($D7CC)      ; {Decrease #R$D7CC by one, return if result is not
       sb   one,@bowie_5_timer         ; DEC A             ; zero.
                                       ; LD ($D7CC),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_2         ; CALL $D6D1        ; to #R$D6D1 and return.
       jmp  bowie_routing_end          ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bowie_close_1:                         ; d83c
                                       ; LD A,($D7CD)      ; {Decrease #R$D7CD by one, return if result is not
       sb   one,@bowie_6_timer         ; DEC A             ; zero.
                                       ; LD ($D7CD),A      ;
       jne  bowie_routing_end          ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
       jmp  bowie_routing_end          ; RET               ; Return.

* Handles marking this as something shootable.
bowie_cash_action:                     ; d84b
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; {Writes $05 to #REGix+$06 and $01 to #REGix+$07.
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; } Score?
                                       ; LD A,$01          ; {Writes $01 to #REGix+$08 and #R$D190.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb one,@deposit_flag          ; LD ($D190),A      ; }
       jmp  bowie_close_3              ; JR $D821          ; Jump to #R$D821.

* Handles marking this as something unshootable.
bowie_bomb_action:                     ; d85d
                                       ; LD A,$05          ; {Writes $05 to #R$D2FE and return.
       movb @bytes+5,@player_died_status ; LD ($D2FE),A      ;
       jmp  bowie_routing_end          ; RET               ; }

* Handles both shooting the hats off Bowie's head, and checking/ routing on the
* last frame for the "surprise".
bowie_shot_action:                     ; d863
       li   hl,bowie_frame_ref         ; LD HL,$D7C6       ; {#REGa=#R$D7C6.
       movb *hl,a                      ; LD A,(HL)         ; }
       movb one,@6(ix)
       cb   a,@bytes+33                ; CP $21            ; Is it character frame reference (#R$AC10(1 hat |
                                                           ; $21))?
                                       ; LD (IX+$06),$01   ; Writes $01 to #REGix+$06.
       jhe  bowie_check                ; JR NC,$D875       ; If Bowie is on the last frame then jump forward to
                                                           ; #R$D875.
       ab   one,a                      ; INC A             ; {Else update #R$D7C6 to point at the next frame, call
       movb a,*hl                      ; LD (HL),A         ; #R$D6ED and return.
       bl   @draw_door_frame_4         ; CALL $D6ED        ;
       jmp  bowie_routing_end          ; RET               ; }

* Checks the "good/ bad" flag and routes the gameplay accordingly.
bowie_check:                           ; d875
       movb @bowie_good_bad,a          ; LD A,($D7C5)      ; {If #R$D7C5 is zero jump to #R$D87D.
       ; AND A                         ; AND A             ;
       jeq  bowie_state_cash           ; JR Z,$D87D        ; }
       jmp  bowie_state_bomb           ; JR $D88F          ; Jump to #R$D88F.

* Handle displaying cash character frame.
bowie_state_cash:                      ; d87d
       movb @bytes+35,a                ; LD A,$23          ; {Writes character frame reference #R$B030(cash | $23)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; }
       li   hl,bowie_cash_action       ; LD HL,$D84B       ; {Writes #R$D84B to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
       jmp  bowie_routing_end          ; RET               ; Return.
* Handle displaying bomb character frame.
bowie_state_bomb:                      ; d88f
       movb @bytes+34,a                ; LD A,$22          ; {Writes character frame reference #R$AE20(bomb | $22)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; }
       li   hl,bowie_bomb_action       ; LD HL,$D85D       ; {Writes #R$D85D to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
bowie_routing_end:
       .ret                            ; RET               ; Return.

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
julius_open_routing:                   ; d8ef
       .proc
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_open_1              ; JR Z,$D907        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_open_2              ; JR Z,$D916        ; { $01 | #R$D907 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D916 }
       jeq  julius_open_3              ; JR Z,$D925        ; { $03 | #R$D925 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D934 }
       jeq  julius_open_4              ; JR Z,$D934        ; { $05 | #R$D963 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D972 }
       jeq  julius_open_5              ; JR Z,$D963        ; { $07 | #R$D981 }
       sb   one,a                      ; DEC A             ; TABLE#
       jeq  julius_open_6              ; JR Z,$D972
       jmp  julius_open_7              ; JR $D981          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
julius_open_1:                         ; d907
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>24,a               ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2         ; CALL $D6D1        ; #R$D6D1 and return.
       jmp  julius_open_8              ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
julius_open_2:                         ; d916
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>24,a               ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D6DF and return.
       jmp  julius_open_8              ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
julius_open_3:                         ; d925
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>24,a               ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_4         ; CALL $D6ED        ; #R$D6ED and return.
       jmp  julius_open_8              ; RET               ; }
* Handle door frame 4 countdown.
julius_open_4:                         ; d934
       li   de,init_julius_shot        ; LD DE,$CFDD       ; {Call #R$D5A3 with a callback to #R$CFDD.
!      bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @julius_good_bad,a         ; LD A,($D8E5)      ; {Jump to #R$D951 if #R$D8E5 is zero (Julius is
       ; AND A                         ; AND A             ; "good").
       jeq  julius_state_4_close       ; JR Z,$D951        ; }
* Changes the frame to show Julius drawing his pistol.
       movb @bytes+7,*hl               ; LD (HL),$07       ; Writes "07" to #R$D8E7.
       movb @bytes+>25,a               ; LD A,$25          ; {Pass character index (#R$B450(draw | $25)) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       jmp  julius_open_8              ; RET               ; }
* Set up (and begin) closing the door.
julius_state_4_close:                  ; d951
       movb @bytes+>24,a               ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D6DF.}
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ;
       jmp  julius_open_8              ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_open_5:                         ; d963
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>24,a               ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2         ; CALL $D6D1        ; #R$D6D1 and return.
       jmp  julius_open_8              ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_open_6:                         ; d972
                                       ; LD A,($D8ED)      ; {Decrease #R$D8ED by one, return if result is not
       sb   one,@julius_6_timer        ; DEC A             ; zero.
                                       ; LD ($D8ED),A      ;
       jne  julius_open_8              ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
       jmp  julius_open_8              ; RET               ; Return.

julius_open_7:                         ; d981
       li   de,init_julius_shot_2      ; LD DE,$CFE2       ; {Call #R$D5A3 with a callback to #R$CFE2.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($D8EE)      ; {Decrease #R$D8EE by one, return if result is not
       sb   one,@julius_7_timer        ; DEC A             ; zero.
                                       ; LD ($D8EE),A      ;
       jne  julius_open_8              ; RET NZ            ; }
                                       ; INC A             ; Move onto next character state.
       movb one,@player_died_status    ; LD ($D2FE),A      ; Write $01 to #R$D2FE.
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
julius_open_8:
       .endproc                        ; RET               ; Return.

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
julius_close_routing:                  ; d997
       .proc
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_close_1             ; JR Z,$D9A9        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_close_2             ; JR Z,$D9B8        ; { $01 | #R$D9A9 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D9B8 }
       jeq  julius_close_3             ; JR Z,$D9D3        ; { $03 | #R$D9D3 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D9E2 }
       jeq  julius_close_4             ; JR Z,$D9E2        ; { $05 | #R$D9F1 }
       jmp  julius_close_5             ; JR $D9F1          ; TABLE#}
* Handles state countdown/ transition to character frame #R$B660($26).
julius_close_1:                        ; d9a9
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jne  julius_close_6             ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>2d,a               ; LD A,$26          ; {Pass character index #R$B660(shot | $26) to #R$D6ED
       movb @julius_flag,tmp0
       jne  !
       ab   one,a
!      bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       jmp  julius_close_6             ; RET               ; }
* Handles state countdown/ transition to character frame #R$B870($27).
julius_close_2:                        ; d9b8
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jne  julius_close_6             ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>27,a               ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6ED.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; }
       movb @julius_flag,a             ; LD A,($D8E6)      ; {Return if #R$D8E6 is zero.
       ; AND A                         ; AND A             ;
       jeq  julius_close_6             ; RET  Z            ; }
                                       ; INC A             ; {Else write #R$D8E6+1 to #R$D2FE, call #R$D8A1 and
       movb @bytes+2,@player_died_status ; LD ($D2FE),A      ; return.
       bl   @reset_door_routine        ; CALL $D8A1        ;
       jmp  julius_close_6             ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
julius_close_3:                        ; d9d3
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jne  julius_close_6             ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>27,a               ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6DF
       bl   @draw_door_frame_3         ; CALL $D6DF        ; and return.
       jmp  julius_close_6             ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_close_4:                        ; d9e2
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jne  julius_close_6             ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+>27,a               ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6D1
       bl   @draw_door_frame_2         ; CALL $D6D1        ; and return.
       jmp  julius_close_6             ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_close_5:                        ; d9f1
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jne  julius_close_6             ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; Call #R$D8A1.
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ;
julius_close_6:
       .ret                            ; RET               ; }

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_open_routing:              ; da17
       .proc
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_open_1         ; JR Z,$DA29        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_open_2         ; JR Z,$DA39        ; { $01 | #R$DA29 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DA39 }
       jeq  bandit_draw_open_3         ; JR Z,$DA49        ; { $03 | #R$DA49 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DA59 }
       jeq  bandit_draw_open_4         ; JR Z,$DA59        ; { $05 | #R$DA6F }
       jmp  bandit_draw_open_5         ; JR $DA6F          ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_draw_open_1:                    ; da29
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jne  bandit_draw_open_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       jmp  bandit_draw_open_return    ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_draw_open_2:                    ; da39
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jne  bandit_draw_open_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Call #R$D6DF and return.
       jmp  bandit_draw_open_return    ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_draw_open_3:                    ; da49
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jne  bandit_draw_open_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  bandit_draw_open_return    ; RET               ; }
* Handles state countdown.
bandit_draw_open_4:                    ; da59
       li   de,init_bandit_draw_shot_1 ; LD DE,$D037       ; {Call #R$D5A3 with a callback to #R$D037.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jne  bandit_draw_open_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_2,a     ; LD A,($DA0E)      ; Grab the character frame index from #R$DA0E.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  bandit_draw_open_return    ; RET               ; }
* Handles state countdown.
bandit_draw_open_5:                    ; da6f
       li   de,init_bandit_draw_shot_2 ; LD DE,$D040       ; {Call #R$D5A3 with a callback to #R$D040.
       bl   @hit_detection             ; CALL $D5A3        ; }
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jne  bandit_draw_open_return    ; RET NZ            ; }
       mov  one,@player_died_status    ; INC A             ; {Else write $01 to #R$D2FE, call #R$D8A1 and return.
                                       ; LD ($D2FE),A      ;
       bl   @reset_door_routine        ; CALL $D8A1        ;
bandit_draw_open_return:
       .ret                            ; RET               ; }

*********************************************************************
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_shot_routing:              ; da85
       .proc
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_shot_1         ; JR Z,$DA97        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_shot_2         ; JR Z,$DAA7        ; { $01 | #R$DA97 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DAA7 }
       jeq  bandit_draw_shot_3         ; JR Z,$DAC0        ; { $03 | #R$DAC0 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DAD0 }
       jeq  bandit_draw_shot_4         ; JR Z,$DAD0        ; { $05 | #R$DAE0 }
       jmp  bandit_draw_shot_5         ; JR $DAE0          ; TABLE#}
* Handles state countdown.
bandit_draw_shot_1:                    ; da97
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jne  bandit_draw_shot_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_3,a     ; LD A,($DA0F)      ; Grab the character frame index from #R$DA0F.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       jmp  bandit_draw_shot_return    ; RET               ; }
* Handles state countdown.
bandit_draw_shot_2:                    ; daa7
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jne  bandit_draw_shot_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; Call #R$D6ED.
       movb @bandit_draw,a             ; LD A,($DA0C)      ; {Return if #R$DA0C is zero.
       ; AND A                         ; AND A             ;
       jeq  bandit_draw_shot_return    ; RET Z             ; }
       mov  @bytes+2,@player_died_status ; INC A             ; {Else write $01 to #R$D2FE and return.
                                       ; LD ($D2FE),A      ;
       jmp  bandit_draw_shot_return    ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_draw_shot_3:                    ; dac0
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jne  bandit_draw_shot_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Call #R$D6DF and return.
       jmp  bandit_draw_shot_return    ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_draw_shot_4:                    ; dad0
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jne  bandit_draw_shot_return    ; RET NZ            ; }
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       jmp  bandit_draw_shot_return    ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_draw_shot_5:                    ; dae0
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jne  bandit_draw_shot_return    ; RET NZ            ; }
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       bl   @reset_door_routine        ; CALL $D8A1        ; {Call #R$D8A1 and return.
bandit_draw_shot_return:
       .ret                            ; RET               ; }

*********************************************************************
* Hit Detection.
*
* Compares the #R$CE1A against the user input for a shot.
* If there isn't a shot to account for then we simply return,
* else we action a jump to the address held in #REGde on entry.
hit_detection:                         ; d5a3
       .proc
                                       ; PUSH HL           ; Store #REGhl on the stack for later.
                                       ; LD A,($D300)      ; {Does a comparison of #R$D300 against #R$CE1A.
                                       ; LD HL,$CE1A       ;
       cb   @hit,@door_frame_ref       ; CP (HL)           ; }
                                       ; POP HL            ; {#HTML(Retrieve #REGhl off the stack and return if the
       jne  hit_detection_1            ; RET NZ            ; numbers compared were <em>NOT</em> the same.)}
       .pop af                         ; POP AF            ; Drop return address
       .ex_de_hl                       ; EX DE,HL          ; {Jumps to the address held in #REGde on entry (with
       b    *hl                        ; JP (HL)           ;
hit_detection_1:
       .endproc

