*********************************************************************
*      West bank for the TI-99/4A
*
       limi 0
       lwpi wrksp
       bl   @setup_environment
;       bl   @perform_duel
       b    @start
*
*********************************************************************
* Level Selection
* 
* Used by the routine at #R$FE00.
level_select:                          ; 6380
       bl   @ti_clear_screen
       li   tmp0,>0500
       li   tmp1,>0028
       li   tmp2,>2008
       bl   @ti_draw_color_area
       li   tmp0,>0d00
       li   tmp1,>0020
       li   tmp2,>2003
       bl   @ti_draw_color_area
* Prints the labels to the screen.
       li   hl,level_select_one        ; LD HL,$64AC       ; {Pass #R$64AC to #R$647C (index "1").
       movb one,a                      ; LD A,$01          ; 
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_three      ; LD HL,$64B3       ; {Pass #R$64B3 to #R$647C (index "2").
       movb @bytes+2,a                 ; LD A,$02          ; 
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_six        ; LD HL,$64BA       ; {Pass #R$64BA to #R$647C (index "3").
       movb @bytes+3,a                 ; LD A,$03          ; 
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_copy       ; LD HL,$6492       ; {Points to #R$6492 and sends it to #R$5B80
       li   de,zx_screen+>0023         ; LD DE,$4023       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
* Prints the images to the screen.
       movb @bytes+37,a                ; LD A,$25          ; {Calls #R$643A with (#R$B450(draw | $25)) for index "1".
       movb one,b                      ; LD B,$01          ; 
       bl   @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+8,a                 ; LD A,$08          ; {Calls #R$643A with (#R$7880(draw | $08)) for index "2".
       movb @bytes+2,b                 ; LD B,$02          ; 
       bl   @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+25,a                ; LD A,$19          ; {Calls #R$643A with (#R$9B90(draw | $19)) for index "3".
       movb @bytes+3,b                 ; LD B,$03          ; 
       bl   @level_select_graphics    ; CALL $643A        ; }

* Loop for getting user keyboard input.
       li   hl,level                   ; LD HL,$5CB1       ; Used later for setting the current level at #R$5CB1.
level_select_input:                    ; 63e5
       li   r0,KEY_1
       bl   @ti_check_key
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1-2-3-4-5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {If "1" is pressed, jump to #R$63F4.
       jne  level_select_level_1       ; JR NC,$63F4        ; }
       li   r0,KEY_2
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "2" is pressed, jump to #R$6405.
       jne  level_select_level_3       ; JR NC,$6405        ; }
       li   r0,KEY_3
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "3" is pressed, jump to #R$6416.
       jne  level_select_level_6       ; JR NC,$6416       ; }
       jmp  level_select_input         ; JR $63E5          ; Cycle back to #R$63E5.
* Act on level being selected.
level_select_level_1:                  ; 63f4
       movb one,*hl                    ; LD (HL),$01       ; {Store $01 at #R$5CB1 and call #R$6427 with
       movb @bytes+38,a                ; LD A,$26          ; (#R$B660(shot | $26)) for index "1".
       movb one,b                      ; LD B,$01          ; 
       bl   @ls_animate_shot          ; CALL $6427        ; }
       movb one,a                      ; LD A,$01          ; {Jump to #R$6457 with #REGhl=#R$64AC and #REGa=$01.
       li   hl,level_select_one        ; LD HL,$64AC       ; 
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_3:                  ; 6405
       movb @bytes+2,*hl               ; LD (HL),$02       ; {Store $02 at #R$5CB1 and call #R$6427 with
       movb @bytes+9,a                 ; LD A,$09          ; (#R$7A90(shot | $09)) for index "2".
       movb @bytes+2,b                 ; LD B,$02          ; 
       bl   @ls_animate_shot          ; CALL $6427        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Jump to #R$6457 with #REGhl=#R$64B3 and #REGa=$02.
       li   hl,level_select_three      ; LD HL,$64B3       ; 
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_6:                  ; 6416
       movb @bytes+3,*hl               ; LD (HL),$03       ; {Store $03 at #R$5CB1 and call #R$6427 with
       movb @bytes+26,a                ; LD A,$1A          ; (#R$9DA0(shot | $1A)) for index "3".
       movb @bytes+3,b                 ; LD B,$03          ; 
       bl   @ls_animate_shot          ; CALL $6427        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$6457 with #REGhl=#R$64BA and #REGa=$03.
       li   hl,level_select_six        ; LD HL,$64BA       ; 
       b    @ls_text_flash             ; JP $6457          ; }

*********************************************************************
* Animates the selected bandit being shot.
ls_animate_shot:                       ; 6427
       .proc
       .push bc                        ; PUSH BC           ;
       bl   @level_select_graphics    ; CALL $643A        ; Call #R$643A.
       bl   @shot_sound_1              ; CALL $6500        ; Call #R$6500.
       movb @bytes+16,b                ; LD B,$10          ; {Short interrupt driven halt loop.
ls_animate_shot_halt_loop:             ; 6430
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6430        ; }
       jne  ls_animate_shot_halt_loop  ;                   
       .pop bc                         ; POP BC            ; 
       movb @bytes+39,a                ; LD A,$27          ; {Call #R$643A with (#R$B870(floor | $27)).
       bl   @level_select_graphics    ; CALL $643A        ; }
       .endproc                            ; RET               ; Return.

*********************************************************************
* Prints the images to the screen.
* a=character index
* b=position
level_select_graphics:                 ; 643a
       .proc
       clr  tmp2
       movb b,tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>20
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character_pattern
       .endproc                        ; RET               ; Return.

*********************************************************************
* Flashes the selected level text.
*
* Jump - not call
ls_text_flash:                         ; 6457
       movb @bytes+8,b                 ; LD B,$08          ; {This prints #R$64C1 and the passed level copy alternately with a delay caused by a HALT loop
       movb a,@c                       ; LD C,A            ; (which continues execution after an interrupt is fired), the sequence repeats $08 times.
ls_text_flash_loop:                    ; 645a
       .push hl                        ; PUSH HL           ; 
       .push bc                        ; PUSH BC           ; 
       movb @c,a                       ; LD A,C            ; 
       bl   @level_select_print       ; CALL $647C        ;
       movb @bytes+16,b                ; LD B,$10          ; 
ls_flash_halt_loop_1:                  ; 6462
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6462        ; 
       jne  ls_flash_halt_loop_1       ;                   
       li   hl,level_select_whitespace ; LD HL,$64C1       ; 
       .pop bc                         ; POP BC            ; 
       .push bc                        ; PUSH BC           ; 
       movb @c,a                       ; LD A,C            ; 
       bl   @level_select_print       ; CALL $647C        ;
       movb @bytes+16,b                ; LD B,$10          ; 
ls_flash_halt_loop_2:                  ; 6470
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6470        ; 
       jne  ls_flash_halt_loop_2       ;                   
       .pop bc                         ; POP BC            ; 
       .pop hl                         ; POP HL            ; 
       sb   one,b                      ; DJNZ $645A        ; 
       jne  ls_text_flash_loop         ;                   
       movb @c,a                       ; LD A,C            ; 
       bl   @level_select_print       ; CALL $647C         ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* Print level select copy to the screen.
level_select_print:                    ; 647c
       .proc
       li   de,zx_screen+>1022         ; LD DE,$5022       ; {First, work out which screen position to use;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre)
       jeq  level_select_print_1       ; JR Z,$648B        ; { =h #REGa | =h Screen Address }
       li   de,zx_screen+>102d         ; LD DE,$502D       ; { $01 | $5022 }
       sb   one,a                      ; DEC A             ; { $02 | $502D }
       jeq  level_select_print_1       ; JR Z,$648B        ; { $03 | $5038 }
       li   de,zx_screen+>1038         ; LD DE,$5038       ; TABLE#}
level_select_print_1:                  ; 648b
       li   bc,>0702                   ; LD BC,$0702       ; {Then call the print routine at #R$5B80.
       bl    @print_two_tone_text      ; CALL $5B80        ; #TABLE(default,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                        ; RET               ; Return.

* Level Selection Text
level_select_copy:                     ; 6492
       text 'CHOOSE THE LEVEL PREFERED',>ff                          ; "CHOOSE THE LEVEL PREFERED"
level_select_one:                      ; 64ac
       text ' ONE  ',>ff                                             ; "ONE"
level_select_three:                    ; 64b3
       text ' THREE',>ff                                             ; "THREE"
level_select_six:                      ; 64ba
       text '  SIX ',>ff                                             ; "SIX"
level_select_whitespace:               ; 64c1
       text '      ',>ff                                             ; "WHITESPACE"
**
* Sounds.
* 
* Shot sound 1.
shot_sound_1:                          ; 6537
       .proc
       li   ix,1
       bl   @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 2.
shot_sound_2:                          ; 653f
       .proc
       li   ix,2
       bl   @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 3.
shot_sound_3:                          ; 6547
       .proc
       li   ix,3
       bl   @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
play_shot_sound:                       ; 654f
       .proc
;      TODO: sound
       .ret                            ; RET               ; Return.

* BANG!
* 
* Used by the routines at #R$C687 and #R$CD47.
bang:                                  ; c000
       bl   @ti_clear_screen           ; CALL $C046        ; Clear the screen.
       li   tmp1,>0002
       bl   @bang_color
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F000 to #R$C061.
       li   hl,gfx_bang_frame_1        ; LD HL,$F000       ;
       bl   @bang_copy                ; CALL $C061        ; }
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F100 to #R$C061.
       li   hl,gfx_bang_frame_2        ; LD HL,$F100       ;
       bl   @bang_copy                ; CALL $C061        ; }
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F200 to #R$C061.
       li   hl,gfx_bang_frame_3        ; LD HL,$F200       ;
       bl   @bang_copy                ; CALL $C061        ; }
       bl   @shot_sound_2             ; CALL $6502        ; {Calls $6502 twice.
       bl   @shot_sound_2             ; CALL $6502        ; }
       movb @bytes+6,b                 ; LD B,$06          ; {Pass #R$F300 to #R$C061.
       li   hl,gfx_bang_frame_4        ; LD HL,$F300       ;
       bl   @bang_copy                ; CALL $C061        ; }
       movb @bytes+5,b                 ; LD B,$05          ; {Pass #R$F400 to #R$C061.
       li   hl,gfx_bang_frame_5        ; LD HL,$F400       ;
       bl   @bang_copy                ; CALL $C061        ; }
       movb @bytes+5,b                 ; LD B,$05          ; {Pass #R$F500 to #R$C061.
       li   hl,gfx_bang_frame_6        ; LD HL,$F500       ;
       bl   @bang_copy                ; CALL $C061        ; }
       movb @bytes+8,b                 ; LD B,$08          ; {Blanks the display by passing a
       li   tmp1,>0000                 ; LD HL,$5000       ; "clear" part of the screen buffer
       bl   @bang_color                ; CALL $C061        ; to #R$C061.}
       movb @bytes+64,b                ; LD B,$40          ; {Jump to #R$C06D.
       jmp  bang_halt_loop             ; JP $C06D          ; }

*********************************************************************
bang_copy:                             ; c061
       .proc
       seto @graphics_bank_select      ; PUSH BC           ; {Sets the screen location and the
       li   tmp2,>0804                 ; LD BC,$2008       ; bang image frame sizing, then
       li   tmp0,>0860                 ; LD DE,$480C       ; calls #R$C071, issues a short
       mov  hl,tmp1                    ; EX DE,HL          ; pause and ...
       bl   @ti_draw_graphics          ; CALL $C071        ;
                                       ; POP BC            ;
bang_halt_loop:                        ; c06d
       bl   @ti_vsync                  ; HALT              ;
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C06D        ; }
       jne  bang_halt_loop             ;
       .endproc                        ; RET               ; ...returns.
*// bank_copy

*********************************************************************
bang_color:
       .proc
       li   tmp0,>0860
       li   tmp2,>0804
       bl   @ti_draw_color_area
       .endproc
*// bang_color

*********************************************************************
* Routine at C3C0
* 
* Used by the routine at #R$C7C0.
perform_duel:
;       mov  a,@duel_counter           ; I think this was intended
       .call @perform_duel_main        ; CALL $C3DD        ; Call #R$C3DD.
                                       ; LD A,($C421)      ; Grab #R$C421.
       jnc  after_duel_1               ; JR NC,$C3C9       ;
       ab   one,@duel_counter          ; INC A             ;
after_duel_1:                          ; c3c9
       movb @duel_counter,a
       movb @bytes+32,b                ; LD B,$20          ; {Interrupt driven HALT loop ($20 cycles).
after_duel_loop:                       ; c3cb
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C3CB        ; }
       jne  after_duel_loop            ;
       movb a,@e                       ; LD E,A            ; 
       li   hl,lives                   ; LD HL,($5B86)     ; {Is #R$CC59 more than $06?
       movb *hl,a                      ; LD A,(HL)         ; Get lives
       cb   a,@bytes+6                 ; CP $06            ; }
       jl   after_duel_2               ; JR C,$C3D8        ; If so, jump to #R$C3D8.
       nop                             ; NOP               ; We have 6 lives or more ?
after_duel_2:
       ; AND A                         ; AND A             ; {If #R$CC59 @duel_counter is zero then return without carry.
       movb @e,a                       ; LD A,E            ; 
       jeq  !                          ; RET NZ            ; }
       b    @return_without_carry                            ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }
*// perform_duel

*********************************************************************
* Kicks off the duelling bonus round.
perform_duel_main:                     ; c3dd
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGde.
       .push de                        ; PUSH DE           ; }
       li   hl,duel_data               ; LD HL,$C3EA       ; {Copies $33 bytes of data from #R$C3EA to #R$5BC0 (and
       li   de,dueller_1               ; LD DE,$5BC0       ; across all three duellists).
       li   bc,>0033                   ; LD BC,$0033       ; 
       .ldir                           ; LDIR              ; }
       .pop de                         ; POP DE            ;
       .pop bc                         ; POP BC            ;
       movb b,a                        ; LD A,B            ; random number from caller
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C67F with #R$5BC0.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       movb @c,a                       ; LD A,C            ; random number from caller
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C67F with #R$5BD1.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       movb d,a                        ; LD A,D            ; random number from caller
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C67F with #R$5BE2.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       sb   a,a                        ; XOR A             ; {Reset the flags (writes $00 to #R$C6E2, #R$C6E3 and
       li   hl,duel_bang_flag          ; LD HL,$C6E2       ; #R$C6E4).
       movb a,*hl+                     ; LD (HL),A         ; clear duel_bang_flag
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear duel_lose_life
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear duel_extra_life
       movb @duel_counter,a            ; LD A,($C421)      ; #R$C421.
       socb one,a                      ; OR $01            ; min 1
       li   de,>0001                   ; CP $20            ;
       cb   a,@bytes+16                ; LD DE,$0001       ;
       jhe  duel_clear_screen          ; JR NC,$C463       ;
       movb a,b                        ; LD B,A            ; 
       li   de,>0010                   ; LD DE,$0020       ;
duel_prep_loop:                        ; c460              ; de = >20 - @duel_counter
       dec  de                         ; DEC DE            ; 
       sb   one,b                      ; DJNZ $C460        ; 
       jne  duel_prep_loop             ;                   
duel_clear_screen:                     ; c463
       mov  de,@duel_inner_iterations  ; LD ($C52E),DE     ; ....
* Clears down the screen buffer.
       bl   @ti_clear_screen
* Writes the attributes for the playfield (sky, grass, footer).
       li   tmp0,>0400
       li   tmp1,>0028
       li   tmp2,>200c
       bl   @ti_draw_color_area
       li   tmp0,>1000
       li   tmp1,>0020
       li   tmp2,>2004
       bl   @ti_draw_color_area
       li   tmp0,>1400
       li   tmp1,>0007
       li   tmp2,>2004
       bl   @ti_draw_color_area
* Creates the footer.
       li   hl,playfield_lives         ; LD HL,$C655       ; {Point to #R$C655 and print using #R$C6A7.
       bl   @duel_print_lives          ; CALL $C6A7        ; }
       bl   @draw_life_images          ; CALL $5B83        ;
       li   hl,playfield_score         ; LD HL,$C64D       ; {Point to #R$C64D and prints using #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       .call @draw_score               ; CALL $5B98        ; Writes the players score.
* Initialise duellers.
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Initialise #R$5BC0 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Initialise #R$5BD1 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ;
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Initialise #R$5BE2 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
* Count down 5-4-3-2-1...0!
countdown_initialise:                  ; c4c5
       movb @bytes+53,a                ; LD A,$35          ; {Initialise countdown to "5" seconds ($35 in ASCII),
countdown_loop:                        ; c4c7
       .push af                        ; PUSH AF           ; hold this at #R$C6E0.
       movb a,@duel_timer              ; LD ($C6E0),A      ; }
       .call @duel_print_countdown     ; CALL $C6D3        ; 
       movb @bytes+49,b                ; LD B,$31          ; {Short halt loop (1 second pause).
countdown_halt_loop:                   ; c4d0
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C4D0        ; }
       jne  countdown_halt_loop        ;                   
       .pop af                         ; POP AF            ; {Keep looping back to #R$C4C7 until the countdown is
       sb   one,a                      ; DEC A             ; "0" ($30 in ASCII).
       cb   a,@bytes+48                ; CP $30            ; 
       jne  countdown_loop             ; JR NZ,$C4C7       ; }
       movb @bytes+32,a                ; LD A,$20          ; {Blank the countdown timer by printing a "SPACE" ($20
       movb a,@duel_timer              ; LD ($C6E0),A      ; in ASCII) over the top of it.
       .call @duel_print_countdown     ; CALL $C6D3        ; }
       jmp  duel_outer_loop            ; JR $C4F9          ; Jump to #R$C4F9 and start the duel!

*********************************************************************
check_any_duellers_shot:               ; c4e3
       .proc
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C530 with #R$5BC0.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C530 with #R$5BD1.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C530 with #R$5BE2.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
duel_outer_loop:                       ; c4f9
       mov  @duel_inner_iterations,de  ; LD DE,($C52E)     ; {#REGde=#R$C52E and push it on the stack.
duel_inner_loop:                       ; c4fd
       .push de                        ; PUSH DE           ; }
       bl   @check_any_duellers_shot   ; CALL $C4E3        ;
       .pop de                         ; POP DE            ; 
       dec  de                         ; DEC DE            ; 
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  duel_inner_loop            ; JR NZ,$C4FD       ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_2               ; LD IX,$5BD1       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_3               ; LD IX,$5BE2       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       movb @8(ix),a                   ; LD A,(IX+$08)     ; Any duellers left?
       socb @25(ix),a                  ; OR (IX+$19)       ; 
       socb @42(ix),a                  ; OR (IX+$2A)       ; 
       jne  !                          ; JP Z,$C690        ; 
       b    @duel_complete             ;                   
!
       jmp  duel_outer_loop            ; JR $C4F9          ;

duel_inner_iterations:                 ; c52e
       data 31                                             ;

*********************************************************************
check_if_duellers_are_shot:            ; c530
       .proc
       bl   @duel_check_fire_at_3     ; CALL $C543        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       bl   @duel_check_fire_at_1     ; CALL $C550        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       bl   @duel_check_fire_at_2     ; CALL $C55D        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       .endproc                        ; RET               ; Return.

*********************************************************************
duel_check_fire_at_3:                  ; c543
       .proc
       bl   @execute_control_method    ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_3_1     ; RET Z             ; }
       movb a,tmp0                     ; BIT 0,A           ; right {If bit 0 is not zero then return setting #REGa to
       movb @bytes+3,a                 ;
       andi tmp0,1*256                 ; LD A,$03          ; $03.
       jne  duel_check_fire_at_3_1     ; RET NZ            ; }
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
duel_check_fire_at_3_1:
       .ret                            ; RET               ; }

*********************************************************************
duel_check_fire_at_1:                  ; c550
       .proc
       bl   @execute_control_method    ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_1_1     ; RET Z             ; }
       movb a,tmp0                     ; BIT 1,A           ; left {If bit 1 is not zero then return setting #REGa to
       movb one,a                      ;
       andi tmp0,2*256                 ; LD A,$01          ; $01.
       jne  duel_check_fire_at_1_1     ; RET NZ            ; }
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
duel_check_fire_at_1_1:
       .ret                            ; RET               ; }

*********************************************************************
duel_check_fire_at_2:                  ; c55d
       .proc
       bl   @execute_control_method    ; CALL $5B88        ;
       movb a,tmp0                     ; BIT 4,A           ; 
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_2_1     ; RET Z             ;
       movb a,tmp0
       sb   a,a                        ; AND $03           ;
       andi tmp0,3*256                 ; LD A,$00          ;
       jne  duel_check_fire_at_2_1     ; RET NZ            ;
       movb @bytes+2,a                 ; LD A,$02          ;
duel_check_fire_at_2_1:
       .endproc                        ; RET               ; Return.

*********************************************************************
check_if_dueller_is_shot:              ; c56b
       .proc
       cb   a,@3(ix)                   ; CP (IX+$03)       ; {If player fires at dueller then
       jeq  dueller_is_shot            ; JR Z,$C575        ; jump to #R$C575.}
       sb   @13(ix),@13(ix)            ; LD (IX+$0D),$00   ; 
       jmp  check_if_dueller_is_shot_1 ; RET               ; Return.
dueller_is_shot:                       ; c575
       movb @13(ix),a                  ; LD A,(IX+$0D)     ; 
       ; AND A                         ; AND A             ; 
       jne  check_if_dueller_is_shot_1 ; RET NZ            ;
       movb one,a                      ; LD A,$01          ;
       movb a,@13(ix)                  ; LD (IX+$0D),A     ; 
       movb a,*ix                      ; LD (IX+$00),A     ; Set dueller state to $01.
check_if_dueller_is_shot_1:
       .endproc                        ; RET               ; Return.

*********************************************************************
* This entry point is used by the routines at #R$C607 and #R$C6E5.
duel_shot_sound:
* Jump - not call
       bl   @shot_sound_1              ; CALL $6500        ;
       .endproc                        ; RET               ;

*********************************************************************
* Dueller routing
update_dueller_status:
       movb @8(ix),a                   ; LD A,(IX+$08)     ; {If IX+$08 is zero then return.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       movb @9(ix),a                   ; LD A,(IX+$09)     ; {If dueller frame index is $01 then jump to #R$C5A1.
       sb   one,a                      ; DEC A             ; 
       jeq  update_dueller_status_1    ; JR Z,$C5A1        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $02 then jump to #R$C5B5.
       jeq  update_dueller_status_2    ; JR Z,$C5B5        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $03 then jump to #R$C5BD.
       jeq  update_dueller_status_3    ; JR Z,$C5BD        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $04 then jump to #R$C5CF.
       jeq  update_dueller_status_4    ; JR Z,$C5CF        ; }
       jmp  update_dueller_status_5    ; JR $C5DD          ; Jump to #R$C5DD.

update_dueller_status_1:               ; c5a1
       li   hl,dueller_duel_over_2     ; LD HL,$C6E5       ; #R$C6E5.
       .call @check_dueller_duel_over  ; CALL $C5EB        ;
       sb   one,@1(ix)                 ; DEC (IX+$01)      ; Timer
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       movb @11(ix),a                  ; LD A,(IX+$0B)     ; Char frame
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; Draw?
       .ret                            ; RET               ; 
update_dueller_status_2:               ; c5b5
       sb   one,@16(ix)                ; DEC (IX+$10)      ; Timer
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       .ret                            ; RET               ; 
update_dueller_status_3:               ; c5bd              ; Shoot?
       li   hl,dueller_duel_over_1     ; LD HL,$C5F6       ;
       .call @check_dueller_duel_over  ; CALL $C5EB        ;
       sb   one,@2(ix)                 ; DEC (IX+$02)      ; Timer
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!                                                          ; a=0 from check_dueller_duel_over
       movb a,@8(ix)                   ; LD (IX+$08),A     ; Completed
       ab   one,a                      ; INC A             ; 
       movb a,@duel_bang_flag          ; LD ($C6E2),A      ; Bang
       .ret                            ; RET               ; 
update_dueller_status_4:               ; c5cf
       sb   one,@14(ix)                ; DEC (IX+$0E)      ; Timer
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       movb @12(ix),a                  ; LD A,(IX+$0C)     ; Char frame
       bl   @duel_draw_bandit_prep    ; CALL $C661        ;
       .ret                            ; RET               ; 
update_dueller_status_5:               ; c5dd
       sb   one,@15(ix)                ; DEC (IX+$0F)      ; Timer
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       movb @bytes+2,a                 ; LD A,$02          ; Char frame
       bl   @duel_draw_bandit_prep    ; CALL $C661        ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; Completed
       .ret                            ; RET               ; 

*********************************************************************
* Routine at C5EB
* 
* Used by the routine at #R$C422.
check_dueller_duel_over:               ; c5eb
       movb *ix,a                      ; LD A,(IX+$00)     ; {Check if the current duellers state is zero (complete),
       ; AND A                         ; AND A             ; return if so.
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; {Mark the current dueller as complete.
       movb a,*ix                      ; LD (IX+$00),A     ; }
       .pop af                         ; POP AF            ; {Restore #REGa and jump to whatever address is held by
       b    *hl                        ; JP (HL)           ; Branches to dueller_down_1 or dueller_duel_over_2

dueller_duel_over_1:                   ; c5f6
       movb @2(ix),a                   ; LD A,(IX+$02)     ; 
       srl  a,1                        ; SRL A             ; 
                                       ; CP $09            ;
       movb @4(ix),@e                  ; LD E,(IX+$04)     ; 
       movb @5(ix),d                   ; LD D,(IX+$05)     ;
       cb   a,@bytes+9                                     ; Check time after draw?
       jhe  duel_points                ; JR NC,$C628       ;
       socb one,a                      ; OR $01            ; 

* Displays The Bonus Score Text.
* 
* Used by the routine at #R$C628.
print_bonus_score:                     ; c607
       movb a,@7(ix)                   ; LD (IX+$07),A     ; {Stores the ASCII representation of the number at #R$C41D (it adds ASCII "0") so for example 1 ends up being
       li   hl,duel_bonus_text         ; LD HL,$C41D       ; 1 + $30 = $31 (e.g. "1" in ASCII).
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*hl                      ; LD (HL),A         ; }
       li   bc,>2928                   ; LD BC,$2928       ; {Print using #R$5B80.
       bl    @print_two_tone_text      ; CALL $5B80        ; #TABLE(default,centre,centre,centre,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; { $28 | $00 | $05 | $00 }
                                                           ; TABLE#}
       .call @scoring_for_door         ; CALL $5B8C        ;
       .call @draw_score               ; CALL $5B98        ;
       ab   one,@9(ix)                 ; INC (IX+$09)      ; frame/state
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

* "Extra" text.
extra_text_copy:                       ; c622
       text 'EXTRA',>ff

* Displays "Extra" and Bonus Score text.
* 
* Handles whether to display points or "EXTRA" above each downed Bandit.
duel_points:                           ; c628
       movb @duel_extra_life,tmp0      ; LD A,($C6E4)      ; {If #R$C6E4 is NOT zero then award 9(00) bonus points.
       ; AND A                         ; AND A             ; 
       movb @bytes+9,a                 ; LD A,$09          ;
       movb tmp0,tmp0
       jne  print_bonus_score          ; JR NZ,$C607       ; }
       li   hl,lives                   ; LD HL,($5B86)     ; {Fetch a 16 bit address from #R$5B86 (#R$CC59), if it is
       movb *hl,tmp0                   ; LD A,(HL)         ; higher than $05 then award 9(00) bonus points.
                                       ; CP $05            ;
       movb @bytes+9,a                 ; LD A,$09          ;
       cb   tmp0,@bytes+5
       jhe  print_bonus_score          ; JR NC,$C607       ; }
       li   hl,extra_text_copy         ; LD HL,$C622       ; {Points to #R$C622 and sends it to #R$5B80.
       dec  de                         ; DEC DE            ; #TABLE(default,centre)
       li   bc,>2a29                   ; LD BC,$2A29       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $2A | $02 | $05 | $00 }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; TABLE#}
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$C6E4.
       movb a,@duel_extra_life         ; LD ($C6E4),A      ; }
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Move onto the next frame.
       .ret                            ; RET               ; Return.

* Playfield Text
playfield_score:                       ; c64d
       text ' SCORE ',>ff
playfield_lives:                       ; c655
       text 'LIVES',>ff
playfield_whitespace:                  ; c65b
       text '     ',>ff

*********************************************************************
* Draw Duel Bandit
* 
* Used by the routine at #R$C422.
duel_draw_bandit_prep:                 ; c661
       .proc
       clr  tmp2
       movb @3(ix),tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>80
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character_pattern
       .endproc                        ; RET               ; Return.

*********************************************************************
* Routine at C67F
* 
* Used by the routine at #R$C422.
duel_update_timer:                     ; c67f
       andi a,63*256                   ; AND $3F           ; {Updates dueller timer.
       socb @bytes+64,a                ; OR $40            ; 
       movb a,@1(ix)                   ; LD (IX+$01),A     ; }
       rt                              ; RET               ; Return.

*********************************************************************
* Lose A Life
* 
* Used by the routine at #R$C690.
lose_life:                             ; c687
       .call @bang                     ; CALL $C000        ; Calls the subroutine to display the "BANG" animation.
       li   hl,lives                   ; LD HL,($5B86)     ; {Decrease the lives counter by one (#R$CC59), set the
       sb   one,*hl                    ; DEC (HL)          ; zero flag if all lives are lost.
       ; AND A                         ; AND A             ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* Is The Duel Finished?
* 
* Used by the routine at #R$C422.
duel_complete:                         ; c690
       movb @duel_lose_life,a          ; LD A,($C6E3)      ; {Jump to #R$C6F0 if #R$C6E3 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6F0       ; }
       b    @flash_life_image          ;                   
!
       movb @duel_bang_flag,a          ; LD A,($C6E2)      ; {Jump to #R$C687 if #R$C6E2 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C687       ; }
       b    @lose_life                 ;                   
!
       movb @duel_extra_life,a         ; LD A,($C6E4)      ; {Jump to #R$C6B1 if #R$C6E4 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6B1       ; }
       b    @duel_flash_text           ;                   
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

*********************************************************************
* Write "Lives" text.
* 
* Used by the routines at #R$C422 and #R$C6B1.
duel_print_lives:                      ; c6a7
       .proc
       li   de,zx_screen+>10d0         ; LD DE,$50D0       ; {Helper routine called from #R$C463 used for writing #R$C655 to the screen using the colours held in #REGbc;
       li   bc,>0702                   ; LD BC,$0702       ; #TABLE(default,centre)
       bl    @print_two_tone_text      ; CALL $5B80        ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                        ; RET               ; Return.

*********************************************************************
* Duel: Gain Extra Life.
* 
* Used by the routine at #R$C690.
duel_flash_text:                       ; c6b1
       movb @bytes+8,b                 ; LD B,$08          ; {Alternates displaying #R$C65B and #R$C655 to "flash"
duel_flash_text_loop:                  ; c6b3
       .push bc                        ; PUSH BC           ; the lives indicator.
       li   hl,playfield_whitespace    ; LD HL,$C65B       ; 
       bl   @duel_print_lives          ; CALL $C6A7        ;
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_1:                ; c6bc
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6BC        ; 
       jne  duel_flash_halt_loop_1     ;                   
       li   hl,playfield_lives         ; LD HL,$C655       ; 
       bl   @duel_print_lives          ; CALL $C6A7        ;
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_2:                ; c6c7
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6C7        ; 
       jne  duel_flash_halt_loop_2     ;                   
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $C6B3        ; }
       jne  duel_flash_text_loop       ;                   
       li   hl,lives                   ; LD HL,($5B86)     ; {Increase the lives counter by one (#R$CC59).
       ab   one,*hl                    ; INC (HL)          ; }
       ; SCF                           ; SCF               ; {Sets the carry flag and returns.
       b    @return_with_carry         ; RET               ; }

* Write "Countdown" text.
* 
* Used by the routine at #R$C422.
duel_print_countdown:                  ; c6d3
       li   hl,duel_timer              ; LD HL,$C6E0       ; {Helper routine used for writing #R$C6E0 to the screen using the colours held in #REGbc;
       li   de,zx_screen+>004f         ; LD DE,$404F       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Duel Countdown Timer
duel_timer:                            ; c6e0
       byte >20
       byte >FF

* Duel Shot Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_bang_flag:                        ; c6e2
       byte >00                                                      ; Holds $00/ $01 to indicate player has been shot.

* Duel Lost Life Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_lose_life:                        ; c6e3
       byte >00                                                      ; Holds $00/ $01 to indicate player should lose a life (as
                                                                     ; they shot too quickly).

* Duel Extra Life Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_extra_life:                       ; c6e4
       byte >00                                                      ; Holds $00/ $01 to indicate player has gained an extra
                                                                     ; life.

* Process Dueller Shot.
dueller_duel_over_2:                   ; c6e5
       movb @bytes+4,a                 ; LD A,$04          ; {Writes $04 to #R$C6E3.
       movb a,@duel_lose_life          ; LD ($C6E3),A      ; }
       movb a,@9(ix)                   ; LD (IX+$09),A     ; Sets the dueller frame index to $04.
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

* Flash Life Image.
* 
* This routine flashes the last life image eight times, and returns with lives being one less and the carry flag
* being set.
flash_life_image:                      ; c6f0
       li   hl,lives                   ; LD HL,($5B86)     ; {Decrease #R$CC59 by one.
       sb   one,*hl                    ; DEC (HL)          ; }
       movb @bytes+8,b                 ; LD B,$08          ; Sets #REGb (the counter) to loop $08 times.
flash_life_image_loop:                 ; c6f6
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       ab   one,*hl                    ; INC (HL)          ; {Increase #R$CC59 by one and call #R$5B83.
       bl   @draw_life_images         ; CALL $5B83        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_1:          ; c6fe
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6FE        ; }
       jne  flash_life_image_halt_loop_1 ;                   
       .pop hl                         ; POP HL            ; 
       .push hl                        ; PUSH HL           ; 
       sb   one,*hl                    ; DEC (HL)          ; {Decrease #R$CC59 by one and call #R$5B83.
       bl   @draw_life_images          ; CALL $5B83        ; }
       .pop hl                         ; POP HL            ; 
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_2:          ; c70a
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C70A        ; }
       jne  flash_life_image_halt_loop_2 ;                   
       .pop bc                         ; POP BC            ; {Retrieves #REGb (the counter) from the stack and loop
       sb   one,b                      ; DJNZ $C6F6        ; back until finished.}
       jne  flash_life_image_loop      ;                   
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Data block at C71E
       byte >22,>FB

* Sheriff's Star Page
* 
* Used by the routine at #R$C7C0.
sheriff_star:                          ; c720
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of the screen buffer (i.e.
;       li   de,zx_screen+1             ; LD DE,$4001       ; "blanks it").
;       li   bc,>1800                   ; LD BC,$1800       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
       li   tmp0,>0458
       li   tmp1,>0006
       li   tmp2,>080a
       bl   @ti_draw_color_area
       li   hl,zx_screen+>008b         ; LD HL,$408B       ; {Points to #R$F600 and prints it to the screen using
       li   de,gfx_badge_image         ; LD DE,$F600       ; #R$5B92.
       li   bc,>5008                   ; LD BC,$5008       ;
       bl   @ti_copy_routine             ; CALL $5B92        ; }
       li   hl,header_1                ; LD HL,$C765       ; {Points to #R$C765 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1001         ; LD DE,$5001       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_2                ; LD HL,$C784       ; {Points to #R$C784 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1041         ; LD DE,$5041       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_3                ; LD HL,$C7A3       ; {Points to #R$C7A3 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1083         ; LD DE,$5083       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Sheriff's Star Page Text
header_1:                              ; c765
       text '      THIS IS YOUR STAR       ',>ff
header_2:                              ; c784
       text 'YOU ARE THE SOFT CITY SHERIFF ',>ff
header_3:                              ; c7a3
       text '    NOW DO YOUR WORK     ',>ff

* New Game
start:                                 ; c7c0
       mov  @>83c0,hl                  ; LD HL,($5C78)     ; #HTML(Fetch <a
                                                           ; href="https://skoolkid.github.io/rom/asm/5C78.html">FRAMES</a>
                                                           ; as a random number seed.)
       mov  hl,@random_seed            ; LD ($D8AC),HL     ; Write it to #R$D8AC.
main_loop:
       bl   @ti_clear_screen
       .call @new_game                  ; CALL $C7E5        ; Call #R$C7E5.
       bl   @ti_clear_screen
       movb @bytes+64,b                ; LD B,$80          ; {Calls #R$CD64 with the counter
       .call @halt_loop                ; CALL $CD64        ; $80.}
;      li   hl,copied_5b80             ; LD HL,$CBB4       ; {Jump to #R$FA00 with
       li   ix,score_digit_6           ; LD IX,$CD86       ; #REGhl=#R$CBB4 and
       .call @draw_and_input_high_scores ; JP $FA00        ; #REGix=#R$CD86.}
       jmp  main_loop
* Displays the title screen and on return, sets the control method and
* initiates variables for a new game.
new_game:                              ; c7e5
;      li   hl,copied_5b80             ; LD HL,$CBB4       ; {Calls #R$FE00 with
       .call @title_screen             ; CALL $FE00        ; #REGhl=#R$CBB4.}
**
* Init new game
       sb   b,b                        ; LD B,$00          ; Unused.
* Setup input control routine
       movb @controller,a              ; LD A,($5CB0)      ; {Grab the value stored at #R$5CB0
       li   hl,controls_keyboard       ; LD HL,$D39B       ; and if it is $01 then jump ahead
       sb   one,a                      ; DEC A             ; to #R$C7F9 which writes #R$D39B
       jeq  set_control_alias          ; JR Z,$C7F9        ; to #R$CE12.}
       li   hl,controls_joystick       ; LD HL,$D392       ; {Write #R$D392 to #R$CE12.
set_control_alias:                     ; c7f9
       mov  hl,@control_routine_alias  ; LD ($CE12),HL     ; }
* Resets all game variables/ states ready for a new game.
       li   hl,score_digit_6           ; LD HL,$CD86       ; {Clears the score (writes $00
       li   de,score_digit_5           ; LD DE,$CD87       ; over seven bytes from #R$CD86).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       .ldir                           ; LDIR              ; }
                                       ; LD A,$03          ; {Initialise #R$CC59 to $03.
       movb @bytes+3,@lives            ; LD ($CC59),A      ; } Starting_lives
       li   hl,>0101                   ; LD HL,$0101       ; {Initialise #R$D45C to $0101.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CE14, #R$CE16 and
       mov  hl,@door_1_routine         ; LD ($CE14),HL     ; #R$CE18 (sets them to $0000).
       mov  hl,@door_2_routine         ; LD ($CE16),HL     ; 
       mov  hl,@door_3_routine         ; LD ($CE18),HL     ; }
       li   hl,>2020                   ; LD HL,$2020       ; {Clear #R$CA58 and #R$CA5A to
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; $2020 (ASCII space-space).
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Set the border to black.
       bl   @ti_set_border_color          ; OUT ($FE),A       ; }
                                       ; INC A             ; {Write $01 to #R$CBCF.
       movb one,@duel_parameter        ; LD ($CBCF),A      ; }
       .call @init_progress            ; CALL $CA6C        ; 
       .call @set_day_attr             ; CALL $C959        ; 
       .call @cls_display_day          ; CALL $CA64         ;
                                       ; LD A,$03          ; {Writes $03 to #R$CE1B.
       movb @bytes+3,@chooser_countdown_init ; LD ($CE1B),A      ; }
       li   hl,>0500                   ; LD HL,$0500       ; {Writes $0500 to #R$CE1C.
       mov  hl,@delay                  ; LD ($CE1C),HL     ; }
                                       ; LD A,$01          ; {Writes $01 to #R$D191.
       movb one,@sheriff_star_flag     ; LD ($D191),A      ; }
**
*      Execute levels
       movb @level,a                   ; LD A,($5CB1)      ; {Grabs the #R$5CB1, if it's phase
       li   hl,phase                   ; LD HL,$CA4A       ; 1 then jump to #R$C878 with
       sb   one,a                      ; DEC A             ; #REGhl=#R$CA4A.
       jeq  level_1                    ; JR Z,$C878        ; }
*      Level 2 or 3
       bl    @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl    @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       sb   one,a                      ; DEC A             ; 
       jeq  level_2                    ; JR Z,$C88F        ;
*      Level 3
       bl    @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl    @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl    @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       jmp  level_3                    ; JR $C8B6          ;
level_1:                               ; c878
       li   hl,choose_default_set      ; LD HL,$CE42       ; {Writes #R$CE42 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_bandit_3         ; LD HL,$CE6F       ; {Writes #R$CE6F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  level_2                    ; RET C             ;
       .ret                            ;
level_2:
       li   hl,choose_bandit_2         ; LD HL,$CE5F       ; {Writes #R$CE5F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_julius           ; LD HL,$CE55       ; {Writes #R$CE55 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_bandit_4         ; LD HL,$CE7E       ; {Writes #R$CE7E to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  level_3                    ; RET C             ;
       .ret                            ;
level_3:
       li   hl,choose_bandit_5         ; LD HL,$CE8D       ; {Writes #R$CE8D to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       .call @set_dusk_attr            ; CALL $C95E        ; 
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl    @reduce_delay             ; CALL $C941        ;
       .call @set_night_attr           ; CALL $C963        ; 
       bl    @run_phase                ; CALL $CA81        ;
       jnc  level_3_1                  ; RET C             ;
       .ret                            ;                   
level_3_1:                             ; c8f0
       .call @set_day_attr             ; CALL $C959        ;
       .call @cls_display_day          ; CALL $CA64        ;
       movb @bytes+7,b                 ; LD B,$07          ; 
level_3_2:                             ; c8f8
       .push bc                        ; PUSH BC           ; 
       bl    @run_phase                ; CALL $CA81        ;
       .pop bc                         ; POP BC            ; 
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       .push bc                        ; PUSH BC           ; 
       bl    @reduce_delay             ; CALL $C941        ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $C8F8        ; 
       jne  level_3_2                  ;                   ; Do 7 times
       .call @set_dusk_attr            ; CALL $C95E        ; 
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       .call @set_night_attr           ; CALL $C963        ; 
       bl    @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ;
       .ret                            ;                   
!
       li   hl,sheriff_star_flag       ; LD HL,$D191       ;
       movb *hl,tmp0                   ; LD A,(HL)         ;
       sb   *hl,*hl                    ; LD (HL),$00       ; You only get a sheriff star once
       movb tmp0,tmp0                  ; AND A             ;
       jeq  level_3_1                  ; JR Z,$C8F0        ;
       .call @sheriff_star             ; CALL $C720        ; Call #R$C720.
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
level_3_3:                             ; c936
       li   tmp0,KEY_SP
       bl   @ti_check_key
       jeq  level_3_3
       jmp  level_3_1                  ; JR $C8F0          ;

* Reduce delay by 64
reduce_delay:                          ; c941
       .push af                        ; PUSH AF           ; 
       .push hl                        ; PUSH HL           ; 
       mov  @delay,hl                  ; LD HL,($CE1C)     ;
       li   bc,>0040                   ; LD BC,$0040       ; 
       ; AND A                         ; AND A             ; 
       s    bc,hl                      ; SBC HL,BC         ; 
       movb h,a                        ; LD A,H            ; 
       socb @l,a                       ; OR L              ; 
       jne  reduce_delay_1             ; JR NZ,$C953       ;
       li   hl,>0040                   ; LD HL,$0040       ; 
reduce_delay_1:                        ; c953
       mov  hl,@delay                  ; LD ($CE1C),HL     ;
       .pop hl                         ; POP HL            ; 
       .pop af                         ; POP AF            ; 
       rt                            ; RET               ;

* Sets the door attributes for the "time of day".
set_day_attr:                          ; c959
       li   hl,door_attr_day           ; LD HL,$C96F       ; {Call #R$C966 using #R$C96F.
       jmp  set_door_attr              ; JR $C966          ; }
set_dusk_attr:                         ; c95e
       li   hl,door_attr_dusk          ; LD HL,$C987       ; {Call #R$C966 using #R$C987.
       jmp  set_door_attr              ; JR $C966          ; }
set_night_attr:                        ; c963
       li   hl,door_attr_night         ; LD HL,$C99F       ; Call #R$C966 using #R$C99F.
* Note this is for the opened door background hence it starts from frame 2 (as
* frame 1 is a closed door).
set_door_attr:                         ; c966
       movb *hl,@character_attr+1
       .ret                            ; RET               ; }
* Door frame attribute data for each day phase.
door_attr_day:                         ; c96f
       byte >28
door_attr_dusk:                        ; c987
       byte >0D
door_attr_night:                       ; c99f
       byte >05

* Clears the cashbox flags, clears the screen and displays the phase number.
init_game_loop:                        ; c9b7
       li   hl,>0101                   ; LD HL,$0101       ; {Writes $0101 to #R$D45C.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Call #R$C9D0 (using $00).
       .call @clear_screen             ; CALL $C9D0        ; }
       .call @display_phase            ; JR $C9DD          ; Jump to #R$C9DD.
       .ret

* This routine has the ability to write any value across the screen buffer, however it's only ever called with
* #REGa=$00 (clear screen).
clear_screen:                          ; c9d0
       bl   @ti_clear_screen
       .ret                            ; RET               ; }

* Displays the current "phase".
display_phase:                         ; c9dd
       li   hl,phase_copy              ; LD HL,$CA4E       ; {Copies #R$CA4E into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ; 
       .ldir                           ; LDIR              ; }
       mov  @phase_ascii,hl            ; LD HL,($CA5A)     ; {Writes #R$CA5A to #R$CA5C (at
;       mov  hl,@progress_buffer+5      ; LD ($CA61),HL     ; $CA61 - just overwriting the
                                                           ; numeric part).}
       movb h,*de+
       movb @l,*de
       li   hl,phase                   ; LD HL,$CA4A       ; {Call #R$CA19 with #R$CA4A.
       .call @progress_base_10         ; CALL $CA19        ; }


;       mov  @progress_buffer+5,hl      ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA5A.
       movb @progress_buffer+5,h
       movb @progress_buffer+6,@l
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       .ret                            ; RET               ; Return.

* Displays the current "day".
display_day:                           ; c9fb
       li   hl,day_copy                ; LD HL,$CA53       ; {Copies #R$CA53 into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ; 
       .ldir                           ; LDIR              ; }
       mov  @day_ascii,hl              ; LD HL,($CA58)     ; {Writes #R$CA58 to #R$CA5C (at
;       mov  hl,@progress_buffer+5      ; LD ($CA61),HL     ; $CA61 - just overwriting the
                                                           ; numeric part).}
       movb h,*de+
       movb @l,*de
       li   hl,day                     ; LD HL,$CA4C       ; {Call #R$CA19 with #R$CA4C.
       .call @progress_base_10         ; CALL $CA19        ; }
;       mov  @progress_buffer+5,hl      ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA58.
       movb @progress_buffer+5,h
       movb @progress_buffer+6,@l
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; }
       .ret                            ; RET               ; Return.

* This routine is for converting progress numbers into ASCII. On entry #REGhl
* will be either #R$CA4A or #R$CA4C.
progress_base_10:                      ; ca19
       movb *hl,a                      ; LD A,(HL)         ; {If the passed number is not more
       ab   one,a                      ; INC A             ; than 10 jump to #R$CA27.
       cb   a,@bytes+10                ; CP $0A            ; 
       jhe  progress_divisible_10      ; JR NC,$CA27       ; }
       movb a,*hl                      ; LD (HL),A         ; {Stores the ASCII representation of the number at $CA62 (for #R$CA5C). It adds ASCII "0" so for example 1
       ab   @bytes+48,a                ; ADD A,$30         ; ends up being 1 + $30 = $31 (e.g. "1" in ASCII).
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; }
       jmp  print_progress             ; JR $CA38          ; Jump to #R$CA38.
* Ensures the progress digit remains 0-9. On entry #REGhl will be either
* #R$CA4A or #R$CA4C.
progress_divisible_10:                 ; ca27
       sb   *hl,*hl                    ; LD (HL),$00       ; Reset the current progress digit
                                                           ; to $00.
       inc  hl                         ; INC HL            ; Use the secondary digit of the
                                                           ; currently focused progress.
* Note this doesn't account for a third digit and so leads to eventual corruption. Once past day/ phase "99", this
* will display "00" and past "09" the first ASCII digit doesn't point to any usable image data. Note however, this
* occurs after ~4 hours of game play so isn't especially an issue.
       ab   one,*hl                    ; INC (HL)          ; Increase this second digit by
                                                           ; one.
       movb *hl,a                      ; LD A,(HL)         ; {Add ASCII "0" so for example 1 ends up being 1 + $30 = $31 (e.g. "1" in ASCII). Write this number to $CA61
       ab   @bytes+48,a                ; ADD A,$30         ; (for #R$CA5C).
       movb a,@progress_buffer+5       ; LD ($CA61),A      ; }
       dec  hl                         ; DEC HL            ; Move back to point to the
                                                           ; original location of #REGhl.
       movb *hl,a                      ; LD A,(HL)         ; {Again, add ASCII "0" for this
       ab   @bytes+48,a                ; ADD A,$30         ; digit too. Write this number to
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; $CA62 (for #R$CA5C).}
* Prints the current progress buffer message to the screen.
print_progress:                        ; ca38
       li   hl,progress_buffer         ; LD HL,$CA5C       ; {Prints #R$CA5C to the screen buffer at $486C using #R$CBD2.
       li   de,zx_screen+>086c         ; LD DE,$486C       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $CBD2        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       movb @bytes+80,b                ; LD B,$50          ; {Interrupt driven HALT loop ($50
progress_halt_loop:                    ; ca46
       bl   @ti_vsync                  ; HALT              ; cycles).
       sb   one,b                      ; DJNZ $CA46        ; }
       jne  progress_halt_loop         ;                   
       .ret                            ; RET               ; Return.

* Game variables
phase:                                 ; ca4a
       data >0600                      ; BCD low endian
day:                                   ; ca4c
       data >0100                      ; BCD low endian
phase_copy:                            ; ca4e
       text 'PHASE'                                                  ; 
day_copy:                              ; ca53
       text ' DAY '                                                  ; 
       even
day_ascii:                             ; ca58
       text ' 1'                                                     ; 
       even
phase_ascii:                           ; ca5a
       text ' 6'                                                     ; 
progress_buffer:                       ; ca5c
       text 'PHASE 6',>ff                                            ; 

* Clears the screen and displays the day number.
cls_display_day:                       ; ca64
       sb   a,a                        ; XOR A             ; {Clears the screen by passing $00
       .call @clear_screen             ; CALL $C9D0        ; to #R$C9D0.}
       .call @display_day              ; CALL $C9FB        ; Call #R$C9FB.
       .ret                            ; RET               ; Return.

* Clear down the day/ progress states.
init_progress:                         ; ca6c
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CA4A and #R$CA4C
       mov  hl,@phase                  ; LD ($CA4A),HL     ; (writes $0000 to them).
       mov  hl,@day                    ; LD ($CA4C),HL     ; }
       movb @bytes+32,a                ; LD A,$20          ; {Writes ASCII space ($20) to $CA61 and ASCII "0" ($30) to $CA62 (i.e. writes " 0" to the numeric portion of
       li   hl,progress_buffer+5       ; LD HL,$CA61       ; #R$CA5C).
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       movb @bytes+48,a                ; LD A,$30          ; 
       movb a,*hl                      ; LD (HL),A         ; }
       .ret                            ; RET               ; Return.

cashboxes_completed_flag:              ; ca80
       byte >00                                                      ; 

run_phase:                             ; ca81
       .proc
       .call @init_and_run_game_loop   ; CALL $CAC8        ;
       jnc  phase_completed            ; RET C             ;
       b    @return_with_carry         ;
phase_completed:
*      Flash cashboxes
       movb @bytes+16,b                ; LD B,$10          ;
cashboxes_flash_loop:                  ; ca87
       .push bc                        ; PUSH BC           ; 
       movb b,a                        ; LD A,B            ; 
       andi a,1*256                    ; AND $01           ; 
       .call @set_all_deposit_flags    ; CALL $CAB9        ;
       movb @bytes+16,b                ; LD B,$10          ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CA87        ; 
       jne  cashboxes_flash_loop       ;                   
       movb @bytes+48,b                ; LD B,$30          ; 
       .call @halt_loop                ; CALL $CD64        ; 
       movb b,a                        ; LD A,B            ; 
       .call @set_all_deposit_flags    ; CALL $CAB9        ;
* Duel
       bl   @random_number             ; CALL $D8B0        ;
       movb a,b                        ; LD B,A            ;
       ; LD A,R                        ; LD A,R            ;
       movb a,@c                       ; LD C,A            ; bc random
       ab   b,a                        ; ADD A,B           ; 
       movb a,d                        ; LD D,A            ; d random
       movb @duel_parameter,a          ; LD A,($CBCF)      ;
;      li   hl,copied_5b80             ; LD HL,$CBB4       ;
       .call @perform_duel             ; CALL $C3C0        ;
       stst tmp2
       movb a,@duel_parameter          ; LD ($CBCF),A      ; a=@duel_counter
       sb   b,b                        ; LD B,$00          ; 
       .call @halt_loop                ; JP $CD64          ;
       andi tmp2,>1000                 ; Check carry
       jne  !
       b    @return_without_carry
!      b    @return_with_carry

* Set all deposit flags to a
set_all_deposit_flags:                 ; cab9
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Writes #REGa across all the
       li   de,door_deposited_02       ; LD DE,$CC8E       ; deposit flags (copies to each
       li   bc,>000d                   ; LD BC,$000D       ; from #R$CC8D).
       movb a,*hl                      ; LD (HL),A         ; 
       .ldir                           ; LDIR              ; }
       b    @draw_and_check_cashboxes  ; JP $CC9B          ; Jump to #R$CC9B.
*
init_and_run_game_loop:                ; cac8
       .call @init_game_loop           ; CALL $C9B7        ;
* This entry point is used by the routines at #R$CD1B and #R$CD47.
next_life:
                                       ; XOR A             ; {Writes $00 to #R$D2FE.
       movb @zero,@player_died_status  ; LD ($D2FE),A      ; }
       .call @draw_entire_playfield    ; CALL $CAD4        ;
       jmp  game_loop                  ; JR $CAE7          ;
* Why is this a routine?
draw_entire_playfield:                 ; cad4
       .call @reset_door_routine_flags ; CALL $CD68        ;
       .call @draw_doors_and_playfield ; CALL $CC3A        ;
       bl    @draw_life_images         ; CALL $CC5A        ;
       .call @draw_and_check_cashboxes           ; CALL $CC9B        ;
       .call @draw_score               ; CALL $CD90        ;
       .call @draw_cashbox_selections  ; CALL $D45E        ;
       .ret                            ; RET               ; 
game_loop:                           ; cae7
       li   tmp0,KEY_Z
       bl   @ti_check_key
       jeq  read_keys_3                ; JR NZ,$CB0B       ;
read_keys_2:                           ; cb03              ; Z pressed. Enter pause mode until X pressed.
       li   tmp0,KEY_X
       bl   @ti_check_key
        jeq  read_keys_2                ; JR NZ,$CB03       ;
read_keys_3:                           ; cb0b
       .call @check_input              ; CALL $D2CF        ;
       mov  @delay,bc                  ; LD BC,($CE1C)     ;
delay_loop:                            ; cb12
       dec  bc                         ; DEC BC            ;
                                       ; LD A,B            ;
                                       ; OR C              ;
       jne  delay_loop                 ; JR NZ,$CB12       ;
       .call @move_right_or_left       ; CALL $D411        ;
* Door 1 handling
       li   ix,door_1_flags            ; LD IX,$D165       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_1_routine,hl         ; LD HL,$CE14       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser        ;                   ; If no door_1_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_1_routine       ; JR Z,$CB3F        ;
                                       ; LD HL,($CE14)     ;
!      li   de,after_door_1_routine    ; LD DE,$CB3F       ;
       .push de                        ; PUSH DE           ; Set return address
       movb one,@door_frame_ref        ; LD A,$01          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 1 routine
after_door_1_routine:                  ; cb3f
* Door 2 handling
       li   ix,door_2_flags            ; LD IX,$D173       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_2_routine,hl         ; LD HL,$CE16       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser                            ; If no door_2_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_2_routine       ; JR Z,$CB61        ;
                                       ; LD HL,($CE16)     ;
!      li   de,after_door_2_routine    ; LD DE,$CB61       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+2,@door_frame_ref   ; LD A,$02          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 2 routine
after_door_2_routine:                  ; _cb61
* Door 3 handling
       li   ix,door_3_flags            ; LD IX,$D181       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_3_routine,hl         ; LD HL,$CE18       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser                            ; If no door_3_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_3_routine       ; JR Z,$CB83        ;
                                       ; LD HL,($CE18)     ;
!      li   de,after_door_3_routine    ; LD DE,$CB83       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+3,@door_frame_ref   ; LD A,$03          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 3 routine
after_door_3_routine:                  ; cb83
* Check status
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 0 of #R$D2FE is not zero
       movb a,tmp0                     ; BIT 0,A           ; then jump to #R$CD47.
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,$CD47       ; }
       b    @died                     ;
!
       movb a,tmp0                     ; BIT 1,A           ; {Else if bit 1 is not zero, jump
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,$CD1B       ; to #R$CD1B.}
       b    @flash_lives               ;                   
!
       .call @scoring                  ; CALL $CDC3        ; Call #R$CDC3.
       li   hl,deposit_flag            ; LD HL,$D190       ; {If #R$D190 is not zero then call
       movb *hl,a                      ; LD A,(HL)         ; #R$CBA0 (also, writes $00 to
       ; AND A                         ; AND A             ; #R$D190 to clear it).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  !                          ; CALL NZ,$CBA0     ; }
       .call @got_a_deposit                    ;
!
       b    @game_loop                 ; JP $CAE7          ;
got_a_deposit:                         ; cba0
       .call @scroll_dollar_sign       ; CALL $F960        ;
       b    @draw_and_check_cashboxes  ; JP $CC9B          ;

duel_parameter:                         ; cbcf                       ; This always appear to be 1
       byte >01                                                      ; 

* Draw Text.
two_tone_attributes_buffer:            ; cbd0
       data 1797                                                     ; Stores the attributes; top attribute/ bottom attribute.

*********************************************************************
* hl: address of text to print
* de: screen address
* This entry point is used by the routines at #R$5B80 and #R$C7C0.
print_two_tone_text:                   ; cbd2
       .proc
       mov  bc,@two_tone_attributes_buffer ; LD ($CBD0),BC     ; Stash the attributes at #R$CBD0.
print_two_tone_text_loop:              ; cbd6
       movb *hl,a                      ; LD A,(HL)         ; {Grab the next character in the string, if it's $FF then
       cb   a,@b255                    ; CP $FF            ; return.
       jeq  print_two_tone_text_2      ; RET Z             ; }
       cb   a,@bytes+48                ; CP $30            ; 
       jne  print_two_tone_text_1      ; JR NZ,$CBE0       ;
       movb @bytes+58,a                ; LD A,$3A          ; 
print_two_tone_text_1:                 ; cbe0
       .push hl                        ; PUSH HL           ; 
       .push de                        ; PUSH DE           ; 
       bl   @print_tt_text_space_check ; CALL $CBFC        ; 
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; 
       inc  hl                         ; INC HL            ; 
       ab   one,@e                     ; INC E             ; 
       movb @e,a                       ; LD A,E            ; 
       andi a,31*256                   ; AND $1F           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb @e,a                       ; LD A,E            ; 
       ab   @bytes+32,a                ; ADD A,$20         ; 
       movb a,@e                       ; LD E,A            ; 
       andi a,224*256                  ; AND $E0           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb d,a                        ; LD A,D            ; 
       ab   @bytes+8,a                 ; ADD A,$08         ; 
       movb a,d                        ; LD D,A            ; 
       jmp  print_two_tone_text_loop   ; JR $CBD6          ; 
print_two_tone_text_2:
       .endproc
*// print_two_tone_text

*********************************************************************
* This entry point is used by the routine at #R$5B9B.
print_tt_text_space_check:             ; cbfc
       .proc
       cb   a,@bytes+32                ; CP $20            ; {If the character is a space then jump forward to
       jne  print_tt_text_2            ; JR NZ,$CC0E       ; #R$CC0E.}
*      Space
       li   hl,gfx_empty_space          ; LD HL,$5B00       ; Needs 16 zeros
       li   bc,>1001                   ; LD BC,$1001       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .push hl                        ; PUSH HL           ; 
       bl   @ti_copy_routine             ; CALL $D5E6        ;
       .pop hl                         ; POP HL            ;
       jmp  print_tt_text_4            ; JR $CC1D          ;
*      Not space
print_tt_text_2:                       ; cc0e              ; not space
       cb   a,@bytes+65                ; CP $41            ; 
       jhe  print_tt_text_3            ; JR NC,$CC14       ;
       ab   @bytes+42,a                ; ADD A,$2A         ; 
print_tt_text_3:                       ; cc14
       sb   @bytes+65,a                ; SUB $41           ; 
;       ab   @bytes+10,a               ; ADD A,$0A         ;
       .push de                        ; PUSH DE           ; 
       bl   @draw_tt_char             ; CALL $CDAE        ;
       .pop hl                         ; POP HL            ;
*      Attributes
print_tt_text_4:                       ; cc1d
       bl   @print_tt_attribute_addr   ; CALL $CC2B        ;
       mov  @two_tone_attributes_buffer,bc ; LD BC,($CBD0)     ; {Load the stored top/ bottom attribute bytes back into
;       movb b,*hl                     ; LD (HL),B         ; #REGbc and write them to the screen.
       mov  hl,tmp1
       movb b,a
       bl   @ti_draw_attribute
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       movb @c,*hl                     ; LD (HL),C         ; }
       ai   hl,>20
       mov  hl,tmp1
       movb @c,a
       bl   @ti_draw_attribute
       .ret                            ; RET               ; Return.
*// print_tt_text_space_check

*********************************************************************
* Routine at CC2B
* 
* Used by the routine at #R$CBD0.
print_tt_attribute_addr:
       movb h,a                        ; LD A,H            ; 
       andi a,24*256                   ; AND $18           ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       ab   @bytes+88,a                ; ADD A,$58         ; 
       movb a,h                        ; LD H,A            ; 
       rt                              ; RET               ; Return.
*// print_tt_attribute_addr

* Main Playfield Initialisation.
* 
* Used by the routine at #R$C7C0.
*
* Draws Main Playfield with all three doors closed.
draw_doors_and_playfield:              ; cc3a
       bl   @ti_draw_playfield
       movb one,a                      ; LD A,$01          ; {Calls #R$D664 with #R$CE1A set to $01.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Calls #R$D664 with #R$CE1A set to $02.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$D664 with #R$CE1A set to $03.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1         ; JP $D664          ; }
       .ret

* Number of lives remaining
lives:                                 ; cc59
       byte >00

*********************************************************************
* Display The "Life" Images.
* 
* Used by the routines at #R$5B83, #R$C7C0 and #R$CD1B.
draw_life_images:                      ; cc5a
       .proc
*      Delete all life images
       movb @bytes+5,b                 ; LD B,$05          ; {Set up counter=$05 screen buffer=$50B6.
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ; }
delete_life_images_loop:               ; cc5f
       .push bc                        ; PUSH BC           ; {jjjss
       li   de,gfx_empty_space         ; LD DE,$5B00       ; Needs 48 zeros
       bl   @copy_life_image           ; CALL $CC84        ;
       inct hl                         ; INC HL            ;
                                       ; INC HL            ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC5F        ; }
       jne  delete_life_images_loop           ;
*      Draw life images
       movb @lives,a                   ; LD A,($CC59)      ; {If #R$CC59 are zero then return.
       ; AND A                         ; AND A             ; 
       jeq  draw_life_images_end       ; RET Z             ; }
       cb   a,@bytes+6                 ; CP $06            ; {If #R$CC59 is more than or equal to "6" then return.
       jhe  draw_life_images_end       ; RET NC            ; }
       movb a,b                        ; LD B,A            ;
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ;
draw_life_images_loop:                 ; cc77
       .push bc                        ; PUSH BC           ; 
       bl   @draw_life_image          ; CALL $CC81        ;
       inct hl                         ; INC HL            ;
                                       ; INC HL            ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC77        ; 
       jne  draw_life_images_loop      ;                   
draw_life_images_end:
       .endproc                        ; RET               ; Return.
*// draw_life_images

*********************************************************************
draw_life_image:                       ; cc81
       .proc
       li   de,gfx_lives_image         ; LD DE,$FFB8       ; {Point at the #R$FFB8 and call #R$D5E6.
       jmp  copy_life_image_1
**
copy_life_image:                       ; cc84
       .proc
copy_life_image_1:
;      .push hl                        ; PUSH HL           ;
       li   bc,>1802                   ; LD BC,$1802       ; 
       bl   @ti_copy_routine             ; CALL $D5E6        ; }
;      .pop hl                         ; POP HL            ;
       .endproc                        ; RET               ; Return.
*// draw_life_image

*********************************************************************
* Deposit Flags.
* 
* Stores whether a deposit has been made for each door.
door_deposited_01:                     ; cc8d
       byte >00
door_deposited_02:                     ; cc8e
       byte >00
door_deposited_03:                     ; cc8f
       byte >00
door_deposited_04:                     ; cc90
       byte >00
door_deposited_05:                     ; cc91
       byte >00
door_deposited_06:                     ; cc92
       byte >00
door_deposited_07:                     ; cc93
       byte >00
door_deposited_08:                     ; cc94
       byte >00
door_deposited_09:                     ; cc95
       byte >00
door_deposited_10:                     ; cc96
       byte >00
door_deposited_11:                     ; cc97
       byte >00
door_deposited_12:                     ; cc98
       byte >00

* Probably represents each block of six deposit flags.
door_deposited_01_06:                  ; cc99
       byte >00
door_deposited_07_12:                  ; cc9a
       byte >00

* Draws Deposit Cashboxes.
* 
* Used by the routine at #R$C7C0.
draw_and_check_cashboxes:
       movb @cashbox_ref,a             ; LD A,($D45C)      ; {Converts #R$D45C into cash deposit box flag address
       movb a,@l                       ; LD L,A            ; (e.g. "1" becomes #R$CC8D and so on).
       sb   h,h                        ; LD H,$00          ; 
       li   de,door_deposited_01-1     ; LD DE,$CC8C       ;
       a    de,hl                      ; ADD HL,DE         ; }
       li   ix,door_1_flags            ; LD IX,$D165       ; {#REGa=#R$D16D.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_2_flags            ; LD IX,$D173       ; {#REGa=#R$D17B.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_3_flags            ; LD IX,$D181       ; {#REGa=#R$D189.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       li   de,door_deposited_01_06    ; LD DE,$CC99       ; #REGde=#R$CC99.
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; #REGhl=#R$CC8D.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC99.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       inc  hl                         ; INC HL            ; 
       inc  de                         ; INC DE            ; Move onto #R$CC9A.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC9A.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       .call @draw_cashboxes           ; CALL $CCFB        ;
check_cashboxes_completed:             ; ccd3
       li   de,door_deposited_01       ; LD DE,$CC8D       ; Points to the cashbox flags (beginning at #R$CC8D).
       li   hl,cashboxes_completed_flag ; LD HL,$CA80       ; {Write $00 to #R$CA80.
       sb   *hl,*hl                    ; LD (HL),$00       ; }
       movb @bytes+12,b                ; LD B,$0C          ; Testing against all 12 cashboxes.
check_cashboxes_completed_loop:        ; ccdd
       movb *de,a                      ; LD A,(DE)         ; {Fetch the cashbox flag, return if its zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       inc  de                         ; INC DE            ; {Move onto the next cashbox (loop back to #R$CCDD) or
       sb   one,b                      ; DJNZ $CCDD        ; continue once all 12 are checked.}
       jne  check_cashboxes_completed_loop
       movb a,*hl                      ; LD (HL),A         ; {Write #REGa ($01) to #R$CA80.
       .ret                            ; RET               ; }

draw_cashbox:                          ; cce5
       ab   a,a                        ; ADD A,A           ; {Determines whether to send #R$FF78 or #R$FF98 to
       ab   @l,a                       ; ADD A,L           ; #R$D5E6.
       movb a,@l                       ; LD L,A            ; 
       li   de,gfx_empty_box_image     ; LD DE,$FF78       ;
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; 
       jeq  draw_cashbox_1             ; JR Z,$CCF4        ;
       li   de,gfx_dollar_box_image    ; LD DE,$FF98       ;
draw_cashbox_1:                        ; ccf4
       li   bc,>1002                   ; LD BC,$1002       ; 
       bl   @ti_copy_routine             ; CALL $D5E6        ; }
       .ret                            ; RET               ; Return.

* Draws all the cashboxes in two blocks of 6.
draw_cashboxes:                        ; ccfb
       li   ix,door_deposited_01       ; LD IX,$CC8D       ; {The statuses for the cashboxes begin at #R$CC8D. This routine processes them in two blocks of 6 (as they
       li   hl,zx_screen+>001f         ; LD HL,$401F       ; appear. The first block is displayed at $401F, after processing the subroutine returns and continues for the
       movb one,a                      ; LD A,$01          ; next six blocks, just altering the screen location to $4025.
       .call @draw_cashboxes_side      ; CALL $CD0A        ;
       li   hl,zx_screen+>0025         ; LD HL,$4025       ;
draw_cashboxes_side:                   ; cd0a
       movb @bytes+6,b                 ; LD B,$06          ; 
draw_cashboxes_loop:                   ; cd0c
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       .push af                        ; PUSH AF           ; 
       .call @draw_cashbox             ; CALL $CCE5        ;
       .pop af                         ; POP AF            ; 
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; 
       inc  ix                         ; INC IX            ; 
       ab   one,a                      ; INC A             ; 
       sb   one,b                      ; DJNZ $CD0C        ; }
       jne  draw_cashboxes_loop        ;
       .ret                            ; RET               ; Return.

* Flash Lives/ Lose Life.
* 
* Used by the routine at #R$C7C0.
flash_lives:                           ; cd1b
       movb @bytes+10,b                ; LD B,$0A          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       li   hl,lives                   ; LD HL,$CC59       ; {Point to #R$CC59. Set a counter for $05 times and stash
       movb @bytes+5,b                 ; LD B,$05          ; it.
flash_lives_loop:                      ; cd25
       .push bc                        ; PUSH BC           ; }
       sb   one,*hl                    ; DEC (HL)          ; {Decrease the number of lives by one, stash the lives
       .push hl                        ; PUSH HL           ; memory location and draw the decreased life images.
       bl   @draw_life_images              ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; {Grab the lives memory location, increase it by one, stash the location again and draw the now increased life
       ab   one,*hl                    ; INC (HL)          ; images (i.e. what they were on entry to the routine).
       .push hl                        ; PUSH HL           ; 
       bl   @draw_life_images              ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; {Loop back until the counter is zero.
       sb   one,b                      ; DJNZ $CD25        ; }
       jne  flash_lives_loop           ;                   
                                       ; LD A,(HL)         ; {Finally decrease lives by one and if they are not zero
       sb   one,*hl                    ; DEC A             ; jump to #R$CACB.
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; }
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Routine at CD47
* 
* Used by the routine at #R$C7C0.
died:                                  ; cd47
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 2 of #R$D2FE is zero then jump to #R$CD53.
       movb a,tmp0                     ; BIT 2,A           ; 
       andi tmp0,4*256                 ;                   
       jeq  died_1                     ; JR Z,$CD53        ; }
       .call @explode_bomb             ; CALL $F880        ;
       jmp  died_2                     ; JR $CD56          ;
died_1:                                ; cd53
       .call @bang                     ; CALL $C000        ; 
died_2:                                ; cd56
       .call @reset_door_routine_flags ; CALL $CD68        ;
       li   hl,lives                   ; LD HL,$CC59       ; 
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ; Lose life
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; 
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; 
       b    @return_with_carry         ; RET               ;

* Configurable "pause".
* 
* Used by the routines at #R$C7C0 and #R$CD1B.
*
* Loops back on itself using #REGb as a counter.
halt_loop:                             ; cd64
       bl   @ti_vsync                     ; HALT              ; {Short interrupt driven pause, and return.
       sb   one,b                      ; DJNZ $CD64        ; 
       jne  halt_loop                  ;                   
       .ret                            ; RET               ; }

* Initialise Door Flags.
* 
* Used by the routines at #R$C7C0 and #R$CD47.
*
* Populates the state flags for each door.
reset_door_routine_flags:              ; cd68
       li   ix,door_1_flags            ; LD IX,$D165       ; {Call #R$D8A1 using #REGix=#R$D165.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_2_flags            ; LD IX,$D173       ; {Call #R$D8A1 using #REGix=#R$D173.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_3_flags            ; LD IX,$D181       ; {Call #R$D8A1 using #REGix=#R$D181.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       .ret                            ; RET               ; Return.
*
* Score (6 bytes)
score_digit_6:                         ; cd86
       byte >00
score_digit_5:                         ; cd87
       byte >00
score_digit_4:                         ; cd88
       byte >00
score_digit_3:                         ; cd89
       byte >00
score_digit_2:                         ; cd8a
       byte >00
score_digit_1:                         ; cd8b
       byte >00

* Game status buffer entry at CD8C
       byte >00

* Game status buffer entry at CD8D
       byte >07,>4F,>52                                              ; ???

* Draw Score To The Screen
* 
* Used by the routines at #R$5B98, #R$C7C0 and #R$CDC3.
draw_score:                            ; cd90
       li   hl,score_digit_1           ; LD HL,$CD8B       ; {Starting values; #TABLE(default,centre,centre,centre,centre)
       li   de,zx_screen+>10c8         ; LD DE,$50C8       ; { =h Source | =h Screen Buffer | =h Counter }
       movb @bytes+6,b                 ; LD B,$06          ; { #R$CD8B | $50C8 | $06 }
                                                           ; TABLE#}
score_digit_loop:                      ; cd98
       .push bc                        ; PUSH BC           ; {Stash the lot.
       .push de                        ; PUSH DE           ; 
       .push hl                        ; PUSH HL           ; }
       movb *hl,a                      ; LD A,(HL)         ; {Grab the number at the source memory location;
       ; AND A                         ; AND A             ; #LIST
       jne  score_digit_non_zero       ; JR NZ,$CDA1       ; { If it's zero then add $0A (as the numbers are stored 1-2-3-4-5-6-7-8-9-0 whereas ASCII uses 0-1-2-3-4-5-6-7-8-9) }
       ab   @bytes+10,a                ; ADD A,$0A         ; { add $23 (so for example "2" will be "$25" - see #R$CDAE) }
score_digit_non_zero:                  ; cda1
       ab   @bytes+25,a                ; ADD A,$23         ; { Call #R$CDAE }
       bl   @draw_tt_char              ; CALL $CDAE        ; LIST#}
       .pop hl                         ; POP HL            ; {Retrieve our current source, destination and counter
       .pop de                         ; POP DE            ; from the stack.
       .pop bc                         ; POP BC            ; }
       inc  de                         ; INC DE            ; {Increase the screen buffer memory location by one, decrease the source memory location and loop round to
       dec  hl                         ; DEC HL            ; #R$CD98 until it is zero.
       sb   one,b                      ; DJNZ $CD98        ; }
       jne  score_digit_loop           ;                   
       .ret                            ; RET               ; Return.

*********************************************************************
* Draw Numbering from Character Set Index.
* 
* Used by the routines at #R$CBD0 and #R$CD90.
* a: character index to draw
draw_tt_char:                          ; cdae
       .proc
       .push de                        ; PUSH DE           ; {Using $C000 as a base address, this works out the character set memory address from a given index passed
       sb   h,h                        ; LD H,$00          ; in #REGa. To give an example using "2" ($25 - see #R$CD90);
       movb a,@l                       ; LD L,A            ; #LIST
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Loads <strong>$25</strong> as the low-order byte; #REGhl=$0025) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Times by <strong>$10</strong>; #REGhl=$250) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Add <strong>$C000</strong>=#R$C250) }
       a    hl,hl                      ; ADD HL,HL         ; LIST#
       li   de,gfx_char_a              ; LD DE,$C000       ; This is then passed to #R$D5E6.
       a    de,hl                      ; ADD HL,DE         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .pop hl                         ; POP HL            ; 
       li   bc,>1001                   ; LD BC,$1001       ;
       bl   @ti_copy_routine             ; CALL $D5E6        ; }
       .endproc                        ; RET               ; Return.
*// draw_tt_char

* Apply Scoring
* 
* Used by the routine at #R$C7C0.
scoring:                               ; cdc3
       li   ix,door_1_flags            ; LD IX,$D165       ; {Calls #R$CDDC three times with #REGix containing;
       .call @scoring_for_door         ; CALL $CDDC        ; #LIST
       li   ix,door_2_flags            ; LD IX,$D173       ; { #R$D165 }
       .call @scoring_for_door         ; CALL $CDDC        ; { #R$D173 }
       li   ix,door_3_flags            ; LD IX,$D181       ; { #R$D181 }
       .call @scoring_for_door         ; CALL $CDDC        ; LIST#}
       .call @draw_score               ; CALL $CD90        ; Call #R$CD90.
       .ret                            ; RET               ; Return.
* Passes the higher and lower score values to #R$CDF7 for the current door.
scoring_for_door:                      ; cddc
       li   hl,score_digit_5           ; LD HL,$CD87       ; References #R$CD87.
       movb @6(ix),b                   ; LD B,(IX+$06)     ; Retrieves #REGix+$06, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @6(ix),@6(ix)              ; LD (IX+$06),$00   ; 
       .call @scoring_apply            ; CALL $CDF7        ; Call #R$CDF7.
       li   hl,score_digit_4           ; LD HL,$CD88       ; References #R$CD88.
       movb @7(ix),b                   ; LD B,(IX+$07)     ; Retrieves #REGix+$07, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; 
       .call @scoring_apply            ; CALL $CDF7        ; Call #R$CDF7.
       .ret                            ; RET               ; Return.
* Applies the door scores into the player score.
scoring_apply:                         ; cdf7
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       .call @scoring_base_10          ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       movb @bytes+5,@e                ; LD E,$05          ; Sets a counter to $05 (5 more digits in the score).
scoring_apply_loop:                    ; cdfe
       inc  hl                         ; INC HL            ; Move onto the next scoring digit.
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       .call @scoring_base_10          ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       sb   one,@e                     ; DEC E             ; {Loop back to #R$CDFE until the counter is zero (and
       jne  scoring_apply_loop         ; JR NZ,$CDFE       ; all scoring digits are accounted for).}
       .ret                            ; RET               ; Return.
* Ensures the current scoring digit remains 0-9 (if $0A then it's reset and the
* carry digit is forwarded on).
scoring_base_10:                       ; ce08
       ab   b,a                        ; ADD A,B           ; Adds current score digit with passed score.
       sb   b,b                        ; LD B,$00          ; Reset passed score to zero.
       cb   a,@bytes+10                ; CP $0A            ; {Return if result is less than $0A (base 10).
       jhe  !                          ; RET C             ; }
       .ret                            ;                   
!
       sb   @bytes+10,a                ; SUB $0A           ; Subtract $0A to keep this digit in base 10 (e.g. "11"
                                                           ; becomes "1", "12" becomes "2", and so on).
       ab   one,b                      ; INC B             ; {Add one onto the passed score (which carries onto the
       .ret                            ; RET               ; next digit as it goes lowest to highest) and return.}

* Control Method Routine Alias.
* 
* Points to either #R$D392 or #R$D39B depending on the chosen control method.
control_routine_alias:                 ; ce12
       data controls_keyboard                              ; 16 bit memory location of either the keyboard or
                                                           ; joystick control routines.

* Door Routine Buffer.
* 
* These buffers point to the routines for character/ door actions for each door that are currently "in-play".
* Some example routines would be;
* #TABLE(default,centre,centre)
* { =h Routine | =h Door }
* { #R$D192 | "Normal" Bandit }
* { #R$D1DC | Bowie }
* { #R$D201 | Customer }
* { #R$D241 | Julius }
* { #R$D289 | "Drawing" Bandit }
* TABLE#
* And will also hold the door closing routines as well.
door_1_routine:                        ; ce14
       data 0                                                        ; Door 1 character/ door routine in-play.
door_2_routine:                        ; ce16
       data 0                                                        ; Door 2 character/ door routine in-play.
door_3_routine:                        ; ce18
       data 0                                                        ; Door 3 character/ door routine in-play.

* Door Frame Reference
* 
* Only one door is "active" at a time, this status buffer points to the
* "currently in-focus door".
door_frame_ref:                        ; ce1a
       byte >03                                                      ; #TABLE(default,centre,centre)
                                                                     ; { =h Value | =h Which One }
                                                                     ; { $01 | Door 1 }
                                                                     ; { $02 | Door 2 }
                                                                     ; { $03 | Door 3 }
                                                                     ; TABLE#

* Game status buffer entry at CE1B
chooser_countdown_init:                ; ce1b copied to _ce1e
       byte >03
delay:                                 ; ce1c
       data >0380
chooser_countdown:                     ; ce1e
       byte >03
* Defines the entry point for the choosing routines. Note, this isn't for one choice - they chain into each other
* this simply points to where the chain starts.
chooser_routine_ptr:                   ; ce1f
       data choose_bandit_5

* Choose Door Character.
* 
* Used by the routine at #R$C7C0.
* 
* The characters available on a particular level are determined by #R$CE1F.
* #TABLE(default,centre,centre)
* { =h Initialisation Routine | =h Door }
* { #R$CE42 | Door 1 }
* { #R$CE8D | Door 2 }
* { #R$D18A | Door 3 }
* TABLE#
* ix=door flags (door_1_flags, door_2_flags, door_3_flags)
* hl=door routine (door_1_routine, door_2_routine, door_3_routine)
*
character_chooser:                     ; ce21
* Wait 3 times before letting us in
       li   hl,chooser_countdown       ; LD HL,$CE1E       ; {Decrease #R$CE1E by one.
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ;
                                       ; LD (HL),A         ; }
       jeq  !                          ; RET NZ            ; Return if not zero.
       .ret                            ;                   
!
* Door also has a count-down
       movb @chooser_countdown_init,*hl ; LD A,($CE1B)      ; {Copies #R$CE1B into #R$CE1E.
                                       ; LD (HL),A         ; }
                                       ; LD A,(IX+$09)     ; {Decrease ????? by one.
       sb   one,@9(ix)                 ; DEC A             ; #TABLE(default,centre,centre)
                                       ; LD (IX+$09),A     ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       jeq  chooser                    ; RET NZ            ; Return if not zero.
       .ret                            ;
chooser:                               ; ce34
*      Reset door count-down to random value
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,31*256                   ; AND $1F           ; Keep bits 0-4 (so 0-31).
       socb @bytes+8,a                 ; OR $08            ; {Set bit 3 and write the resulting value to;
       movb a,@9(ix)                   ; LD (IX+$09),A     ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       mov  @chooser_routine_ptr,hl    ; LD HL,($CE1F)     ; {Jump to the memory address contained at #R$CE1F.
       b    *hl                        ; JP (HL)           ; .
* Handles choosing one of the initial "default" characters. A
* character is always chosen here, so this is the end of the
* choosing routine.
choose_default_set:                    ; ce42
       .call @gen_random_number        ; CALL $DAEF        ; Call #R$DAEF.
       andi a,3*256                    ; AND $03           ; Keep only bits 0 and 1 (which determine the type of
                                                           ; character).
       jeq  init_bandit_open           ; JR Z,$CEB8        ; {Determines which character initialisation to run;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre,centre)
       jne  !                          ; JP Z,$CEFC        ; { =h #REGa | =h Initialisation Routine }
       b    @init_bowie                ;                   
!
       sb   one,a                      ; DEC A             ; { $00 | #R$CEB8 }
       jne  !                          ; JP Z,$CF5E        ; { $01 | #R$CEFC }
       b    @init_customer_close       ;                   
!
       sb   one,a                      ; DEC A             ; { $02 | #R$CF5E }
       b    @init_customer_open        ; JP $CF2B          ; { $03 | #R$CF2B }
                                                           ; TABLE#}
* Handles whether or not to choose Julius.
choose_julius:                         ; ce55
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,12*256                   ; AND $0C           ; {Keep only bits 2 and 3. Jump to the next character "test" if
       jne  choose_bandit_2            ; JR NZ,$CE5F       ; this is a non-zero number at #R$CE5F.}
       b    @init_julius_open          ; JP $CFB7          ; Jump to #R$CFB7.
* Handles whether or not to choose Bandit 2.
choose_bandit_2:                       ; ce5f
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,152*256                  ; AND $98           ; {Keep only bits 3, 4 and 7. Jump to the next character "test" if
       jne  choose_bandit_3            ; JR NZ,$CE6F       ; this is a non-zero number at #R$CE6F.}
       li   hl,bandit_2_source         ; LD HL,$D119       ; Set source character data to #R$D119.
       li   de,bandit_2_buffer         ; LD DE,$D124       ; Set target character buffer to #R$D124.
       b    @choose_action             ; JP $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 3.
choose_bandit_3:                       ; ce6f
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,49*256                   ; AND $31           ; {Keep only bits 0, 4 and 5. Jump to the next character "test" if
       jne  choose_default_set         ; JR NZ,$CE42       ; this is a non-zero number then jump back to the #R$CE42.
                                                           ; }
       li   hl,bandit_3_source         ; LD HL,$D0C1       ; Set source character data to #R$D0C1.
       li   de,bandit_3_buffer         ; LD DE,$D0CC       ; Set target character buffer to #R$D0CC.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 4.
choose_bandit_4:                       ; ce7e
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,131*256                  ; AND $83           ; {Keep only bits 0, 1 and 7. Jump to the next character "test" if
       jne  choose_julius              ; JR NZ,$CE55       ; this is a non-zero number #R$CE55.}
       li   hl,bandit_4_source         ; LD HL,$D0D7       ; Set source character data to #R$D0D7.
       li   de,bandit_4_buffer         ; LD DE,$D0E2       ; Set target character buffer to #R$D0E2.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 5.
choose_bandit_5:                       ; ce8d
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,88*256                   ; AND $58           ; {Keep only bits 3, 4 and 6. Jump to the next character "test" if
       jne  choose_bandit_4            ; JR NZ,$CE7E       ; this is a non-zero number #R$CE7E.}
       li   hl,bandit_5_source         ; LD HL,$D0ED       ; Set source character data to #R$D0ED.
       li   de,bandit_5_buffer         ; LD DE,$D0F8       ; Set target character buffer to #R$D0F8.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 6.
choose_bandit_6:                       ; ce9c
       bl   @random_number             ; CALL $D8B0        ; Call #R$D8B0.
       andi a,113*256                  ; AND $71           ; {Keep only bits 0, 4, 5 and 6. Jump to the next character "test" if
       jne  choose_bandit_5            ; JR NZ,$CE8D       ; this is a non-zero number #R$CE8D.}
       li   hl,bandit_6_source         ; LD HL,$D103       ; Set source character data to #R$D103.
       li   de,bandit_6_buffer         ; LD DE,$D10E       ; Set target character buffer to #R$D10E.
* Stashes the chosen character source/ buffer to the door state buffer.
choose_action:                         ; cea9
       mov  hl,@12(ix)                 ; LD (IX+$0C),L     ; {Writes the character source memory address to one of the following (depending on which door is currently
                                       ; LD (IX+$0D),H     ; being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D171 | Door 1 }
                                                           ; { #R$D17F | Door 2 }
                                                           ; { #R$D18D | Door 3 }
                                                           ; TABLE#}
       movb de,@10(ix)                 ; LD (IX+$0A),E     ; {Writes the character target/ buffer memory address to one of the following (depending on which door is
                                       ; LD (IX+$0B),D     ; currently being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#}
       b    @init_bandit_draw_open     ; JP $D019          ; Jump to #R$D019.

* Character Initialisations.
* 
* Used by the routines at #R$CE21 and #R$D48F.
* 
* .
* 
* Writes a "bandit opening the door" to the door flags/ cache.
init_bandit_open:                      ; ceb8
       li   de,prep_bandit_open        ; LD DE,$D192       ; {Writes #R$D192 to the address contained
*      Set hl = pointer to pointer to door routine
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
*      Set pointer to door routine to prep_bandit_open
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
*      Set hl = pointer to bandit data
       li   hl,bandit_open_source      ; LD HL,$D076       ; {Handles copying $0007 bytes of data from the address contained
*      Set de = pointer to door source data
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
*      Copy 7 bytes from bandit data to door source data
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D076.}
*      Set the flag
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F and return.
                                       ; LD ($D18F),A      ;
       .ret                            ; RET               ; }
* Writes a "bandit closing the door" to the door flags/ cache.
init_bandit_close:                     ; ced8
       li   de,prep_bandit_close       ; LD DE,$D1B7       ; {Writes #R$D1B7 to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov de,*hl                      ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,bandit_close_source                   ; LD HL,$D07D       ; {Handles copying $0007 bytes of data from the address contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D07D.}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F.
                                       ; LD ($D18F),A      ; }
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; Score?
       .ret                            ; RET               ; 
* Writes "Bowie" to the door flags/ cache.
init_bowie:                            ; cefc
       li   de,prep_bowie              ; LD DE,$D1DC       ; {Writes #R$D1DC to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,8*256                    ; AND $08           ; 
       li   hl,bowie_source            ; LD HL,$D084       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  init_bowie_set_flag        ; JR Z,$CF16        ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_bowie_set_flag:                   ; cf16
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>0009                   ; LD BC,$0009       ; 
       .ldir                           ; LDIR              ; 
       li   de,bowie_shot_action       ; LD DE,$D863       ; 
       mov  de,@4(ix)                  ; LD (IX+$04),E     ;
                                       ; LD (IX+$05),D     ;
       .ret                            ; RET               ; 
* Writes a "customer opening the door" to the door flags/ cache.
init_customer_open:                    ; cf2b
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,130*256                  ; AND $82           ; 
       li   hl,customer_open_source_2  ; LD HL,$D0A1       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_open_set_flag    ; JR NZ,$CF45       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_cust_open_set_flag:               ; cf45
       li   hl,customer_open_source_1  ; LD HL,$D09C       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ; 
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ; 
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes a "customer closing the door" to the door flags/ cache.
init_customer_close:                   ; cf5e
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number             ; CALL $D8B0        ;
       andi a,65*256                   ; AND $41           ; 
       li   hl,customer_close_source_2 ; LD HL,$D092       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_close_set_flag   ; JR NZ,$CF78       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_cust_close_set_flag:              ; cf78
       li   hl,customer_close_source_1 ; LD HL,$D08D       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ; 
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ; 
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes a "customer being shot" to the door flags/ cache.
init_customer_shot:                    ; cf91
       li   de,prep_customer_shot      ; LD DE,$D226       ; {Writes #R$D226 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; {Loads e.g. #R$D167 (depending on which door is currently
                                       ; LD D,(IX+$03)     ; being actioned) into #REGde.}
       li   hl,customer_shot_source    ; LD HL,$D0AB       ; #REGhl=#R$D0AB.
       ai   de,6                       ; INC DE            ; {Increase #REGde by $06.
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ; }
       li   bc,>0003                   ; LD BC,$0003       ; {Copies three sequential bytes of data from #REGhl to
       .ldir                           ; LDIR              ; #REGde.}
       li   hl,copy_char_data_flag     ; LD HL,$D18F       ; {Writes $01 to #R$D18F and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }
* Writes "Julius opening the door" to the door flags/ cache.
init_julius_open:                      ; cfb7
       li   de,prep_julius_open        ; LD DE,$D241       ; {Writes #R$D241 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_open_source      ; LD HL,$D0AE       ;
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       bl   @random_number             ; CALL $D8B0        ;
       andi a,32*256                   ; AND $20           ; 
       jne  init_julius_open_set_flag  ; JR NZ,$CFD1       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_julius_open_set_flag:             ; cfd1
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000a                   ; LD BC,$000A       ; 
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes "Julius closing the door" to the door flags/ cache.
init_julius_close:                     ; cfdd
       movb one,@julius_close_source   ; LD A,$01          ; {Writes $01 to #R$D0B8.
                                       ; LD ($D0B8),A      ; }
julius_callback:                       ; cfe2
       li   de,prep_julius_close       ; LD DE,$D265       ; {Writes #R$D265 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_close_source     ; LD HL,$D0B8       ; {Handles copying $0009 bytes of data from the address (plus 1) contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       inc  de                         ; INC DE            ; { =h Address | =h Door }
       li   bc,>0009                   ; LD BC,$0009       ; { #R$D167 | Door 1 }
       .ldir                           ; LDIR              ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D0B8.}
       movb one,@copy_char_data_flag   ; LD A,$01          ;
                                       ; LD ($D18F),A      ;
       li   hl,julius_close_source     ; LD HL,$D0B8       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; 
       movb a,@7(ix)                   ; LD (IX+$07),A     ; 
       movb a,@6(ix)                   ; LD (IX+$06),A     ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ret                            ; RET               ; 

* Routine at D019
* 
* Used by the routine at #R$CE21.
init_bandit_draw_open:                 ; d019
       li   de,prep_bandit_draw_open   ; LD DE,$D289       ; {Writes #R$D289 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @12(ix),hl                 ; LD L,(IX+$0C)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0D)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D171 | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17F | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18D | #R$D183 | Door 3 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Routine at D037
set_state_init_bandit_draw_close:      ; d037
       movb one,a                      ; LD A,$01          ; {Writes $01 to the address contained
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       movb a,*hl                      ; LD (HL),A         ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; This is the first byte of character state data.}
init_bandit_draw_close:                ; d040
       li   de,prep_bandit_draw_close  ; LD DE,$D2AD       ; {Writes #R$D2AD to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#
                                                           ; This is copying the actual source data into the cache where it can be manipulated by the game events.
                                                           ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D16F | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17D | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18B | #R$D183 | Door 3 }
                                                           ; TABLE#}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Initialise #R$D18F (writes $01 to it).
                                       ; LD ($D18F),A      ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Loads #REGa with the flag from the address contained
                                       ; LD H,(IX+$0B)     ; at (depending on which door is currently being actioned);
       movb *hl,a                      ; LD A,(HL)         ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; As per #R$D037, this should be $01.}
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       ; AND A                         ; AND A             ;
       movb a,a
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; Score?
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ret                            ; RET               ; Return.

* Copy Source Character Data To Character State Data.
*
* Handles copying a "normal" bandit into the bandit state cache at #R$D71E.
prep_bandit_open:                      ; d192
*      Set hl = pointer to door source data
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
*      Copy 7 bytes from door source data to bandit state
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       .call @bandit_open_routing      ; CALL $D725        ; Call #R$D725 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
*      If flag is set then reset and copy state data back to door source data
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* And copying a successful bandit encounter to close the door.
prep_bandit_close:                     ; d1b7
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       .call @bandit_close_routing     ; CALL $D771        ; Call #R$D771 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying Bowie state data into the state cache at #R$D7C5.
prep_bowie:                            ; d1dc
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0009 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bowie_good_bad          ; LD DE,$D7C5       ; #TABLE(default,centre,centre)
       li   bc,>0009                   ; LD BC,$0009       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D7C5.}
       .call @bowie_routing            ; CALL $D7CE        ; Call #R$D7CE to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying customer state data into the state cache at #R$D48F.
prep_customer:                         ; d201
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       .call @customer_routing         ; CALL $D49E        ; Call #R$D49E to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying customer "is shot" state data into the state cache at
* #R$D48F.
prep_customer_shot:                    ; d226
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       .call @customer_shot            ; CALL $D57B        ; Call #R$D57B.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       .ldir                           ; LDIR              ; {Copy the (swapped) source back to the new target and
       .ret                            ; RET               ; return.}
* Handles copying Julius state data into the state cache at #R$D8E5.
prep_julius_open:                      ; d241
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       .call @julius_open_routing      ; CALL $D8EF        ; Call #R$D8EF.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* And copying a successful Julius encounter to close the door.
prep_julius_close:                     ; d265
       movb @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       .call @julius_close_routing     ; CALL $D997        ; Call #R$D997.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a                   ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* Handles copying a "drawing bandit" into the bandit state cache at #R$DA0C.
prep_bandit_draw_open:                 ; d289
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       .call @bandit_draw_open_routing ; CALL $DA17        ; Call #R$DA17.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* And copying a successful "drawing bandit" encounter to close the door.
prep_bandit_draw_close:                ; d2ad
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       .call @bandit_draw_close_routing ; CALL $DA85        ; Call #R$DA85.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. If it wasn't zero then
       ; AND A                         ; AND A             ; return.
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ; Suspicious that flag was not set to 0
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }

* Routine at D2CF
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
check_input:                           ; d2cf
       bl   @execute_control_method    ; LD HL,($CE12)     ; #R$CE12
                                       ; LD DE,$D2D7       ; Return address
                                       ; PUSH DE           ;
                                       ; JP (HL)           ;
check_input_1:                         ; d2d7
*      Clear
       movb a,@c                       ; LD C,A            ;
       sb   a,a                        ; XOR A             ;
       li   hl,byte_before_hit         ; LD HL,$D2FF       ;
       movb a,*hl+                     ; LD (HL),A         ; clear _d2ff
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear hit
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear right
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear left
       movb @c,a                       ; LD A,C            ; 
*      Is 1,2,3 pressed?
       movb a,tmp0                     ; BIT 4,A           ;
       andi tmp0,16*256                ;                   
       jne  controls                   ; JR NZ,$D307       ; Yes - jump
*      No, clear 1,2,3
       li   hl,two_pressed             ; LD HL,$D303       ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear two
                                       ; INC HL            ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear three
                                       ; INC HL            ;
       sb   *hl,*hl                    ; LD (HL),$00       ; clear one
*      Is right pressed?
       movb a,tmp0                     ; BIT 0,A           ; 
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,$D386       ; 
       b    @set_right                 ;                   
!
*      Is left pressed
       movb a,tmp0                     ; BIT 1,A           ; 
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,$D38C       ; 
       b    @set_left                  ;                   
!
       .ret                            ; RET               ;

player_died_status:                    ; d2fe
       byte >02                        ;
byte_before_hit:
       byte >00                        ; just cleared - not used
* Player Shot. Which door player is shooting at.
hit:                                   ; d300
       byte >00                                                      ; #TABLE(default,centre,centre)
                                                                     ; { =h Value | =h What }
                                                                     ; { $00 | No shot/ inactive }
                                                                     ; { $01 | Door 1 }
                                                                     ; { $02 | Door 2 }
                                                                     ; { $03 | Door 3 }
                                                                     ; TABLE#

* Player Left/ Right.
*
* These flags don't control left/ right movement they just indicate whether
* keys are being pressed/ joystick used.
right_pressed:                         ; d301
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "right".
left_pressed:                          ; d302
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "left".

* Player Shooting.
two_pressed:                           ; d303
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "2".
three_pressed:                         ; d304
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "3".
one_pressed:                           ; d305
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "1".
controls_byte:                         ; d306
       byte >11                                                      ; Holds the controls in one byte.
                                                                     ; #TABLE(default,centre,centre,centre)
                                                                     ; { =h Value | =h Bits | Door }
                                                                     ; { $10 | #EVAL($10, 2, 8) | Door 2 }
                                                                     ; { $11 | #EVAL($11, 2, 8) | Door 3 }
                                                                     ; { $12 | #EVAL($12, 2, 8) | Door 1 }
                                                                     ; TABLE#
* Action Controls.
* 
* Used by the routine at #R$D2CF.
* 
* On entry #REGa will contain one of;
* #TABLE(default,centre,centre,centre)
* { =h Value | =h Bits | Door }
* { $10 | #EVAL($10, 2, 8) | Door 2 }
* { $11 | #EVAL($11, 2, 8) | Door 3 }
* { $12 | #EVAL($12, 2, 8) | Door 1 }
* TABLE#
* This is written to #R$D306, and then decoded into writing a $01, $02 or $03 to #R$D300 to represent which door has
* been shot at.  This routine also writes $01 to #R$D305, #R$D303 and #R$D304 to represent the same thing.
* Before returning, #REGhl is set to the screen location for displaying the shot mask/ shot image in the centre of the
* door.
controls:                              ; d307
       li   hl,controls_byte           ; LD HL,$D306       ; {Writes #REGa to #R$D306 and sets #REGhl=#R$D300.
       movb a,*hl                      ; LD (HL),A         ; 
       li   hl,hit                     ; LD HL,$D300       ; }
       movb @c,a                       ; LD A,C            ; 
       movb a,tmp0                     ; BIT 0,A           ; {If "3" was pressed then jump to #R$D33B (a check for if
       andi tmp0,1*256                 ;                   
       jne  shot_three                 ; JR NZ,$D33B       ; bit 0 is set).}
       movb a,tmp0                     ; BIT 1,A           ; {If "1" was pressed then jump to #R$D360 (a check for if
       andi tmp0,2*256                 ;                   
       jne  shot_one                   ; JR NZ,$D360       ; bit 1 is set).}
* Handles settings flags and shot drawing location for door 2.
shot_two:                              ; d317
       movb @two_pressed,a             ; LD A,($D303)      ; {If #R$D303 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@three_pressed           ; LD ($D304),A      ; {Sets the other two door flags to zero (#R$D304 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the middle door is being shot at (write
       movb one,@two_pressed           ; LD ($D303),A      ; $01 to #R$D303 and $02 to #R$D300).
                                       ; LD A,$02          ;
       movb @bytes+2,*hl               ; LD (HL),A         ; }
       li   hl,random_seed             ; LD HL,$D8AC       ; {Increase #R$D8AC by one.
       ab   one,*hl                    ; INC (HL)          ; }
       bl   @ti_draw_door_2_shot
       bl    @shot_sound_1              ; JP $6500          ; Jump to #R$6500.
       .ret
* Handles settings flags and shot drawing location for door 3.
shot_three:                            ; d33b
       movb @three_pressed,a           ; LD A,($D304)      ; {If #R$D304 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the right door is being shot at (write $01
       movb one,@three_pressed         ; LD ($D304),A      ; to #R$D304 and $03 to #R$D300).
                                       ; LD A,$03          ;
       movb @bytes+3,*hl               ; LD (HL),A         ; }
       mov  @random_seed,tmp0          ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       sla  tmp0,1                     ; SLA (HL)          ; moved to the carry flag and bit 0 reset (zeroed).}
       mov  tmp0,@random_seed
       bl   @ti_draw_door_3_shot
       bl   @shot_sound_2              ; JP $6502          ; Jump to #R$6502.
       .ret
* Handles settings flags and shot drawing location for door 1.
shot_one:                              ; d360
       movb @one_pressed,a             ; LD A,($D305)      ; {If #R$D305 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@three_pressed           ; LD ($D304),A      ; #R$D304).}
                                       ; INC A             ; {Indicate the the left door is being shot at (write $01
       movb one,@one_pressed           ; LD ($D305),A      ; to #R$D305 and $01 to #R$D300).
                                       ; LD A,$01          ;
       movb one,*hl                    ; LD (HL),A         ; }
       mov  @random_seed,tmp0          ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       sla  tmp0,1                     ; SLA (HL)          ; moved to the carry flag and bit 0 reset (zeroed).}
       mov  tmp0,@random_seed
       bl   @ti_draw_door_1_shot
       bl   @shot_sound_3              ; CALL $6504        ; Jump to #R$6504.
       .ret                            ; RET               ; Return.
* Sets the flag for indicating "right" has been pressed by the player.
set_right:                             ; d386
       li   hl,right_pressed           ; LD HL,$D301       ; {Write $01 to #R$D301 and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }
* Sets the flag for indicating "left" has been pressed by the player.
set_left:                              ; d38c
       li   hl,left_pressed            ; LD HL,$D302       ; {Write $01 to #R$D302 and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }

*********************************************************************
* Jump Controls.
*
* Loads the 16 bit address stored at #R$CE12 into #REGhl and jumps to it.
execute_control_method:                ; 5b88
       .proc
       mov  @control_routine_alias,hl  ; LD HL,($CE12)     ;
       b    *hl                        ; JP (HL)           ;

* Reads In-Game Joystick Controls.
controls_joystick:                     ; d392
* Jump - not call
       sb   a,a
       li   tmp0,KEY_FI
       bl   @ti_check_key
       jeq  controls_joystick_1
       movb @bytes+>10,a
controls_joystick_1:
       li   tmp0,KEY_LF
       bl   @ti_check_key
       jeq  controls_joystick_2
       socb @bytes+>02,a
controls_joystick_2:
       li   tmp0,KEY_RG
       bl   @ti_check_key
       jeq  controls_joystick_3
       socb @bytes+>01,a
controls_joystick_3:
       .endproc                         ; RET               ; Return.

*********************************************************************
* Reads In-Game Keyboard Controls (1-2-3).
* 
* Used by the routine at #R$D392.
controls_keyboard:                     ; d39b
* Jump - not call
       sb   a,a                        ; LD A,$F7          ; {Read keys 1-2-3-4-5.
                                       ; IN A,($FE)        ; }
controls_keyboard_1:                   ; d39f
       li   tmp0,KEY_1                 ; BIT 0,A           ; {If "1" isn't being pressed then jump to #R$D3A6.
       bl   @ti_check_key              ;
       jeq  controls_keyboard_2        ; JR NZ,$D3A6       ; }
       movb @bytes+18,a                ; LD A,$12          ; {Set #REGa=$12 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
controls_keyboard_2:                   ; d3a6
       li   tmp0,KEY_2                 ; BIT 1,A           ; {If "2" isn't being pressed then jump to #R$D3AD.
       bl   @ti_check_key              ;
       jeq  controls_keyboard_3        ; JR NZ,$D3AD       ; }
       movb @bytes+16,a                ; LD A,$10          ; {Set #REGa=$10 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
controls_keyboard_3:                   ; d3ad
       li   tmp0,KEY_3                 ; BIT 2,A           ; {If "3" isn't being pressed then jump to #R$D3E2.
       bl   @ti_check_key              ;
       jeq  controls_input_o_p         ; JR NZ,$D3E2       ; }
       movb @bytes+17,a                ; LD A,$11          ; {Set #REGa=$11 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
* Reads In-Game Controls (Left + Right).
* Used by the routine at #R$D39B.
controls_input_o_p:                    ; d3e2
       li   tmp0,KEY_O                 ; LD A,$DF          ; {Read keys P-O-I-U-Y.
       bl   @ti_check_key              ; IN A,($FE)        ; }
       jeq  controls_keyboard_5        ; CPL               ; Invert all the bits of #REGa.
       movb @bytes+2,a                 ; AND $03           ; Keep only bits 0 and 1 (i.e. we only care about "P" and
                                                           ; "O" for left and right).
       jmp  controls_keyboard_6                            ; RET               ; Return.
controls_keyboard_5:
      li   tmp0,KEY_P
       bl   @ti_check_key
       jeq  controls_keyboard_6
       movb one,a
controls_keyboard_6:
       .endproc

*********************************************************************
* Routine at D3EA
check_ready_to_scroll:                 ; d3ea
       li   hl,door_1_routine          ; LD HL,$CE14       ; #R$CE14
       sb   a,a                        ; XOR A             ; {Sets #REGa=0 and #REGb=$06 (counter).
       li   bc,6                       ; LD B,$06          ; }
check_no_doors_active:                 ; d3f0
       socb *hl+,a                     ; OR (HL)           ;
                                       ; INC HL            ;
       dec  bc                         ; DJNZ $D3F0        ;
       jne  check_no_doors_active                        ;
       ; AND A                         ; AND A             ; 
       .pop bc                         ; POP BC            ; Pop return address off stack
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   ; Return to caller's caller (game_loop) if any door active
!
       .push bc                        ; PUSH BC           ; Push return address back
       li   hl,random_seed             ; LD HL,$D8AC       ;
       ab   one,*hl                    ; INC (HL)          ; 
                                       ; LD DE,$0400       ; (TI moved)
       .call @check_cashboxes_flag     ; CALL $D407       ;
       joc  !                          ; RET NC            ; Return move_right_or_left if cashboxes not completed
       .ret                            ;                   ;
!
       .pop bc                         ; POP AF            ; Pop return address off stack
       .pop bc                         ; POP AF            ; Pop return address off stack
       ; AND A                         ; AND A             ;
       b    @return_without_carry      ; RET               ; Return to caller's caller's caller (run_phase)

check_cashboxes_flag:                  ; d407
       li   hl,cashboxes_completed_flag ; LD HL,$CA80      ;
       movb *hl,a                      ; LD A,(HL)         ; Check the flag
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; 
       b    @return_without_carry      ;                   ; Return without carry if not completed
!
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear the flag
       ; SCF                           ; SCF               ; 
       b    @return_with_carry         ; RET               ; Return with carry if completed

* This entry point is used by the routine at #R$C7C0.
move_right_or_left:                    ; d411
       .call @check_ready_to_scroll    ; CALL $D3EA        ;
       li   de,>0100                                       ; Number of iterations for loop to check left/right
move_right_or_left_loop:
       .push de                        ; PUSH DE           ; de=>400
       .call @check_input              ; CALL $D2CF        ;
       movb @right_pressed,a           ; LD A,($D301)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D42D     ; 
       .call @move_cashboxes_right     ;
!
       movb @left_pressed,a            ; LD A,($D302)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D449     ; 
       .call @move_cashboxes_left      ;
!
       .pop de                         ; POP DE            ; 
       dec  de                         ; DEC DE            ; 
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  move_right_or_left_loop    ; RET Z             ;
       .ret                            ;
                                       ; JR $D414          ;
move_cashboxes_right:                  ; d42d
       bl   @ti_scroll_left            ; CALL $6600        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   draw_selection_and_return  ; JR C,$D43F        ;
       movb one,*hl                    ; LD (HL),$01       ; 
draw_selection_and_return:             ; d43f
       .call @draw_cashbox_selections  ; CALL $D45E        ;
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb a,@cashbox_ref             ; LD ($D45C),A      ;
       .ret                            ; RET               ; 
move_cashboxes_left:                   ; d449
       bl   @ti_scroll_right           ; CALL $6700        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       sb   one,a                      ; DEC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       ; AND A                         ; AND A             ; 
       jne  draw_selection_and_return  ; JR NZ,$D43F       ;
       movb @bytes+12,*hl              ; LD (HL),$0C       ; 
       jmp  draw_selection_and_return  ; JR $D43F          ;

* Cash Deposit Box Reference.
cashbox_ref:                           ; d45c
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).
cashbox_ref_new:                       ; d45d
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).

* Routine at D45E
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
draw_cashbox_selections:               ; _d45e
       clr  a
       movb @cashbox_ref,a             ; LD A,($D45C)      ;
       movb @bytes+56,@c               ; LD C,$38          ; Attribute black/grey
       .call @draw_cashbox_selections_1 ; CALL $D46B       ; Remove old selection
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb @bytes+58,@c               ; LD C,$3A          ; Attribute red/grey
draw_cashbox_selections_1:             ; d46b              ; Apply new selection
       movb @bytes+3,b                 ; LD B,$03          ; 
draw_cashbox_selections_2:             ; d46d
       .push af                        ; PUSH AF           ; 
       .call @draw_cashbox_selection   ; CALL $D47E        ;
       .pop af                         ; POP AF            ; 
       ab   one,a                      ; INC A             ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   !                          ; CALL NC,$D47B     ; 
       .call @back_to_first_cashbox                    ;
!
       sb   one,b                      ; DJNZ $D46D        ; 
       jne  draw_cashbox_selections_2                      ;
       .ret                            ; RET               ; 
back_to_first_cashbox:                 ; d47b
       movb one,a                      ; LD A,$01          ; 
       .ret                            ; RET               ; 
draw_cashbox_selection:                ; d47e
                                       ; CP $07            ; In right side?
       li   hl,zx_attributes+>0005     ; LD HL,$5805       ; Right
       cb   a,@bytes+7
       jhe  draw_cashbox_selection_1   ; JR NC,$D488       ;
       li   hl,zx_attributes+>00ff     ; LD HL,$58FF       ; Left
draw_cashbox_selection_1:              ; d488
       ab   a,a                        ; ADD A,A           ; 2*a
       ab   @l,a                       ; ADD A,L           ; l=2*a-1 or l=2*a+5
       movb a,@l                       ; LD L,A            ;
       movb @c,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       inc  hl                         ; INC HL            ; 
       mov  hl,tmp1
       bl   @ti_draw_attribute
;      movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       .ret                            ; RET               ; 

* Customer Logic.
*
* Character state variables/ flags.
customer_frame_1:                      ; d48f
       byte >03                                                      ; Character frame index 1.
customer_frame_2:                      ; d490
       byte >04                                                      ; Character frame index 2.
customer_frame_3:                      ; d491
       byte >05                                                      ; Character frame index 3.
customer_frame_4:                      ; d492
       byte >06                                                      ; Character frame index 4.
customer_frame_5:                      ; d493
       byte >07                                                      ; Character frame index 5.
customer_flag_uncover:                 ; d494
       byte >01                                                      ; Represents whether the customer will move to uncover a bandit
                                                                     ; ($00 "normal" / $01 "uncover" action).
customer_state_ref:                    ; d495
       byte >02                                                      ; The current character state.
customer_1_timer:                      ; d496
       byte >0B                                                      ; Character timer 1.
customer_2_timer:                      ; d497
       byte >00                                                      ; Character timer 2.
customer_3_timer:                      ; d498
       byte >00                                                      ; Character timer 3.
customer_4_timer:                      ; d499
       byte >1E                                                      ; Character timer 4.
customer_5_timer:                      ; d49a
       byte >0C                                                      ; Character timer 5.
customer_6_timer:                      ; d49b
       byte >06                                                      ; Character timer 6.
customer_7_timer:                      ; d49c
       byte >08                                                      ; Character timer 7.
customer_8_timer:                      ; d49d
       byte >08                                                      ; Character timer 8.
* This routine looks at the current character state and routes to the correct
* subroutine.
customer_routing:                      ; d49e
       li   hl,customer_state_ref      ; LD HL,$D495       ; {#REGa=#R$D495.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  customer_open_1            ; JR Z,$D4BD        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  customer_open_2            ; JR Z,$D4CD        ; { $01 | #R$D4BD }
       sb   one,a                      ; DEC A             ; { $02 | #R$D4CD }
       jeq  customer_open_3            ; JR Z,$D4DD        ; { $03 | #R$D4DD }
       sb   one,a                      ; DEC A             ; { $04 | #R$D4ED }
       jeq  customer_open_4            ; JR Z,$D4ED        ; { $05 | #R$D524 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D540 }
       jne  !                          ; JP Z,$D524        ; { $07 | #R$D559 }
       b    @customer_uncover          ;                   
!
       sb   one,a                      ; DEC A             ; { $08 | #R$D56C }
       jne  !                          ; JP Z,$D540        ; TABLE#
       b    @customer_close_3          ;                   
!
       sb   one,a                      ; DEC A             ; 
       jne  !                          ; JP Z,$D559        ; 
       b    @customer_close_2          ;                   
!
       b    @customer_close_1          ; JP $D56C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
customer_open_1:                       ; d4bd
                                       ; LD A,($D496)      ; {Decrease #R$D496 by one, return if result is not
       sb   one,@customer_1_timer      ; DEC A             ; zero.
                                       ; LD ($D496),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
customer_open_2:                       ; d4cd
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
customer_open_3:                       ; d4dd
                                       ; LD A,($D498)      ; {Decrease #R$D498 by one, return if result is not
       sb   one,@customer_3_timer      ; DEC A             ; zero.
                                       ; LD ($D498),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 timer...
customer_open_4:                       ; d4ed
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D499)      ; {Decrease #R$D499 by one, return if result is not
       sb   one,@customer_4_timer      ; DEC A             ; zero.
                                       ; LD ($D499),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb @customer_flag_uncover,a   ; LD A,($D494)      ; {Jump to #R$D516 if #R$D494 is not zero.
       ; AND A                         ; AND A             ; 
       jne  customer_hands_up          ; JR NZ,$D516       ; }
       movb @bytes+7,*hl               ; LD (HL),$07       ; Set #R$D495 to use state $07 (#R$D559 on the next call
                                                           ; to #R$D49E).
       movb @customer_frame_1,a        ; LD A,($D48F)      ; {Call #R$D6DF using the character frame index from
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D48F.}
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; Issue 500 points (by writing $05 to the high order
                                                           ; byte of, e.g. #R$D16B).
                                       ; LD A,$01          ; {Register this as a deposit (by writing $01 to e.g.
       movb one,@8(ix)                 ; LD (IX+$08),A     ; #R$D16D).}
       movb one,@deposit_flag          ; LD ($D190),A      ; Writes $01 to #R$D190.
       .ret                            ; RET               ; Return.
* Handle customer putting their hands up.
customer_hands_up:                     ; d516
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_2,a        ; LD A,($D490)      ; Grab the character frame index from #R$D490.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles customer uncovering a "hidden" bandit action.
customer_uncover:                      ; d524
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D49A)      ; {Decrease #R$D49A by one, return if result is not
       sb   one,@customer_5_timer      ; DEC A             ; zero.
                                       ; LD ($D49A),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_3,a        ; LD A,($D491)      ; Grab the character frame index from #R$D491.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
customer_close_3:                      ; d540
                                       ; LD A,($D49B)      ; {Decrease #R$D49B by one, return if result is not
       sb   one,@customer_6_timer      ; DEC A             ; zero.
                                       ; LD ($D49B),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .call @init_bandit_open         ; CALL $CEB8        ; Call #R$CEB8.
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Load, e.g. #R$D167 (bandit source data) into #REGhl, and
                                       ; LD H,(IX+$03)     ; write $03 to the address contained in it.
       movb @bytes+3,*hl+              ; LD (HL),$03       ; }
       inct hl                         ; INC HL            ; {Increase the pointer to the bandit source data by 3 and
                                       ; INC HL            ; write $04 to this byte.
                                       ; INC HL            ;
       movb @bytes+4,*hl               ; LD (HL),$04       ; }
       .ret                            ; RET               ; Return.
* Handle door frame 3 countdown/ transition to door frame 2.
customer_close_2:                      ; d559
                                       ; LD A,($D49C)      ; {Decrease #R$D49C by one, return if result is not
       sb   one,@customer_7_timer      ; DEC A             ; zero.
                                       ; LD ($D49C),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       li   hl,customer_state_ref      ; LD HL,$D495       ; {Increase #R$D495 by one.
       ab   one,*hl                    ; INC (HL)          ; }
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
customer_close_1:                      ; d56c
                                       ; LD A,($D49D)      ; {Decrease #R$D49D by one, return if result is not
       sb   one,@customer_8_timer      ; DEC A             ; zero.
                                       ; LD ($D49D),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }
* Handles customer being shot.
customer_shot:                         ; d57b
       li   hl,customer_state_ref      ; LD HL,$D495       ; {If #R$D495 is zero then jump to #R$D584 else jump to
       movb *hl,a                      ; LD A,(HL)         ; #R$D58C.
       sb   one,a                      ; DEC A             ; 
       jeq  customer_shot_midair       ; JR Z,$D584        ; 
       jmp  customer_shot_floor        ; JR $D58C          ; }
customer_shot_midair:                  ; d584
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_4,a        ; LD A,($D492)      ; Grab the character frame index from #R$D492.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
customer_shot_floor:                   ; d58c
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb @customer_frame_5,a        ; LD A,($D493)      ; Grab the character frame index from #R$D493.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; Call #R$D6ED.
                                       ; LD A,$02          ; {Writes $02 to #R$D2FE.
       movb @bytes+2,@player_died_status ; LD ($D2FE),A      ; }
       .call @reset_door_routine       ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }

* Hit Detection.
* 
* Compares the #R$CE1A against the user input for a shot.
* If there isn't a shot to account for then we simply return,
* else we action a jump to the address held in #REGde on entry.
hit_detection:                         ; d5a3
                                       ; PUSH HL           ; Store #REGhl on the stack for later.
                                       ; LD A,($D300)      ; {Does a comparison of #R$D300 against #R$CE1A.
                                       ; LD HL,$CE1A       ;
       cb   @hit,@door_frame_ref       ; CP (HL)           ; }
                                       ; POP HL            ; {#HTML(Retrieve #REGhl off the stack and return if the
       jeq  !                          ; RET NZ            ; numbers compared were <em>NOT</em> the same.)}
       .ret                            ;
!      .pop af                         ; POP AF            ; Drop return address
       .ex_de_hl                       ; EX DE,HL          ; {Jumps to the address held in #REGde on entry (with
       b    *hl                        ; JP (HL)           ;
* Copy Routine.
* 
* Used by the routines at #R$5B92, #R$C300, #R$CBD0, #R$CC5A, #R$CC9B, #R$CDAE,
* #R$D5CA and #R$D664.
* 
* This routine copies bytes from #REGde TO #REGhl and uses the #REGbc register to track the number of bytes
* and the number of lines.
copy_routine:                          ; d5e6
       bl   @ti_copy_routine
       .ret                            ; RET               ; Return.

* Draw Doors.
* 
* Used by the routines at #R$CC3A, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
* 
* .
* 
* Preps door frame 1.
draw_door_frame_1:                     ; d664
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_1
       .endproc

* Preps door frame 2.
draw_door_frame_2:                     ; d6d1
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_2
       .endproc
* Preps door frame 3.
draw_door_frame_3:                     ; d6df
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_3
       .endproc
* Preps door frame 4.
draw_door_frame_4:                     ; d6ed
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_4
       .endproc

* Generic Bandit in Door Frame Logic.
*
* Character state variables/ flags.
bandit_state_ref:                      ; d71e
       byte >04                                                      ; The current character state.
bandit_1_timer:                        ; d71f
       byte >08                                                      ; Character timer 1.
bandit_2_timer:                        ; d720
       byte >08                                                      ; Character timer 2.
bandit_3_timer:                        ; d721
       byte >00                                                      ; Character timer 3.
bandit_4_timer:                        ; d722
       byte >55                                                      ; Character timer 4.
       byte >08                                                      ; 
       byte >08                                                      ; 
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_open_routing:                   ; d725
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_open_1              ; JR Z,$D734        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_open_2              ; JR Z,$D741        ; { $01 | #R$D734 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D741 }
       jeq  bandit_open_3              ; JR Z,$D74E        ; { $03 | #R$D74E }
       jmp  bandit_open_4              ; JR $D75B          ; { $04 | #R$D75B }
                                                           ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_open_1:                         ; d734
       movb @bandit_1_timer,a          ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_1_timer          ; LD ($D71F),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6D1 and return.}
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_open_2:                         ; d741
       movb @bandit_2_timer,a          ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_2_timer          ; LD ($D720),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6DF and return.}
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_open_3:                         ; d74e
       movb @bandit_3_timer,a          ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_3_timer          ; LD ($D721),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6ED and return.}
* Handle door frame 4 timer...
bandit_open_4:                         ; d75b
       li   de,init_bandit_close       ; LD DE,$CED8       ; {Calls #R$D5A3 with #REGde=$CED8.
       .call @hit_detection            ; CALL $D5A3        ; }
       movb @bandit_4_timer,a          ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_4_timer          ; LD ($D722),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,a                      ; INC A             ; {Writes $01 to #R$D2FE.
       movb a,@player_died_status      ; LD ($D2FE),A      ; }
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_close_routing:                  ; d771
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_shot_action         ; JR Z,$D783        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_close_4             ; JR Z,$D789        ; { $01 | #R$D783 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D789 }
       jeq  bandit_close_3             ; JR Z,$D798        ; { $03 | #R$D798 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D7A7 }
       jeq  bandit_close_2             ; JR Z,$D7A7        ; { $05 | #R$D7B6 }
       jmp  bandit_close_1             ; JR $D7B6          ; TABLE#}
* Handles the transition to the (#R$6A10(shot | $01)) frame in the open
* doorway.
bandit_shot_action:                    ; d783
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       ab   one,a                      ; INC A             ; Move onto next character frame (i.e. #R$6A10(shot |
                                                           ; $01)).
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle "floor frame in open doorway" countdown.
bandit_close_4:                        ; d789
       movb @bandit_1_timer,a          ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_1_timer          ; LD ($D71F),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)) to
       bl   @draw_door_frame_4        ; CALL $D6ED        ; #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_close_3:                        ; d798
       movb @bandit_2_timer,a          ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_2_timer          ; LD ($D720),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_3        ; CALL $D6DF        ; it to #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_close_2:                        ; d7a7
       movb @bandit_3_timer,a          ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_3_timer          ; LD ($D721),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_2        ; CALL $D6D1        ; it to #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_close_1:                        ; d7b6
       movb @bandit_4_timer,a          ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_4_timer          ; LD ($D722),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine                 ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

* Bowie logic.
* 
* Handles all the logic around drawing Bowie and handling his "special" logic.
* 
* .
* 
* Bowie state variables/ flags.
bowie_good_bad:                        ; d7c5
       byte >01                                                      ; If this is $00 then Bowie is "good". If this is $01
                                                                     ; then he is "bad" (i.e. there's a bomb under his hat).
bowie_frame_ref:                       ; d7c6
       byte >22                                                      ; The current character frame index reference.
bowie_state_ref:                       ; d7c7
       byte >06                                                      ; The current character state.
bowie_1_timer:                         ; d7c8
       byte >00                                                      ; Character timer 1.
bowie_2_timer:                         ; d7c9
       byte >00                                                      ; Character timer 2.
bowie_3_timer:                         ; d7ca
       byte >00                                                      ; Character timer 3.
bowie_4_timer:                         ; d7cb
       byte >00                                                      ; Character timer 4.
bowie_5_timer:                         ; d7cc
       byte >00                                                      ; Character timer 5.
bowie_6_timer:                         ; d7cd
       byte >00                                                      ; Character timer 6.
* This routine looks at the current character state and routes to the correct
* subroutine.
bowie_routing:                         ; d7ce
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {#REGa=#R$D7C7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to jump to based on the current state.
       jeq  bowie_open_1               ; JR Z,$D7E3        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bowie_open_2               ; JR Z,$D7F2        ; { $01 | #R$D7E3 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D7F2 }
       jeq  bowie_open_3               ; JR Z,$D801        ; { $03 | #R$D801 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D810 }
       jeq  bowie_open_4               ; JR Z,$D810        ; { $05 | #R$D82C }
       sb   one,a                      ; DEC A             ; { $06 | #R$D83C }
       jeq  bowie_close_2              ; JR Z,$D82C        ; TABLE#
       jmp  bowie_close_1              ; JR $D83C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
bowie_open_1:                          ; d7e3
                                       ; LD A,($D7C8)      ; {Decrease #R$D7C8 by one, return if result is not
       sb   one,@bowie_1_timer         ; DEC A             ; zero.
                                       ; LD ($D7C8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6D1 and
       bl   @draw_door_frame_2         ; CALL $D6D1        ; return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bowie_open_2:                          ; d7f2
                                       ; LD A,($D7C9)      ; {Decrease #R$D7C9 by one, return if result is not
       sb   one,@bowie_2_timer         ; DEC A             ; zero.
                                       ; LD ($D7C9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6DF and
       bl   @draw_door_frame_3         ; CALL $D6DF        ; return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bowie_open_3:                          ; d801
                                       ; LD A,($D7CA)      ; {Decrease #R$D7CA by one, return if result is not
       sb   one,@bowie_3_timer         ; DEC A             ; zero.
                                       ; LD ($D7CA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character frame index #R$9FB0($1B) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bowie_open_4:                          ; d810
       mov  @4(ix),de                  ; LD E,(IX+$04)     ; {Call #R$D5A3 with a callback to either #R$D84B or
                                       ; LD D,(IX+$05)     ; #R$D85D.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D7CB)      ; {Decrease #R$D7CB by one, return if result is not
       sb   one,@bowie_4_timer         ; DEC A             ; zero.
                                       ; LD ($D7CB),A      ;
       jeq  bowie_close_3              ; RET NZ            ; }
       .ret                            ;
bowie_close_3:                         ; d821
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {Move onto next character state (#R$D7C7).
       ab   one,*hl                    ; INC (HL)          ; }
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_3         ; CALL $D6DF        ; to #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bowie_close_2:                         ; d82c
                                       ; LD A,($D7CC)      ; {Decrease #R$D7CC by one, return if result is not
       sb   one,@bowie_5_timer         ; DEC A             ; zero.
                                       ; LD ($D7CC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_2        ; CALL $D6D1        ; to #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bowie_close_1:                         ; d83c
                                       ; LD A,($D7CD)      ; {Decrease #R$D7CD by one, return if result is not
       sb   one,@bowie_6_timer         ; DEC A             ; zero.
                                       ; LD ($D7CD),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.
* Handles marking this as something shootable.
bowie_cash_action:                     ; d84b
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; {Writes $05 to #REGix+$06 and $01 to #REGix+$07.
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; } Score?
                                       ; LD A,$01          ; {Writes $01 to #REGix+$08 and #R$D190.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb one,@deposit_flag          ; LD ($D190),A      ; }
       jmp  bowie_close_3              ; JR $D821          ; Jump to #R$D821.
* Handles marking this as something unshootable.
bowie_bomb_action:                     ; d85d
       movb @bytes+5,a                 ; LD A,$05          ; {Writes $05 to #R$D2FE and return.
       movb a,@player_died_status      ; LD ($D2FE),A      ;
       .ret                            ; RET               ; }
* Handles both shooting the hats off Bowie's head, and checking/ routing on the
* last frame for the "surprise".
bowie_shot_action:                     ; d863
       li   hl,bowie_frame_ref         ; LD HL,$D7C6       ; {#REGa=#R$D7C6.
       movb *hl,a                      ; LD A,(HL)         ; }
       movb one,@6(ix)
       cb   a,@bytes+33                ; CP $21            ; Is it character frame reference (#R$AC10(1 hat |
                                                           ; $21))?
                                       ; LD (IX+$06),$01   ; Writes $01 to #REGix+$06.
       jhe  bowie_check                ; JR NC,$D875       ; If Bowie is on the last frame then jump forward to
                                                           ; #R$D875.
       ab   one,a                      ; INC A             ; {Else update #R$D7C6 to point at the next frame, call
       movb a,*hl                      ; LD (HL),A         ; #R$D6ED and return.
       bl   @draw_door_frame_4         ; CALL $D6ED        ;
       .ret                            ; RET               ; }
* Checks the "good/ bad" flag and routes the gameplay accordingly.
bowie_check:                           ; d875
       movb @bowie_good_bad,a          ; LD A,($D7C5)      ; {If #R$D7C5 is zero jump to #R$D87D.
       ; AND A                         ; AND A             ; 
       jeq  bowie_state_cash           ; JR Z,$D87D        ; }
       jmp  bowie_state_bomb           ; JR $D88F          ; Jump to #R$D88F.
* Handle displaying cash character frame.
bowie_state_cash:                      ; d87d
       movb @bytes+35,a                ; LD A,$23          ; {Writes character frame reference #R$B030(cash | $23)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; }
       li   hl,bowie_cash_action       ; LD HL,$D84B       ; {Writes #R$D84B to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
       .ret                            ; RET               ; Return.
* Handle displaying bomb character frame.
bowie_state_bomb:                      ; d88f
       movb @bytes+34,a                ; LD A,$22          ; {Writes character frame reference #R$AE20(bomb | $22)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; }
       li   hl,bowie_bomb_action       ; LD HL,$D85D       ; {Writes #R$D85D to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
       .ret                            ; RET               ; Return.

* Routine at D8A1
* 
* Used by the routines at #R$CD68, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
reset_door_routine:                    ; d8a1
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Blanks the 16 bit address pointed to by one of the
                                       ; LD H,(IX+$01)     ; passed door flags (i.e. writes $0000 to one of #R$CE14,
                                       ; XOR A             ; #R$CE16, #R$CE18).
       clr  *hl                        ; LD (HL),A         ;
                                       ; INC HL            ;
                                       ; LD (HL),A         ; }
       .ret                            ; RET               ; Return.

* Routine at DAEF
*
* Used by the routine at #R$CE21.
gen_random_number:                     ; daef
       bl   @random_number             ; CALL $D8B0        ;
;       movb a,@c                       ; LD C,A            ;
;       movb @>5c78,a                   ; LD A,($5C78)      ; Get FRAMES
;       src  a,3                        ; RR C              ;
;                                       ; RR C              ;
;                                       ; RR C              ;
;       ab    @c,a                      ; ADD A,C           ;
       .ret                            ; RET               ;

* Game status buffer entry at D8AC
random_seed:
       data >92ee

* Game status buffer entry at D8AE
random_flag:
       data >e51b

* Routine at D8B0
* 
* Used by the routines at #R$C7C0, #R$CE21, #R$CEB8 and #R$DAEF.
* 
random_number:                         ; d8b0
       .proc
;       bl   @ti_rnd
;       swpb tmp0
;       movb tmp0,a
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGhl for later.
       .push hl                        ; PUSH HL           ; }
                                       ; LD A,($D8AE)      ; {Decrease #R$D8AE by one.
       sb   one,@random_flag           ; DEC A             ;
                                       ; LD ($D8AE),A      ; }
       jne  random_number_1            ; JR NZ,$D8C8       ; If the result is not zero jump to #R$D8C8.
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       jmp  random_number_2            ; JR $D8D7          ;
random_number_1:                       ; d8c8
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       a    bc,hl                      ; ADD HL,BC         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
random_number_2:                       ; d8d7
       a    bc,hl                      ; ADD HL,BC         ;
       dec  hl                         ; DEC HL            ;
       mov  hl,@random_seed            ; LD ($D8AC),HL     ;
       movb @l,a                       ; LD A,L            ;
       li   hl,random_flag+1           ; LD HL,$D8AF       ;
       ab   one,*hl                    ; INC (HL)          ;
       ab   *hl,a                      ; ADD A,(HL)        ;
       .pop hl                         ; POP HL            ;
       .pop bc                         ; POP BC            ;
       .endproc                         ; RET               ; 

* Julius logic.
*
* Handles all the logic around drawing Julius and handling his "special" logic.
julius_good_bad:                       ; d8e5
       byte >00                                                      ; If this is $00 then Julius is "good". If this is $01
                                                                     ; then he is "bad" (i.e. will draw on you).
julius_flag:                           ; d8e6
       byte >00                                                      ; 
julius_state_ref:                      ; d8e7
       byte >04                                                      ; The current character state.
julius_1_timer:                        ; d8e8
       byte >00                                                      ; Character timer 1.
julius_2_timer:                        ; d8e9
       byte >00                                                      ; Character timer 2.
julius_3_timer:                        ; d8ea
       byte >00                                                      ; Character timer 3.
julius_4_timer:                        ; d8eb
       byte >1B                                                      ; Character timer 4.
julius_5_timer:                        ; d8ec
       byte >08                                                      ; Character timer 5.
julius_6_timer:                        ; d8ed
       byte >08                                                      ; Character timer 6.
julius_7_timer:                        ; d8ee
       byte >80                                                      ; Character timer 7.
* This routine looks at the current character state and routes to the correct
* subroutine.
julius_open_routing:                   ; d8ef
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_open_1              ; JR Z,$D907        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_open_2              ; JR Z,$D916        ; { $01 | #R$D907 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D916 }
       jeq  julius_open_3              ; JR Z,$D925        ; { $03 | #R$D925 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D934 }
       jeq  julius_open_4              ; JR Z,$D934        ; { $05 | #R$D963 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D972 }
       jeq  julius_open_5              ; JR Z,$D963        ; { $07 | #R$D981 }
       sb   one,a                      ; DEC A             ; TABLE#
       jeq  julius_open_6              ; JR Z,$D972
       jmp  julius_open_7              ; JR $D981          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
julius_open_1:                         ; d907
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2        ; CALL $D6D1        ; #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
julius_open_2:                         ; d916
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3        ; CALL $D6DF        ; #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
julius_open_3:                         ; d925
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_4        ; CALL $D6ED        ; #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown.
julius_open_4:                         ; d934
       li   de,init_julius_close       ; LD DE,$CFDD       ; {Call #R$D5A3 with a callback to #R$CFDD.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @julius_good_bad,a         ; LD A,($D8E5)      ; {Jump to #R$D951 if #R$D8E5 is zero (Julius is
       ; AND A                         ; AND A             ; "good").
       jeq  julius_state_4_close       ; JR Z,$D951        ; }
* Changes the frame to show Julius drawing his pistol.
       movb @bytes+7,*hl               ; LD (HL),$07       ; Writes "07" to #R$D8E7.
       movb @bytes+37,a                ; LD A,$25          ; {Pass character index (#R$B450(draw | $25)) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Set up (and begin) closing the door.
julius_state_4_close:                  ; d951
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D6DF.}
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_open_5:                         ; d963
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2        ; CALL $D6D1        ; #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_open_6:                         ; d972
                                       ; LD A,($D8ED)      ; {Decrease #R$D8ED by one, return if result is not
       sb   one,@julius_6_timer        ; DEC A             ; zero.
                                       ; LD ($D8ED),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

julius_open_7:                         ; d981
       li   de,julius_callback         ; LD DE,$CFE2       ; {Call #R$D5A3 with a callback to #R$CFE2.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D8EE)      ; {Decrease #R$D8EE by one, return if result is not
       sb   one,@julius_7_timer        ; DEC A             ; zero.
                                       ; LD ($D8EE),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
                                       ; INC A             ; Move onto next character state.
       movb one,@player_died_status    ; LD ($D2FE),A      ; Write $01 to #R$D2FE.
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

* This routine looks at the current character state and routes to the correct
* subroutine.
julius_close_routing:                  ; d997
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_close_1             ; JR Z,$D9A9        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_close_2             ; JR Z,$D9B8        ; { $01 | #R$D9A9 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D9B8 }
       jeq  julius_close_3             ; JR Z,$D9D3        ; { $03 | #R$D9D3 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D9E2 }
       jeq  julius_close_4             ; JR Z,$D9E2        ; { $05 | #R$D9F1 }
       jmp  julius_close_5             ; JR $D9F1          ; TABLE#}
* Handles state countdown/ transition to character frame #R$B660($26).
julius_close_1:                        ; d9a9
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+38,a                ; LD A,$26          ; {Pass character index #R$B660(shot | $26) to #R$D6ED
       bl   @draw_door_frame_4        ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Handles state countdown/ transition to character frame #R$B870($27).
julius_close_2:                        ; d9b8
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6ED.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; }
       movb @julius_flag,a             ; LD A,($D8E6)      ; {Return if #R$D8E6 is zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       ab   one,a                      ; INC A             ; {Else write #R$D8E6+1 to #R$D2FE, call #R$D8A1 and
       movb a,@player_died_status      ; LD ($D2FE),A      ; return.
       .call @reset_door_routine       ; CALL $D8A1        ;
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
julius_close_3:                        ; d9d3
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6DF
       bl   @draw_door_frame_3        ; CALL $D6DF        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_close_4:                        ; d9e2
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6D1
       bl   @draw_door_frame_2        ; CALL $D6D1        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_close_5:                        ; d9f1
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       .ret                            ; RET               ; }

* Drawing Bandit Logic.
*
* Character state variables/ flags.
bandit_draw:                           ; da0c
       byte >00                                                      ; 
bandit_draw_frame_1:                   ; da0d
       byte >08                                                      ; Character frame index 1.
bandit_draw_frame_2:                   ; da0e
       byte >08                                                      ; Character frame index 2.
bandit_draw_frame_3:                   ; da0f
       byte >09                                                      ; Character frame index 3.
bandit_draw_frame_4:                   ; da10
       byte >07                                                      ; Character frame index 4.
bandit_draw_state_ref:                 ; da11
       byte >05                                                      ; The current character state.
bandit_draw_1_timer:                   ; da12
       byte >00                                                      ; Character timer 1.
bandit_draw_2_timer:                   ; da13
       byte >00                                                      ; Character timer 2.
bandit_draw_3_timer:                   ; da14
       byte >00                                                      ; Character timer 3.
bandit_draw_4_timer:                   ; da15
       byte >00                                                      ; Character timer 4.
bandit_draw_5_timer:                   ; da16
       byte >00                                                      ; Character timer 5.

* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_open_routing:              ; da17
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_open_1         ; JR Z,$DA29        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_open_2         ; JR Z,$DA39        ; { $01 | #R$DA29 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DA39 }
       jeq  bandit_draw_open_3         ; JR Z,$DA49        ; { $03 | #R$DA49 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DA59 }
       jeq  bandit_draw_open_4         ; JR Z,$DA59        ; { $05 | #R$DA6F }
       jmp  bandit_draw_open_5         ; JR $DA6F          ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_draw_open_1:                    ; da29
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_draw_open_2:                    ; da39
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_draw_open_3:                    ; da49
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_open_4:                    ; da59
       li   de,set_state_init_bandit_draw_close   ; LD DE,$D037       ; {Call #R$D5A3 with a callback to #R$D037.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_2,a     ; LD A,($DA0E)      ; Grab the character frame index from #R$DA0E.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_open_5:                    ; da6f
       li   de,init_bandit_draw_close  ; LD DE,$D040       ; {Call #R$D5A3 with a callback to #R$D040.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,@player_died_status    ; INC A             ; {Else write $01 to #R$D2FE, call #R$D8A1 and return.
                                       ; LD ($D2FE),A      ;
       .call @reset_door_routine       ; CALL $D8A1        ;
       .ret                            ; RET               ; }

* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_close_routing:             ; da85
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_close_1        ; JR Z,$DA97        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_close_2        ; JR Z,$DAA7        ; { $01 | #R$DA97 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DAA7 }
       jeq  bandit_draw_close_3        ; JR Z,$DAC0        ; { $03 | #R$DAC0 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DAD0 }
       jeq  bandit_draw_close_4        ; JR Z,$DAD0        ; { $05 | #R$DAE0 }
       jmp  bandit_draw_close_5        ; JR $DAE0          ; TABLE#}
* Handles state countdown.
bandit_draw_close_1:                   ; da97
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_3,a     ; LD A,($DA0F)      ; Grab the character frame index from #R$DA0F.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_close_2:                   ; daa7
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; Call #R$D6ED.
       movb @bandit_draw,a             ; LD A,($DA0C)      ; {Return if #R$DA0C is zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       ab   one,@player_died_status    ; INC A             ; {Else write $01 to #R$D2FE and return.
                                       ; LD ($D2FE),A      ;
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_draw_close_3:                   ; dac0
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_draw_close_4:                   ; dad0
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_draw_close_5:                   ; dae0
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine                 ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }

* Door Buffer
* 
* Used by the routines at #R$6600, #R$C300 and #R$F950.
;door_buffer:                           ; ea90
;       bss 704

*
* Used by the routine at #R$CD47.
explode_bomb:
       li   bc,12                      ; LD B,$0C          ;
explode_bomb_1:                        ; f882
       .push bc                        ; PUSH BC           ; 
       .call @explode_bomb_3           ; CALL $F894        ;
       .pop bc                         ; POP BC            ; 
       dec  bc                         ; DJNZ $F882        ;
       jne  explode_bomb_1             ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       movb @bytes+64,b                ; LD B,$40          ; 
explode_bomb_2:                        ; f890
       bl   @ti_vsync                     ; HALT              ;
       sb   one,b                      ; DJNZ $F890        ; 
       jne  explode_bomb_2             ;
       .ret                            ; RET               ;

explode_bomb_3:                        ; f894
       movb @bytes+56,a                ; LD A,$38          ; 
       .call @explode_set_attrs        ; CALL $F8B2        ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       li   bc,4                       ; LD B,$04          ;
explode_bomb_4:                        ; f8a0
       bl   @ti_vsync                     ; HALT              ;
       dec  bc                         ; DJNZ $F8A0        ;
       jne  explode_bomb_4             ;
       movb @bytes+7,a                 ; LD A,$07          ; 
       .call @explode_set_attrs        ; CALL $F8B2        ;
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       li   bc,3                       ; LD B,$03          ;
explode_bomb_5:                        ; f8ae
       bl   @ti_vsync                     ; HALT              ;
       dec  bc                         ; DJNZ $F8AE        ;
       jne  explode_bomb_5             ;
       .ret                            ; RET               ;

explode_set_attrs:                     ; f8b2
       bl   @ti_set_screen_color
       .ret                            ; RET               ;

* This entry point is used by the routine at #R$C7C0.
scroll_dollar_sign:                    ; f960
       seto @graphics_bank_select
       li   de,gfx_dollar_image_2      ; LD DE,$F940       ; {Sends #R$F940 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>0cf8                   ; LD HL,$0CF8       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $0CF8 | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>079e                   ; LD HL,$079E       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $079E | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>029e                   ; LD HL,$029E       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $029E | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0020                   ; LD DE,$0020       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>0209                   ; LD HL,$0209       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $0209 | $0020 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
*      Clear
       li   de,gfx_empty_space          ; LD DE,$5B00       ; {Sends #R$5B00 to #R$F9C3 (blanks the centrepiece).
       .call @dollar_scroll_draw       ; CALL $F9C3        ;  Needs 32 zeros }
       .ret                            ; RET               ; Return.
* Draws the image to the screen.
* de=image to draw
dollar_scroll_draw:                    ; f9c3
       li   tmp0,(1*32+15)*8
       mov  de,tmp1
       li   tmp2,>0202
       bl   @ti_draw_graphics
       movb one,b                      ; LD B,$01          ;
dollar_scroll_halt_loop:               ; f9e3
       bl   @ti_vsync
       bl   @ti_vsync
       sb   one,b                      ; DJNZ $F9E3        ;
       jne  dollar_scroll_halt_loop    ;
       .ret                            ; RET               ; Return.

* High Score Entry.
* 
* Used by the routine at #R$C7C0.
* ix=score_digit_6
draw_and_input_high_scores:            ; fa00
       .call @high_scores              ; CALL $FA06        ;
       b    @high_score_read_char      ; JP $FB62          ; Wait keypress and return
high_scores:                           ; fa06
       movb @bytes+48,a                ; LD A,$30          ; {Writes "0" ($30 in ASCII) to #R$FB94.
       movb a,@high_score_line_buffer  ; LD ($FB94),A      ; }
       .call @hs_clear_screen          ; CALL $FAD4        ; Call #R$FAD4.
       li   hl,zx_screen+>0040         ; LD HL,$4040       ; {Writes $4040 to #R$FBF0.
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ; }
       .push ix                        ; PUSH IX           ; 
       .call @hs_find_position         ; CALL $FC09        ; Call #R$FC09.
       movb a,@high_score_position     ; LD ($FB57),A      ;
       .pop ix                         ; POP IX            ; 
       movb a,tmp0
                                       ; CP $1F            ;
       movb one,a                      ; LD A,$01          ;
       cb   tmp0,@bytes+31             ;                   ; Is position last?
       jne  new_high_score             ; JP Z,$FAB0        ;
       b    @draw_high_scores   ;
new_high_score:
       li   hl,zx_screen               ; LD HL,$4000       ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
*      Move name entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_name_addr       ; CALL $FB19        ;
                                       ; LD DE,$61EF       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_name ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_name-1 ; POP HL            ;
       li   de,high_score_table_last_name+15 ; LD DE,$61FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Move score entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       sb   one,a                      ; DEC A             ; 
       .call @hs_table_score_address   ; CALL $FBFF        ;
                                       ; LD DE,$62F9       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_score ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_score-1 ; POP HL            ;
       li   de,high_score_table_last_score+5 ; LD DE,$62FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Copy new score into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_score_address   ; CALL $FBFF        ;
       dec  hl                         ; DEC HL            ; 
       .ex_de_hl                       ; EX DE,HL          ;
       .push ix                        ; PUSH IX           ;
       .pop hl                         ; POP HL            ;
       movb @bytes+6,b                 ; LD B,$06          ;
new_high_score_1:                      ; fa6f
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*de                      ; LD (DE),A         ; 
       dec  de                         ; DEC DE            ; 
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $FA6F        ; 
       jne  new_high_score_1           ;
*      Fill name buffer with spaces
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Overwrites the text at #R$5BC0 with spaces to "blank"
       li   de,high_score_name_buffer+1 ; LD DE,$5BC1      ; it out ($12 characters).
       li   bc,>0011                   ; LD BC,$0011       ; 
       movb @bytes+32,*hl              ; LD (HL),$20       ; 
       .ldir                           ; LDIR              ; }
       movb @b255,*hl                  ; LD (HL),$FF       ; Set a string termination character ($FF) at the end of
* Print "Write your name please"                           ; the string.
       .call @hs_clear_screen          ; CALL $FAD4        ;
       li   hl,high_score_title        ; LD HL,$FB78       ; {Points to #R$FB78 and sends it to #R$5B80.
       li   de,zx_screen+>0802         ; LD DE,$4802       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
* Input name
       .call @high_score_input_name    ; CALL $FB26        ;
       .call @hs_clear_screen          ; CALL $FAD4        ;
* Copy name into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_name_addr       ; CALL $FB19        ; a--
       .ex_de_hl                       ; EX DE,HL          ; 
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ;
       li   bc,>0010                   ; LD BC,$0010       ; 
       .ldir                           ; LDIR              ;
* Determine from which position to draw
       sb   @bytes+5,a                 ; SUB $05           ; position - 1 - 5
       jgt  draw_high_scores_2         ; JR NC,$FABD       ; If 5 or more higher scores start from position - 5
       jmp  draw_high_scores_1         ; JR $FABC          ; Otherwise start from top
draw_high_scores:                      ; _fab0
       li   hl,high_score_sub_head     ; LD HL,$FBB5       ; {Points to #R$FBB5 and sends it to #R$5B80.
       li   de,zx_screen               ; LD DE,$4000       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
draw_high_scores_1:                    ; fabc
       sb   a,a                        ; XOR A             ; 
draw_high_scores_2:                    ; fabd
       ab   one,a                      ; INC A             ; 
       movb @bytes+10,b                ; LD B,$0A          ; 
draw_high_scores_3:                    ; fac0
       .push bc                        ; PUSH BC           ; 
       .push af                        ; PUSH AF           ; 
       .call @hs_setup_line_buffer     ; CALL $FAE2        ;
       li   de,high_score_line_buffer  ; LD DE,$FB94       ;
       .call @advance_2_rows_and_print  ; CALL $FBD5        ;
       .pop af                         ; POP AF            ; 
       .pop bc                         ; POP BC            ; 
       ab   one,a                      ; INC A             ; 
       cb   a,@bytes+32                ; CP $1F            ;
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   one,b                      ; DJNZ $FAC0        ; 
       jne  draw_high_scores_3         ;
       .ret                            ; RET               ;

hs_clear_screen:                       ; fad4
       bl   @ti_clear_screen
       .ret                            ; RET               ; }

hs_setup_line_buffer:                  ; fae2
       movb a,@c                       ; LD C,A            ; 
       li   hl,high_score_line_buffer  ; LD HL,$FB94       ;
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+49,*hl              ; LD (HL),$31       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+50,*hl              ; LD (HL),$32       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+51,*hl              ; LD (HL),$33       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
hs_setup_line_buffer_1:                ; fafa
       ab   @bytes+10,a                ; ADD A,$0A         ; 
       inc  hl                         ; INC HL            ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       movb @c,a                       ; LD A,C            ; 
       .call @hs_table_name_addr      ; CALL $FB19        ;
       li   de,high_score_line_buffer+6 ; LD DE,$FB9A       ;
       li   bc,>0010                   ; LD BC,$0010       ; 
       .ldir                           ; LDIR              ; 
       ai   de,4                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
       .call @hs_table_score_address   ; CALL $FBFF        ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ;

* Works out where in the high score table to place the score.
hs_table_name_addr:                    ; fb19
       sb   one,a                      ; DEC A             ; {Using #R$6000 as a base, work out where to place the new score.
       movb a,@l                       ; LD L,A            ; #LIST
       sb   h,h                        ; LD H,$00          ; { Decrease $1B by one... }
       sla  hl,4                       ; ADD HL,HL         ; { Loads $1A as the low-order byte; #REGhl=$001A }
                                       ; ADD HL,HL         ; { Times by $10; #REGhl=$1A0 }
                                       ; ADD HL,HL         ; { Add $6000=#R$61A0 }
                                       ; ADD HL,HL         ; LIST#
                                       ; LD DE,$6000       ;
       ai   hl,high_score_table        ; ADD HL,DE         ; }
       .ret                            ; RET               ; Return.

high_score_input_name:                 ; fb26
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Stores #R$5BC0 at #R$FB55.
high_score_input_name_1:               ; fb29
       mov  hl,@high_score_name_buffer_addr ; LD ($FB55),HL     ;
       .call @hs_print_name_buffer          ; CALL $FBF2        ; }
       .call @high_score_read_char     ; CALL $FB62        ;
       mov  @high_score_name_buffer_addr,hl ; LD HL,($FB55)     ;
       cb   a,@bytes+13                ; CP $0D            ; 
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       cb   a,@bytes+8                 ; CP $0C            ;
       jeq  high_score_input_name_3    ; JR Z,$FB58        ;
                                       ; LD C,A            ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer+16 ; CP $D1          ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; LD A,C            ;
       cb   a,@bytes+32                ; CP $20            ; 
       jeq  high_score_input_name_2    ; JR Z,$FB51        ;
       cb   a,@bytes+65                ; CP $61            ;
       jl   high_score_input_name_1    ; JR C,$FB29        ;
       cb   a,@bytes+91                ; CP $7B            ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; SUB $20           ;
high_score_input_name_2:               ; fb51
       movb a,*hl+                     ; LD (HL),A         ;
                                       ; INC HL            ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

high_score_name_buffer_addr:           ; fb55              ;
       data 0
high_score_position:                   ; fb57
       byte 0                          ; RRA               ;

high_score_input_name_3:               ; fb58              ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer  ; CP $C1            ;
       jle  high_score_input_name_1    ; JR C,$FB29        ;
       dec  hl                         ; DEC HL            ;
       movb @bytes+32,*hl              ; LD (HL),$20       ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

* Returns a single keypress.
high_score_read_char:                  ; fb62
       equ  $                          ; LD HL,$5C08       ; {#HTML(Keep looping around until <em>any</em> input is detected. This is achieved by writing $00 to
                                       ; LD (HL),$00       ; <a href="https://skoolkid.github.io/rom/asm/5C08.html">LAST_K</a> and looping until it's non-zero.)
high_score_read_char_loop:             ; fb67
       bl   @ti_vsync                  ; HALT              ;
       bl   @ti_keyscan                ; LD A,(HL)         ;
       movb  a,a                       ; AND A             ;
       jeq  high_score_read_char_loop  ; JR Z,$FB67        ; }
       .ret                            ; RET               ; }

* High Score Table Name Entry.
high_score_title:                      ; fb78
       text '  WRITE YOUR NAME PLEASE   ',>ff
high_score_line_buffer:                ; fb94
       text '10    PANCHO VILLA        241610',>ff
high_score_sub_head:                   ; fbb5
       text '     THESE ARE THE BEST        ',>ff
high_score_name_buffer:
       bss  18

* Routine at FBD5
* 
* Used by the routine at #R$FA00.
advance_2_rows_and_print:              ; fbd5
       mov  @high_score_screen_addr,hl ; LD HL,($FBF0)     ;
       movb @l,a                       ; LD A,L            ; 
       ab   @bytes+64,a                ; ADD A,$40         ;
       jnc  !
       .call @add_8_to_h               ; CALL C,$FBEA      ;
!      movb a,@l                       ; LD L,A            ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
       li   bc,>0705                   ; LD BC,$0705       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       bl    @print_two_tone_text ; CALL $5B80        ; 
       .ret                            ; RET               ; 

add_8_to_h:                            ; fbea
       movb h,a                        ; LD A,H            ; 
       ab   @bytes+8,a                 ; ADD A,$08         ; 
       movb a,h                        ; LD H,A            ; 
       sb   a,a                        ; XOR A             ; 
       .ret                            ; RET               ; 

high_score_screen_addr:                ; fbf0:
       data >50c0                                          ; Cache

* This entry point is used by the routine at #R$FA00.
hs_print_name_buffer:                  ; fbf2
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Points to #R$5BC0 and sends it to #R$5B80.
       li   de,zx_screen+>0887         ; LD DE,$4887       ; #TABLE(default,centre)
       li   bc,>0705                   ; LD BC,$0705       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
       .ret                            ; RET               ; { $05 | $05 | $00 | $00 }
                                                           ; TABLE#}
* This entry point is used by the routine at #R$FA00.
* Calculate hl = >6200 + 6 * a
hs_table_score_address:                ; fbff
       clr  hl
       movb a,h                        ; LD C,A            ; x1
                                       ; XOR A             ;
       sla  hl,1                       ; ADD A,C           ; x2
       ab   a,h                        ; ADD A,C           ; x3
       sla  hl,1                       ; ADD A,C           ; x6
       swpb hl                         ; ADD A,A           ;
                                       ; LD L,A            ;
       ai   hl,high_score_table_scores  ; LD H,$62          ;
       .ret                            ; RET               ; 

* This entry point is used by the routine at #R$FA00.
* ix points to new potential high score BCD low endian
* Returns position in a
hs_find_position:                      ; fc09
       li   hl,high_score_table_scores-6 ; LD HL,$61FA       ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       sb   @e,@e                      ; LD E,$00          ; 
hs_find_next_digit:                    ; fc11
       ab   one,@e                     ; INC E             ; 
       movb @e,a                       ; LD A,E            ; 
       cb   a,@bytes+31                ; CP $1F            ; 
       jhe  hs_find_return             ; RET NC            ;
       a    bc,hl                      ; ADD HL,BC         ;
* hs_cmp_1st_digit:
       movb @5(ix),a                   ; LD A,(IX+$05)     ;
       ab   @bytes+48,a                ; ADD A,$30         ; 
       cb   a,*hl                      ; CP (HL)           ; 
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_2nd_digit           ; JR Z,$FC23        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_2nd_digit:                      ; fc23
       movb @4(ix),a                   ; LD A,(IX+$04)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
       cb   a,@1(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_3rd_digit           ; JR Z,$FC31        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_3rd_digit:                      ; fc31
       movb @3(ix),a                   ; LD A,(IX+$03)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@2(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_4th_digit           ; JR Z,$FC41        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_4th_digit:                      ; fc41
       movb @2(ix),a                   ; LD A,(IX+$02)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@3(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_5th_digit           ; JR Z,$FC53        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_5th_digit:                      ; fc53
       movb @1(ix),a                   ; LD A,(IX+$01)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@4(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jhe  hs_find_return             ; JR NC,$FC65       ;
       jmp  hs_find_next_digit         ; JR $FC11          ;
hs_find_return:                        ; fc65
       movb @e,a                       ; LD A,E            ; 
       .ret                            ; RET               ;

* Title Screen.
* 
* Used by the routine at #R$C7C0.
title_screen:                          ; fe00
       movb one,a                      ; LD A,$01          ;
       bl   @ts_draw_bandits           ; CALL $FEA4        ;
       li   hl,title_screen_game_name  ; LD HL,$FEEA       ; {Points to #R$FEEA and sends it to #R$5B80.
       li   de,zx_screen+>002b         ; LD DE,$402B       ;
       li   bc,>0703                   ; LD BC,$0703       ; 
       bl    @print_two_tone_text ; CALL $5B80        ; }
       li   hl,title_screen_play       ; LD HL,$FEF4       ; {Points to #R$FEF4 and sends it to #R$FEE4.
       li   de,zx_screen+>00cb         ; LD DE,$40CB       ;
       bl   @title_screen_print       ; CALL $FEE4        ; }
       li   hl,title_screen_keys       ; LD HL,$FEFC       ; Points to #R$FEFC and sends it to #R$FEE4.
       li   de,zx_screen+>082b         ; LD DE,$482B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_joystick   ; LD HL,$FF06       ; Points to #R$FF06 and sends it to #R$FEE4.
       li   de,zx_screen+>088b         ; LD DE,$488B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_level      ; LD HL,$FF11       ; Points to #R$FF11 and sends it to #R$FEE4.
       li   de,zx_screen+>08eb         ; LD DE,$48EB       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_author     ; LD HL,$FF19       ; Points to #R$FF19 and sends it to #R$5B80.
       li   de,zx_screen+>1083         ; LD DE,$5083       ;
       li   bc,>0705                   ; LD BC,$0705       ; 
       bl    @print_two_tone_text ; CALL $5B80        ; 
       li   hl,title_screen_copyright  ; LD HL,$FF34       ; {Points to #R$FF34 and sends it to #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ;
       li   bc,>0704                   ; LD BC,$0704       ;
       bl    @print_two_tone_text ; CALL $5B80        ; }

* Act on input.
title_screen_input:                    ; fe58
       movb @controller,a              ; LD A,($5CB0)      ; {If #R$5CB0 is zero (joystick) then #REGde=$0787 else #REGde=$8707. Then call the subroutine at #R$FE95.
       ; AND A                         ; AND A             ; The $07/ $87 correspond to white INK and white INK flashing for the selected control method.
       jeq  ts_select_kempston         ; JR Z,$FE63        ; #TABLE(default,centre,centre,centre,centre,centre)
       li   de,>8707                   ; LD DE,$8707       ; { =h Value | =h Ink | =h Paper | =h Bright | =h Flash }
       jmp  ts_call_flash              ; JR $FE66          ; { $07 | $07 | $00 | $00 | $00 }
ts_select_kempston:                    ; fe63
       li   de,>0787                   ; LD DE,$0787       ; { $87 | $07 | $00 | $00 | $01 }
ts_call_flash:                         ; fe66
       .call @ts_flash_text            ; CALL $FE95        ; TABLE#}
       li   hl,controller              ; LD HL,$5CB0       ; Point #REGhl=#R$5CB0.
       li   tmp0,KEY_1
       bl   @ti_check_key
       jne  ts_set_keyboard
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1, 2, 3, 4, 5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {Jump to #R$FE86 if "1" is pressed.
;       jnc  ts_set_keyboard            ; JR NC,$FE86       ;
       li   tmp0,KEY_2
       bl   @ti_check_key
       jne  ts_set_kempston
;       ; RRA                           ; RRA               ; {Jump to #R$FE8B if "2" is pressed.
;       jnc  ts_set_kempston            ; JR NC,$FE8B       ;
       li   tmp0,KEY_N
       bl   @ti_check_key
       jne  ts_select_level
       li   tmp0,KEY_0
       bl   @ti_check_key
       jeq  !
       .ret                            ;
;!
!      jmp  title_screen_input         ; JR $FE58          ; }
*
ts_set_keyboard:                       ; fe86
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ; 
       jmp  title_screen_input         ; JR $FE58          ; }
ts_set_kempston:                       ; fe8b
       sb   a,a                        ; XOR A             ; {Writes $00 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ; 
       jmp  title_screen_input         ; JR $FE58          ; }
ts_select_level:                       ; fe8f
       b    @level_select              ; JP $6380          ; }
*
ts_flash_text:                         ; fe95
       li   bc,>0020                   ; LD BC,$0020       ; {ggg
       li   hl,zx_attributes+>012b     ; LD HL,$592B       ;
*      Attributes for 1 Keys
       movb d,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
*      Attributes for 2 Kempston
       a    bc,hl                      ; ADD HL,BC         ; 
       a    bc,hl                      ; ADD HL,BC         ;
       movb @e,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ; }
*      Return
       .ret                            ; RET               ; Return.

* Draw bandits.
ts_draw_bandits:                        ; fea4
       .proc
*      Left bandit
       li   tmp0,>00c1
       clr  tmp1
       bl   @ti_draw_character
*      Right bandit
       li   tmp0,>00d9
       clr  tmp1
       bl   @ti_draw_character
*      Left bandit bottom colors
       li   tmp0,(>00c1+(8*32))*8
       li   tmp1,>0020
       li   tmp2,>0603
       bl   @ti_draw_color_area
*      Right bandit bottom colors
       li   tmp0,(>00d9+(8*32))*8
       li   tmp1,>0020
       li   tmp2,>0603
       bl   @ti_draw_color_area
       .endproc

*********************************************************************
*
title_screen_print:                    ; fee4
       .proc
       li   bc,>0702                   ; LD BC,$0702       ; {#REGb=$07, #REGc=$02 and jump to #R$5B80.
       bl   @print_two_tone_text       ; JP $5B80          ; }
       .endproc
*// title_screen_print

* Title Screen/ Game Options
title_screen_game_name:                ; feea
       text 'WEST BANK',>ff
* Playing Options.
title_screen_play:                     ; fef4
       text '0 PLAY ',>ff
title_screen_keys:                     ; fefc
       text '1 KEYS   ',>ff
title_screen_joystick:                 ; ff06
       text '2 JOYSTICK',>ff
title_screen_level:                    ; ff11
       text 'N LEVEL',>ff
* Credits.
title_screen_author:                   ; ff19
       text ' PROGRAM BY ALVARO MATEOS ',>ff
title_screen_copyright:                ; ff34
       text 'COPYRIGHT  DINAMIC SOFTWARE 1985',>ff
       text >00,>00,>ff
