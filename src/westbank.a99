*********************************************************************
*      West bank for the TI-99/4A
*
start:
       limi 0
       lwpi wrksp
       bl   @ti_setup_environment

*      Test
;       bl   @ti_clear_screen
;       bl   @perform_duel_main
;       li   hl,test_frames
;test_loop:
;       li   tmp0,4*32+13
;       mov  *hl+,tmp1
;       jlt  after_test
;       bl   @ti_draw_character
;       li   tmp0,32
;       bl   @ti_delay
;       jmp  test_loop
;test_frames:
;       data >00,>01,>02
;       data >03,>06,>07
;       data >03,>04,>05,>00,>01,>02
;       data >0a,>0d,>0e
;       data >0a,>0b,>0c,>00,>01,>02
;       data >08,>09,>29
;       data >10,>0f,>11,>2a
;       data >12,>13,>14,>2b
;       data >15,>16,>17,>2c
;       data >18,>19,>1a,>28
;       data >1b,>1c,>1d,>1e,>1f,>20,>21,>22
;       data >1b,>1c,>1d,>1e,>1f,>20,>21,>23
;       data >24,>25,>26,>27
;       data -1
after_test:
;       bl   @ti_clear_screen

       mov  @>83c0,hl                  ; LD HL,($5C78)     ; #HTML(Fetch <a
                                                           ; href="https://skoolkid.github.io/rom/asm/5C78.html">FRAMES</a>
                                                           ; as a random number seed.)
       mov  hl,@random_seed            ; LD ($D8AC),HL     ; Write it to #R$D8AC.
       bl   @ti_show_loading_screen
       movb @bytes+120,b
       bl   @halt_loop
main_loop:
       bl   @ti_clear_screen
       bl   @title_screen              ; CALL $FE00        ; #REGhl=#R$CBB4.}
       bl   @mute_sound
       bl   @play_game                  ; CALL $C7E5        ; Call #R$C7E5.
       bl   @mute_sound
       bl   @ti_clear_screen
       movb @bytes+64,b                ; LD B,$80          ; {Calls #R$CD64 with the counter
       bl   @halt_loop                 ; CALL $CD64        ; $80.}
       bl   @draw_and_input_high_scores ; JP $FA00          ; #REGix=#R$CD86.}
       jmp  main_loop

*********************************************************************
* New game
* Displays the title screen and on return, sets the control method and
* initiates variables for a new game.
play_game:                              ; c7e5
       .proc
* Setup input control routine
       movb @controller,a              ; LD A,($5CB0)      ; {Grab the value stored at #R$5CB0
       li   hl,controls_keyboard       ; LD HL,$D39B       ; and if it is $01 then jump ahead
       sb   one,a                      ; DEC A             ; to #R$C7F9 which writes #R$D39B
       jeq  set_control_alias          ; JR Z,$C7F9        ; to #R$CE12.}
       li   hl,controls_joystick       ; LD HL,$D392       ; {Write #R$D392 to #R$CE12.
set_control_alias:                     ; c7f9
       mov  hl,@control_routine_alias  ; LD ($CE12),HL     ; }
* Resets all game variables/ states ready for a new game.
       li   hl,score_digit_6           ; LD HL,$CD86       ; {Clears the score (writes $00
       li   de,score_digit_5           ; LD DE,$CD87       ; over seven bytes from #R$CD86).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       li   bc,>0006                   ; LD BC,$0006       ;
       .ldir                           ; LDIR              ; }
                                       ; LD A,$03          ; {Initialise #R$CC59 to $03.
       movb @bytes+3,@lives            ; LD ($CC59),A      ; } Starting_lives
       li   hl,>0101                   ; LD HL,$0101       ; {Initialise #R$D45C to $0101.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CE14, #R$CE16 and
       mov  hl,@door_1_routine         ; LD ($CE14),HL     ; #R$CE18 (sets them to $0000).
       mov  hl,@door_2_routine         ; LD ($CE16),HL     ;
       mov  hl,@door_3_routine         ; LD ($CE18),HL     ; }
       li   hl,>2020                   ; LD HL,$2020       ; {Clear #R$CA58 and #R$CA5A to
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; $2020 (ASCII space-space).
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Set the border to black.
       bl   @ti_set_border_color          ; OUT ($FE),A       ; }
                                       ; INC A             ; {Write $01 to #R$CBCF.
       movb one,@duel_parameter        ; LD ($CBCF),A      ; }
       bl   @init_progress            ; CALL $CA6C        ;
       bl   @set_day_attr             ; CALL $C959        ;
       bl   @cls_inc_display_day          ; CALL $CA64         ;
                                       ; LD A,$03          ; {Writes $03 to #R$CE1B.
       movb @bytes+3,@chooser_countdown_init ; LD ($CE1B),A      ; }
       li   hl,>0400                   ; LD HL,$0500       ; {Writes $0500 to #R$CE1C.
       mov  hl,@delay                  ; LD ($CE1C),HL     ; }
                                       ; LD A,$01          ; {Writes $01 to #R$D191.
       movb one,@sheriff_star_flag     ; LD ($D191),A      ; }
**
*      Execute levels
       movb @level,a                   ; LD A,($5CB1)      ; {Grabs the #R$5CB1, if it's phase
       li   hl,phase                   ; LD HL,$CA4A       ; 1 then jump to #R$C878 with
       sb   one,a                      ; DEC A             ; #REGhl=#R$CA4A.
       jeq  level_1                    ; JR Z,$C878        ; }
*      Level 2 or 3
       bl   @reduce_delay              ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl   @reduce_delay              ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       sb   one,a                      ; DEC A             ;
       jeq  level_2                    ; JR Z,$C88F        ;
*      Level 3
       bl   @reduce_delay              ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl   @reduce_delay              ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       bl   @reduce_delay              ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       jmp  level_3                    ; JR $C8B6          ;
level_1:                               ; c878
*      Day 1
*      Phase 1
       li   hl,choose_default_set      ; LD HL,$CE42       ; {Writes #R$CE42 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 2
       li   hl,choose_bandit_3         ; LD HL,$CE6F       ; {Writes #R$CE6F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
level_2:
*      Phase 3
       li   hl,choose_bandit_2         ; LD HL,$CE5F       ; {Writes #R$CE5F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 4
       li   hl,choose_julius           ; LD HL,$CE55       ; {Writes #R$CE55 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 5
       li   hl,choose_bandit_4         ; LD HL,$CE7E       ; {Writes #R$CE7E to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
level_3:
*      Phase 6
       li   hl,choose_bandit_5         ; LD HL,$CE8D       ; {Writes #R$CE8D to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 7
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 8
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @set_dusk_attr             ; CALL $C95E        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
*      Phase 9
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       bl   @reduce_delay              ; CALL $C941        ;
       bl   @set_night_attr            ; CALL $C963        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return            ; RET C             ;
level_3_1:                             ; c8f0
*      Day 2
*      Phase 10-16
       bl   @set_day_attr              ; CALL $C959        ;
       bl   @cls_inc_display_day       ; CALL $CA64        ;
       movb @bytes+7,b                 ; LD B,$07          ;
level_3_2:                             ; c8f8
       .push bc                        ; PUSH BC           ;
       bl    @run_phase                ; CALL $CA81        ;
       .pop bc                         ; POP BC            ;
       joc  play_game_return           ; RET C             ;
       .push bc                        ; PUSH BC           ;
       bl    @reduce_delay             ; CALL $C941        ;
       .pop bc                         ; POP BC            ;
       sb   one,b                      ; DJNZ $C8F8        ;
       jne  level_3_2                  ;                   ; Do 7 times
*      Phase 17
       bl   @set_dusk_attr             ; CALL $C95E        ;
       bl   @run_phase                 ; CALL $CA81        ;
       joc  play_game_return           ; RET C             ;
*      Phase 18
       bl   @set_night_attr            ; CALL $C963        ;
       bl    @run_phase                ; CALL $CA81        ;
       joc  play_game_return           ; RET C             ;
*      Sheriff
       li   hl,sheriff_star_flag       ; LD HL,$D191       ;
       movb *hl,tmp0                   ; LD A,(HL)         ;
       sb   *hl,*hl                    ; LD (HL),$00       ; You only get a sheriff star once
       movb tmp0,tmp0                  ; AND A             ;
       jeq  level_3_1                  ; JR Z,$C8F0        ;
       bl   @sheriff_star              ; CALL $C720        ; Call #R$C720.
       bl   @halt_loop                 ; CALL $CD64        ;
       bl   @halt_loop                 ; CALL $CD64        ;
       bl   @halt_loop                 ; CALL $CD64        ;
level_3_3:                             ; c936
       li   tmp0,KEY_SP
       bl   @ti_check_key
       jeq  level_3_3
       jmp  level_3_1                  ; JR $C8F0          ;
play_game_return:
       .endproc

*********************************************************************
* Reduce delay by 64
reduce_delay:                          ; c941
                                       ; PUSH AF           ;
       .push hl                        ; PUSH HL           ;
       mov  @delay,hl                  ; LD HL,($CE1C)     ;
       li   bc,>0040                   ; LD BC,$0040       ;
       ; AND A                         ; AND A             ;
       s    bc,hl                      ; SBC HL,BC         ;
                                       ; LD A,H            ;
                                       ; OR L              ;
       jgt  reduce_delay_1             ; JR NZ,$C953       ;
       li   hl,>0001                   ; LD HL,$0040       ;
reduce_delay_1:                        ; c953
       mov  hl,@delay                  ; LD ($CE1C),HL     ;
       .pop hl                         ; POP HL            ;
                                       ; POP AF            ;
       rt                              ; RET               ;

*********************************************************************
* Sets the door attributes for the "time of day".
set_day_attr:                          ; c959
       li   hl,door_attr_day           ; LD HL,$C96F       ; {Call #R$C966 using #R$C96F.
       jmp  set_door_attr              ; JR $C966          ; }
set_dusk_attr:                         ; c95e
       li   hl,door_attr_dusk          ; LD HL,$C987       ; {Call #R$C966 using #R$C987.
       jmp  set_door_attr              ; JR $C966          ; }
set_night_attr:                        ; c963
       li   hl,door_attr_night         ; LD HL,$C99F       ; Call #R$C966 using #R$C99F.
* Note this is for the opened door background hence it starts from frame 2 (as
* frame 1 is a closed door).
set_door_attr:                         ; c966
       movb *hl,@character_attr+1
       rt                              ; RET               ; }

* Door frame attribute data for each day phase.
door_attr_day:                         ; c96f
       byte >28
door_attr_dusk:                        ; c987
       byte >0D                        ; cyan on blue
door_attr_night:                       ; c99f
       byte >05                        ; cyan on black

*********************************************************************
* Clears the cashbox flags, clears the screen and displays the phase number.
init_game_loop:                        ; c9b7
       .proc
       li   hl,>0101                   ; LD HL,$0101       ; {Writes $0101 to #R$D45C.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Call #R$C9D0 (using $00).
       bl   @clear_screen              ; CALL $C9D0        ; }
       bl   @inc_display_phase         ; JR $C9DD          ; Jump to #R$C9DD.
       .endproc

*********************************************************************
* This routine has the ability to write any value across the screen buffer, however it's only ever called with
* #REGa=$00 (clear screen).
clear_screen:                          ; c9d0
       .proc
       bl   @ti_clear_screen
       .endproc                        ; RET               ; }

*********************************************************************
* Displays the current "phase".
inc_display_phase:                     ; c9dd
       .proc
       li   hl,phase_text              ; LD HL,$CA4E       ; {Copies #R$CA4E into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ;
       .ldir                           ; LDIR              ; }
       mov  @phase_ascii,hl            ; LD HL,($CA5A)     ; {Writes #R$CA5A to #R$CA5C (at
       movb h,*de+                     ; LD ($CA61),HL     ; $CA61 - just overwriting the
       movb @l,*de                                         ; numeric part).}
       li   hl,phase                   ; LD HL,$CA4A       ; {Call #R$CA19 with #R$CA4A.
       bl   @inc_and_print_number      ; CALL $CA19        ; }
       movb @progress_buffer+5,h       ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA5A.
       movb @progress_buffer+6,@l
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
* Displays the current "day".
inc_display_day:                       ; c9fb
       .proc
       li   hl,day_text                ; LD HL,$CA53       ; {Copies #R$CA53 into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ;
       .ldir                           ; LDIR              ; }
       mov  @day_ascii,hl              ; LD HL,($CA58)     ; {Writes #R$CA58 to #R$CA5C (at
       movb h,*de+                     ; LD ($CA61),HL    ; $CA61 - just overwriting the
       movb @l,*de                                         ; numeric part).}
       li   hl,day                     ; LD HL,$CA4C       ; {Call #R$CA19 with #R$CA4C.
       bl   @inc_and_print_number      ; CALL $CA19        ; }
       movb @progress_buffer+5,h       ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA58.
       movb @progress_buffer+6,@l
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
* This routine is for converting progress numbers into ASCII. On entry #REGhl
* will be either #R$CA4A or #R$CA4C.
inc_and_print_number:                  ; ca19
       .proc
       movb *hl,a                      ; LD A,(HL)         ; {If the passed number is not more
       ab   one,a                      ; INC A             ; than 10 jump to #R$CA27.
       cb   a,@bytes+10                ; CP $0A            ;
       jhe  progress_divisible_10      ; JR NC,$CA27       ; }
       movb a,*hl                      ; LD (HL),A         ; {Stores the ASCII representation of the number at $CA62 (for #R$CA5C). It adds ASCII "0" so for example 1
       ab   @bytes+48,a                ; ADD A,$30         ; ends up being 1 + $30 = $31 (e.g. "1" in ASCII).
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; }
       jmp  print_progress             ; JR $CA38          ; Jump to #R$CA38.
* Ensures the progress digit remains 0-9. On entry #REGhl will be either
* #R$CA4A or #R$CA4C.
progress_divisible_10:                 ; ca27
       sb   *hl,*hl                    ; LD (HL),$00       ; Reset the current progress digit
                                                           ; to $00.
       inc  hl                         ; INC HL            ; Use the secondary digit of the
                                                           ; currently focused progress.
* Note this doesn't account for a third digit and so leads to eventual corruption. Once past day/ phase "99", this
* will display "00" and past "09" the first ASCII digit doesn't point to any usable image data. Note however, this
* occurs after ~4 hours of game play so isn't especially an issue.
       ab   one,*hl                    ; INC (HL)          ; Increase this second digit by
                                                           ; one.
       movb *hl,a                      ; LD A,(HL)         ; {Add ASCII "0" so for example 1 ends up being 1 + $30 = $31 (e.g. "1" in ASCII). Write this number to $CA61
       ab   @bytes+48,a                ; ADD A,$30         ; (for #R$CA5C).
       movb a,@progress_buffer+5       ; LD ($CA61),A      ; }
       dec  hl                         ; DEC HL            ; Move back to point to the
                                                           ; original location of #REGhl.
       movb *hl,a                      ; LD A,(HL)         ; {Again, add ASCII "0" for this
       ab   @bytes+48,a                ; ADD A,$30         ; digit too. Write this number to
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; $CA62 (for #R$CA5C).}
* Prints the current progress buffer message to the screen.
print_progress:                        ; ca38
       li   hl,progress_buffer         ; LD HL,$CA5C       ; {Prints #R$CA5C to the screen buffer at $486C using #R$CBD2.
       li   de,zx_screen+>086c         ; LD DE,$486C       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $CBD2        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       movb @bytes+80,b                ; LD B,$50          ; {Interrupt driven HALT loop ($50
progress_halt_loop:                    ; ca46
       bl   @ti_vsync                  ; HALT              ; cycles).
       sb   one,b                      ; DJNZ $CA46        ; }
       jne  progress_halt_loop         ;
       .endproc                        ; RET               ; Return.

*********************************************************************
* Clears the screen and displays the day number.
cls_inc_display_day:                   ; ca64
       .proc
       sb   a,a                        ; XOR A             ; {Clears the screen by passing $00
       bl   @clear_screen              ; CALL $C9D0        ; to #R$C9D0.}
       bl   @inc_display_day           ; CALL $C9FB        ; Call #R$C9FB.
       .endproc                        ; RET               ; Return.

*********************************************************************
* Clear down the day/ progress states.
init_progress:                         ; ca6c
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CA4A and #R$CA4C
       mov  hl,@phase                  ; LD ($CA4A),HL     ; (writes $0000 to them).
       mov  hl,@day                    ; LD ($CA4C),HL     ; }
       movb @bytes+32,a                ; LD A,$20          ; {Writes ASCII space ($20) to $CA61 and ASCII "0" ($30) to $CA62 (i.e. writes " 0" to the numeric portion of
       li   hl,progress_buffer+5       ; LD HL,$CA61       ; #R$CA5C).
       movb a,*hl                      ; LD (HL),A         ;
       inc  hl                         ; INC HL            ;
       movb @bytes+48,a                ; LD A,$30          ;
       movb a,*hl                      ; LD (HL),A         ; }
       rt                              ; RET               ; Return.

*********************************************************************
run_phase:                             ; ca81
       .proc
       bl   @init_and_run_game_loop    ; CALL $CAC8        ;
       jnc  phase_completed            ; RET C             ;
       b    @return_with_carry         ;
phase_completed:
       bl   @mute_sound
*      Flash cashboxes
       movb @bytes+16,b                ; LD B,$10          ;
cashboxes_flash_loop:                  ; ca87
       bl   @play_deposit
       .push bc                        ; PUSH BC           ;
       movb b,a                        ; LD A,B            ;
       andi a,1*256                    ; AND $01           ;
       bl   @set_all_deposit_flags     ; CALL $CAB9        ;
       movb @bytes+16,b                ; LD B,$10          ;
       bl   @halt_loop                 ; CALL $CD64        ;
       .pop bc                         ; POP BC            ;
       sb   one,b                      ; DJNZ $CA87        ;
       jne  cashboxes_flash_loop       ;
       movb @bytes+48,b                ; LD B,$30          ;
       bl   @halt_loop                 ; CALL $CD64        ;
       movb b,a                        ; LD A,B            ;
       bl   @set_all_deposit_flags     ; CALL $CAB9        ;
* Duel
       bl   @mute_sound
       bl   @random_number             ; CALL $D8B0        ;
       movb a,b                        ; LD B,A            ;
       ; LD A,R                        ; LD A,R            ;
       movb a,@c                       ; LD C,A            ; bc random
       ab   b,a                        ; ADD A,B           ;
       movb a,d                        ; LD D,A            ; d random
       movb @duel_parameter,a          ; LD A,($CBCF)      ;
       bl   @perform_duel              ; CALL $C3C0        ;
       stst tmp2
       movb a,@duel_parameter          ; LD ($CBCF),A      ; a=@duel_counter
       sb   b,b                        ; LD B,$00          ;
       bl   @halt_loop                 ; JP $CD64          ;
       andi tmp2,>1000                 ; Check carry
       jne  !
       b    @return_without_carry
!      b    @return_with_carry

*********************************************************************
* Set all deposit flags to a
set_all_deposit_flags:                 ; cab9
       .proc
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Writes #REGa across all the
       li   de,door_deposited_02       ; LD DE,$CC8E       ; deposit flags (copies to each
       li   bc,>000d                   ; LD BC,$000D       ; from #R$CC8D).
       movb a,*hl                      ; LD (HL),A         ;
       .ldir                           ; LDIR              ; }
       bl   @draw_and_check_cashboxes ; JP $CC9B          ; Jump to #R$CC9B.
       .endproc

*********************************************************************
*
init_and_run_game_loop:                ; cac8
       .proc
       bl   @init_game_loop            ; CALL $C9B7        ;
* This entry point is used by the routines at #R$CD1B and #R$CD47.
next_life:
                                       ; XOR A             ; {Writes $00 to #R$D2FE.
       movb @zero,@player_died_status  ; LD ($D2FE),A      ; }
       bl   @reset_door_routine_flags  ; CALL $CD68        ;
       bl   @draw_doors_and_playfield  ; CALL $CC3A        ;
       bl   @draw_life_images          ; CALL $CC5A        ;
       bl   @draw_and_check_cashboxes  ; CALL $CC9B        ;
       bl   @draw_score                ; CALL $CD90        ;
       bl   @draw_cashbox_selections   ; CALL $D45E        ;
start_music:
       mov  @phase,tmp0
       andi tmp0,>0100
       jeq  !
       li   tmp0,chrys_module
       jmp  !!
!:
       li   tmp0,bnwrag_module
!:
       bl   @play_module
**
*      Game loop
*
game_loop:                             ; cae7
       inc  @frame
       bl   @module_player
       li   tmp0,KEY_Z
       bl   @ti_check_key
       jeq  read_keys_3                ; JR NZ,$CB0B       ;
read_keys_2:                           ; cb03              ; Z pressed. Enter pause mode until X pressed.
       bl   @mute_sound
read_keys_2a:
       li   tmp0,KEY_X
       bl   @ti_check_key
       jeq  read_keys_2a               ; JR NZ,$CB03       ;
       jmp  start_music
read_keys_3:                           ; cb0b
       bl   @check_input               ; CALL $D2CF        ;
       bl   @module_player
       mov  @delay,bc                  ; LD BC,($CE1C)     ;
delay_loop_1:                          ; cb12
       dect bc                         ; DEC BC            ;
                                       ; LD A,B            ;
                                       ; OR C              ;
       jgt  delay_loop_1               ; JR NZ,$CB12       ;
       bl   @module_player
       mov  @delay,bc                  ; LD BC,($CE1C)     ;
delay_loop_2:                          ; cb12
       dect bc                         ; DEC BC            ;
                                       ; LD A,B            ;
                                       ; OR C              ;
       jgt  delay_loop_2               ; JR NZ,$CB12       ;
       bl   @module_player
       bl   @move_right_or_left        ; CALL $D411        ;
* Door 1 handling
       li   ix,door_1_flags            ; LD IX,$D165       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_1_routine,hl         ; LD HL,$CE14       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ;
       bl   @character_chooser        ;                   ; If no door_1_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_1_routine       ; JR Z,$CB3F        ;
                                       ; LD HL,($CE14)     ;
!      li   de,after_door_1_routine    ; LD DE,$CB3F       ;
       .push de                        ; PUSH DE           ; Set return address
       movb one,@door_frame_ref        ; LD A,$01          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 1 routine
after_door_1_routine:                  ; cb3f
       bl   @module_player
* Door 2 handling
       li   ix,door_2_flags            ; LD IX,$D173       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_2_routine,hl         ; LD HL,$CE16       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ;
       bl   @character_chooser                            ; If no door_2_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_2_routine       ; JR Z,$CB61        ;
                                       ; LD HL,($CE16)     ;
!      li   de,after_door_2_routine    ; LD DE,$CB61       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+2,@door_frame_ref   ; LD A,$02          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 2 routine
after_door_2_routine:                  ; _cb61
       bl   @module_player
* Door 3 handling
       li   ix,door_3_flags            ; LD IX,$D181       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_3_routine,hl         ; LD HL,$CE18       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ;
       bl   @character_chooser                            ; If no door_3_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_3_routine       ; JR Z,$CB83        ;
                                       ; LD HL,($CE18)     ;
!      li   de,after_door_3_routine    ; LD DE,$CB83       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+3,@door_frame_ref   ; LD A,$03          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 3 routine
after_door_3_routine:                  ; cb83
       bl   @module_player
* Check status
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 0 of #R$D2FE is not zero
       jeq  game_loop_2
       movb a,tmp0                     ; BIT 0,A           ; then jump to #R$CD47.
       andi tmp0,1*256                 ;
       jeq  game_loop_1                ; JP NZ,$CD47       ; }
       b    @died                      ;
game_loop_1:
       movb a,tmp0                     ; BIT 1,A           ; {Else if bit 1 is not zero, jump
       andi tmp0,2*256                 ;
       jeq  game_loop_2                ; JP NZ,$CD1B       ; to #R$CD1B.}
       b    @flash_lives               ;
game_loop_2:
       bl   @scoring                  ; CALL $CDC3        ; Call #R$CDC3.
       li   hl,deposit_flag            ; LD HL,$D190       ; {If #R$D190 is not zero then call
       movb *hl,a                      ; LD A,(HL)         ; #R$CBA0 (also, writes $00 to
       ; AND A                         ; AND A             ; #R$D190 to clear it).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  !                          ; CALL NZ,$CBA0     ; }
       bl   @got_a_deposit                    ;
!
       bl   @ti_check_quit
       b    @game_loop                 ; JP $CAE7          ;

*********************************************************************
got_a_deposit:                         ; cba0
       .proc
       bl    @scroll_dollar_sign       ; CALL $F960        ;
       bl    @draw_and_check_cashboxes ; JP $CC9B          ;
       .endproc

*********************************************************************
* Sounds.
* 
* Shot sound 1.
shot_sound_1:                          ; 6537
       .proc
       bl   @play_shot_1               ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 2.
shot_sound_2:                          ; 653f
       .proc
       bl   @play_shot_2               ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 3.
shot_sound_3:                          ; 6547
       .proc
       bl   @play_shot_3               ; CALL $654F        ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* BANG!
* 
* Used by the routines at #R$C687 and #R$CD47.
bang:                                  ; c000
       .proc
       bl   @ti_clear_screen           ; CALL $C046        ; Clear the screen.
       li   tmp1,>0002
       bl   @bang_color
       movb @bytes+6,b                 ; LD B,$03          ; {Pass #R$F000 to #R$C061.
       li   hl,gfx_bang_frame_1        ; LD HL,$F000       ;
       bl   @bang_copy                 ; CALL $C061        ; }
       movb @bytes+6,b                 ; LD B,$03          ; {Pass #R$F100 to #R$C061.
       li   hl,gfx_bang_frame_2        ; LD HL,$F100       ;
       bl   @bang_copy                 ; CALL $C061        ; }
       movb @bytes+6,b                 ; LD B,$03          ; {Pass #R$F200 to #R$C061.
       li   hl,gfx_bang_frame_3        ; LD HL,$F200       ;
       bl   @bang_copy                 ; CALL $C061        ; }
       bl   @shot_sound_2              ; CALL $6502        ; {Calls $6502 twice.
;       bl   @shot_sound_2              ; CALL $6502        ; }
       movb @bytes+12,b                ; LD B,$06          ; {Pass #R$F300 to #R$C061.
       li   hl,gfx_bang_frame_4        ; LD HL,$F300       ;
       bl   @bang_copy                 ; CALL $C061        ; }
       movb @bytes+10,b                ; LD B,$05          ; {Pass #R$F400 to #R$C061.
       li   hl,gfx_bang_frame_5        ; LD HL,$F400       ;
       bl   @bang_copy                 ; CALL $C061        ; }
       movb @bytes+10,b                ; LD B,$05          ; {Pass #R$F500 to #R$C061.
       li   hl,gfx_bang_frame_6        ; LD HL,$F500       ;
       bl   @bang_copy                 ; CALL $C061        ; }
                                       ; LD B,$08          ; {Blanks the display by passing a
       li   tmp1,>0000                 ; LD HL,$5000       ; "clear" part of the screen buffer
       bl   @bang_color                ; CALL $C061        ; to #R$C061.}
       movb @bytes+128,b               ; LD B,$40          ; {Jump to #R$C06D.
       bl   @halt_loop                 ; JP $C06D          ; }
       .endproc

*********************************************************************
bang_copy:                             ; c061
       .proc
       seto @graphics_bank_select      ; PUSH BC           ; {Sets the screen location and the
       li   tmp2,>0804                 ; LD BC,$2008       ; bang image frame sizing, then
       li   tmp0,>0860                 ; LD DE,$480C       ; calls #R$C071, issues a short
       mov  hl,tmp1                    ; EX DE,HL          ; pause and ...
       bl   @ti_draw_graphics          ; CALL $C071        ;
       bl   @halt_loop                  ; POP BC           ;
       .endproc
*// bank_copy

*********************************************************************
bang_color:
       .proc
       li   tmp0,>0860
       li   tmp2,>0804
       bl   @ti_draw_color_area
       .endproc
*// bang_color

*********************************************************************
* Routine at C3C0
* 
* Used by the routine at #R$C7C0.
perform_duel:
       .proc
       movb a,@duel_counter           ; I think this was the intention - otherwise duel_counter is never updated
       bl   @perform_duel_main        ; CALL $C3DD        ; Call #R$C3DD.
                                       ; LD A,($C421)      ; Grab #R$C421.
       jnc  after_duel_1               ; JR NC,$C3C9       ;
       ab   one,@duel_counter          ; INC A             ;
after_duel_1:                          ; c3c9
       movb @duel_counter,a
       movb @bytes+32,b                ; LD B,$20          ; {Interrupt driven HALT loop ($20 cycles).
after_duel_loop:                       ; c3cb
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C3CB        ; }
       jne  after_duel_loop            ;
;      movb a,@e                       ; LD E,A            ;
       li   hl,lives                   ; LD HL,($5B86)     ; {Is #R$CC59 more than $06?
       movb *hl,tmp0                   ; LD A,(HL)         ; Get lives
;       cb   tmp0,@bytes+6              ; CP $06            ; }
;       jl   after_duel_2               ; JR C,$C3D8        ; If so, jump to #R$C3D8.
;       nop                             ; NOP               ; We have 6 lives or more ?
;after_duel_2:
;       ; AND A                         ; AND A             ; {If #R$CC59 @duel_counter is zero then return without carry.
;       movb @e,a                       ; LD A,E            ;
       jeq  !                          ; RET NZ            ; }
       b    @return_without_carry                            ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }
*// perform_duel

*********************************************************************
* Kicks off the duelling bonus round.
perform_duel_main:                     ; c3dd
       .proc
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGde.
       .push de                        ; PUSH DE           ; }
       li   hl,duel_data               ; LD HL,$C3EA       ; {Copies $33 bytes of data from #R$C3EA to #R$5BC0 (and
       li   de,dueller_1               ; LD DE,$5BC0       ; across all three duellists).
       li   bc,>0036                   ; LD BC,$0033       ; RM added 3 bytes
       .ldir                           ; LDIR              ; }
       .pop de                         ; POP DE            ;
       .pop bc                         ; POP BC            ;
       movb b,a                        ; LD A,B            ; random number from caller
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C67F with #R$5BC0.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       movb @c,a                       ; LD A,C            ; random number from caller
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C67F with #R$5BD1.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       movb d,a                        ; LD A,D            ; random number from caller
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C67F with #R$5BE2.
       bl   @duel_update_timer        ; CALL $C67F        ; }
       sb   a,a                        ; XOR A             ; {Reset the flags (writes $00 to #R$C6E2, #R$C6E3 and
       li   hl,duel_bang_flag          ; LD HL,$C6E2       ; #R$C6E4).
       movb a,*hl+                     ; LD (HL),A         ; clear duel_bang_flag
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear duel_lose_life
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear duel_extra_life
       movb @duel_counter,a            ; LD A,($C421)      ; #R$C421.
       socb one,a                      ; OR $01            ; min 1
       li   de,>0001                   ; CP $20            ;
       cb   a,@bytes+10                ; LD DE,$0001       ;
       jhe  duel_clear_screen          ; JR NC,$C463       ;
       movb a,b                        ; LD B,A            ; 
       li   de,10                      ; LD DE,$0020       ;
duel_prep_loop:                        ; c460              ; de = >20 - @duel_counter
       dec  de                         ; DEC DE            ; 
       sb   one,b                      ; DJNZ $C460        ; 
       jne  duel_prep_loop             ;                   
duel_clear_screen:                     ; c463
       mov  de,@duel_inner_iterations  ; LD ($C52E),DE     ; ....
* Clears down the screen buffer.
       bl   @ti_clear_screen
* Writes the attributes for the playfield (sky, grass, footer).
       li   tmp0,>0400
       li   tmp1,>0028
       li   tmp2,>200c
       bl   @ti_draw_color_area
       li   tmp0,>1000
       li   tmp1,>0020
       li   tmp2,>2004
       bl   @ti_draw_color_area
       li   tmp0,>1400
       li   tmp1,>0007
       li   tmp2,>2004
       bl   @ti_draw_color_area
* Creates the footer.
       li   hl,playfield_lives         ; LD HL,$C655       ; {Point to #R$C655 and print using #R$C6A7.
       bl   @duel_print_lives          ; CALL $C6A7        ; }
       bl   @draw_life_images          ; CALL $5B83        ;
       li   hl,playfield_score         ; LD HL,$C64D       ; {Point to #R$C64D and prints using #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       bl   @draw_score               ; CALL $5B98        ; Writes the players score.
* Initialise duellers.
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Initialise #R$5BC0 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Initialise #R$5BD1 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ;
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Initialise #R$5BE2 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       bl   @duel_draw_bandit_prep    ; CALL $C661        ; }
* Count down 5-4-3-2-1...0!
* countdown_initialise                 ; c4c5
       li   tmp0,duel_module
       bl   @play_module
       movb @bytes+53,a                ; LD A,$35          ; {Initialise countdown to "5" seconds ($35 in ASCII),
countdown_loop:                        ; c4c7
       .push af                        ; PUSH AF           ; hold this at #R$C6E0.
       movb a,@duel_timer              ; LD ($C6E0),A      ; }
       bl   @duel_print_countdown     ; CALL $C6D3        ;
       movb @bytes+49,b                ; LD B,$31          ; {Short halt loop (1 second pause).
countdown_halt_loop:                   ; c4d0
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C4D0        ; }
       jne  countdown_halt_loop        ;                   
       .pop af                         ; POP AF            ; {Keep looping back to #R$C4C7 until the countdown is
       sb   one,a                      ; DEC A             ; "0" ($30 in ASCII).
       cb   a,@bytes+48                ; CP $30            ; 
       jne  countdown_loop             ; JR NZ,$C4C7       ; }
       movb @bytes+32,a                ; LD A,$20          ; {Blank the countdown timer by printing a "SPACE" ($20
       movb a,@duel_timer              ; LD ($C6E0),A      ; in ASCII) over the top of it.
       bl   @duel_print_countdown     ; CALL $C6D3        ; }
       jmp  duel_outer_loop            ; JR $C4F9          ; Jump to #R$C4F9 and start the duel!

*********************************************************************
check_any_duellers_shot:               ; c4e3
       .proc
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C530 with #R$5BC0.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C530 with #R$5BD1.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C530 with #R$5BE2.
       bl   @check_if_duellers_are_shot ; CALL $C530        ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
duel_outer_loop:                       ; c4f9
       mov  @duel_inner_iterations,de  ; LD DE,($C52E)     ; {#REGde=#R$C52E and push it on the stack.
duel_inner_loop:                       ; c4fd
       .push de                        ; PUSH DE           ; }
       bl   @check_any_duellers_shot   ; CALL $C4E3        ;
       .pop de                         ; POP DE            ; 
       bl   @module_player
       dec  de                         ; DEC DE            ;
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  duel_inner_loop            ; JR NZ,$C4FD       ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       bl   @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_2               ; LD IX,$5BD1       ; 
       bl   @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_3               ; LD IX,$5BE2       ; 
       bl   @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       movb @8(ix),a                   ; LD A,(IX+$08)     ; Any duellers left?
       socb @26(ix),a                  ; OR (IX+$19)       ;
       socb @44(ix),a                  ; OR (IX+$2A)       ;
       jne  !                          ; JP Z,$C690        ; 
       b    @duel_complete             ;                   
!
       jmp  duel_outer_loop            ; JR $C4F9          ;

duel_inner_iterations:                 ; c52e
       data 31                                             ;

*********************************************************************
check_if_duellers_are_shot:            ; c530
       .proc
       bl   @duel_check_fire_at_3     ; CALL $C543        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       bl   @duel_check_fire_at_1     ; CALL $C550        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       bl   @duel_check_fire_at_2     ; CALL $C55D        ;
       bl   @check_if_dueller_is_shot ; CALL $C56B        ;
       .endproc                        ; RET               ; Return.

*********************************************************************
duel_check_fire_at_3:                  ; c543
       .proc
       bl   @execute_control_method    ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_3_1     ; RET Z             ; }
       movb a,tmp0                     ; BIT 0,A           ; right {If bit 0 is not zero then return setting #REGa to
       movb @bytes+3,a                 ;
       andi tmp0,1*256                 ; LD A,$03          ; $03.
       jne  duel_check_fire_at_3_1     ; RET NZ            ; }
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
duel_check_fire_at_3_1:
       .ret                            ; RET               ; }

*********************************************************************
duel_check_fire_at_1:                  ; c550
       .proc
       bl   @execute_control_method    ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_1_1     ; RET Z             ; }
       movb a,tmp0                     ; BIT 1,A           ; left {If bit 1 is not zero then return setting #REGa to
       movb one,a                      ;
       andi tmp0,2*256                 ; LD A,$01          ; $01.
       jne  duel_check_fire_at_1_1     ; RET NZ            ; }
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
duel_check_fire_at_1_1:
       .ret                            ; RET               ; }

*********************************************************************
duel_check_fire_at_2:                  ; c55d
       .proc
       bl   @execute_control_method    ; CALL $5B88        ;
       movb a,tmp0                     ; BIT 4,A           ; 
       andi tmp0,16*256                ;                   
       jeq  duel_check_fire_at_2_1     ; RET Z             ;
       movb a,tmp0
       sb   a,a                        ; AND $03           ;
       andi tmp0,3*256                 ; LD A,$00          ;
       jne  duel_check_fire_at_2_1     ; RET NZ            ;
       movb @bytes+2,a                 ; LD A,$02          ;
duel_check_fire_at_2_1:
       .endproc                        ; RET               ; Return.

*********************************************************************
check_if_dueller_is_shot:              ; c56b
       .proc
       cb   a,@3(ix)                   ; CP (IX+$03)       ; {If player fires at dueller then
       jeq  dueller_is_shot            ; JR Z,$C575        ; jump to #R$C575.}
       sb   @13(ix),@13(ix)            ; LD (IX+$0D),$00   ; 
       jmp  check_if_dueller_is_shot_1 ; RET               ; Return.
dueller_is_shot:                       ; c575
       movb @13(ix),a                  ; LD A,(IX+$0D)     ; 
       ; AND A                         ; AND A             ; 
       jne  check_if_dueller_is_shot_1 ; RET NZ            ;
       movb one,a                      ; LD A,$01          ;
       movb a,@13(ix)                  ; LD (IX+$0D),A     ; 
       movb a,*ix                      ; LD (IX+$00),A     ; Set dueller state to $01.
check_if_dueller_is_shot_1:
       .endproc                        ; RET               ; Return.

*********************************************************************
* This entry point is used by the routines at #R$C607 and #R$C6E5.
duel_shot_sound:
* Jump - not call
       bl   @shot_sound_1              ; CALL $6500        ;
       .endproc                        ; RET               ;

*********************************************************************
* Dueller routing
update_dueller_status:
       .proc
       movb @8(ix),a                   ; LD A,(IX+$08)     ; {If IX+$08 is zero then return.
       ; AND A                         ; AND A             ; 
       jeq  update_dueller_status_6    ; RET Z             ; }
       movb @9(ix),a                   ; LD A,(IX+$09)     ; {If dueller frame index is $01 then jump to #R$C5A1.
       sb   one,a                      ; DEC A             ; 
       jeq  update_dueller_status_1    ; JR Z,$C5A1        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $02 then jump to #R$C5B5.
       jeq  update_dueller_status_2    ; JR Z,$C5B5        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $03 then jump to #R$C5BD.
       jeq  update_dueller_status_3    ; JR Z,$C5BD        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $04 then jump to #R$C5CF.
       jeq  update_dueller_status_4    ; JR Z,$C5CF        ; }
       jmp  update_dueller_status_5    ; JR $C5DD          ; Jump to #R$C5DD.
update_dueller_status_1:               ; c5a1
       li   hl,dueller_duel_over_2     ; LD HL,$C6E5       ; #R$C6E5. Lost
       bl   @check_dueller_duel_over   ; CALL $C5EB        ;
       sb   one,@1(ix)                 ; DEC (IX+$01)      ; Timer
       jne  update_dueller_status_6    ; RET NZ            ;
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       movb @11(ix),a                  ; LD A,(IX+$0B)     ; Char frame
       bl   @duel_draw_bandit_prep     ; CALL $C661        ; Draw?
       jmp  update_dueller_status_6    ; RET               ;
update_dueller_status_2:               ; c5b5
       sb   one,@16(ix)                ; DEC (IX+$10)      ; Timer
       jne  update_dueller_status_6    ; RET NZ            ;
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       jmp  update_dueller_status_6    ; RET               ;
update_dueller_status_3:               ; c5bd              ; Shoot?
       li   hl,dueller_duel_over_1     ; LD HL,$C5F6       ; Won
       bl   @check_dueller_duel_over  ; CALL $C5EB         ;
       sb   one,@2(ix)                 ; DEC (IX+$02)      ; Timer
       jne  update_dueller_status_6    ; RET NZ            ;
       movb a,@8(ix)                   ; LD (IX+$08),A     ; Completed
       ab   one,a                      ; INC A             ; 
       movb a,@duel_bang_flag          ; LD ($C6E2),A      ; Bang
       jmp  update_dueller_status_6    ; RET               ;
update_dueller_status_4:               ; c5cf
       sb   one,@14(ix)                ; DEC (IX+$0E)      ; Timer
       jne  update_dueller_status_6    ; RET NZ            ;
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Frame/state
       movb @12(ix),a                  ; LD A,(IX+$0C)     ; Char frame
       bl   @duel_draw_bandit_prep     ; CALL $C661        ;
       jmp  update_dueller_status_6    ; RET               ;
update_dueller_status_5:               ; c5dd
       sb   one,@15(ix)                ; DEC (IX+$0F)      ; Timer
       jne  update_dueller_status_6    ; RET NZ            ;
       movb @17(ix),a                  ; LD A,$02          ; Char frame dueller 1
       bl   @duel_draw_bandit_prep     ; CALL $C661        ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; Completed
update_dueller_status_6:
       .endproc                        ; RET               ;

*********************************************************************
* Routine at C5EB
* 
* Used by the routine at #R$C422.
check_dueller_duel_over:               ; c5eb
       movb *ix,a                      ; LD A,(IX+$00)     ; {Check if the current duellers state is zero (complete),
       ; AND A                         ; AND A             ; return if so.
       jeq  check_dueller_duel_over_1  ; RET Z             ; }
       sb   a,a                        ; XOR A             ; {Mark the current dueller as complete.
       movb a,*ix                      ; LD (IX+$00),A     ; }
                                       ; POP AF            ; Pop return address
       b    *hl                        ; JP (HL)           ; Branches to dueller_duel_over_1 or dueller_duel_over_2
check_dueller_duel_over_1:
       rt
*// check_dueller_duel_over

*********************************************************************
dueller_duel_over_1:                   ; c5f6
       movb @2(ix),a                   ; LD A,(IX+$02)     ; 
       srl  a,1                        ; SRL A             ; 
                                       ; CP $09            ;
       movb @4(ix),@e                  ; LD E,(IX+$04)     ; 
       movb @5(ix),d                   ; LD D,(IX+$05)     ;
       cb   a,@bytes+9                                     ; Check time after draw?
       jhe  duel_points                ; JR NC,$C628       ;
       socb one,a                      ; OR $01            ; 

*********************************************************************
* Displays The Bonus Score Text.
* 
* Used by the routine at #R$C628.
print_bonus_score:                     ; c607
       movb a,@7(ix)                   ; LD (IX+$07),A     ; {Stores the ASCII representation of the number at #R$C41D (it adds ASCII "0") so for example 1 ends up being
       li   hl,duel_bonus_text         ; LD HL,$C41D       ; 1 + $30 = $31 (e.g. "1" in ASCII).
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*hl                      ; LD (HL),A         ; }
       li   bc,>2928                   ; LD BC,$2928       ; {Print using #R$5B80.
       bl    @print_two_tone_text      ; CALL $5B80        ; #TABLE(default,centre,centre,centre,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; { $28 | $00 | $05 | $00 }
                                                           ; TABLE#}
       bl   @scoring_for_door          ; CALL $5B8C        ;
       bl   @draw_score                ; CALL $5B98        ;
       ab   one,@9(ix)                 ; INC (IX+$09)      ; frame/state
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

*********************************************************************
* Displays "Extra" and Bonus Score text.
* 
* Handles whether to display points or "EXTRA" above each downed Bandit.
duel_points:                           ; c628
       movb @duel_extra_life_flag,tmp0      ; LD A,($C6E4)      ; {If #R$C6E4 is NOT zero then award 9(00) bonus points.
       ; AND A                         ; AND A             ; 
       movb @bytes+9,a                 ; LD A,$09          ;
       movb tmp0,tmp0
       jne  print_bonus_score          ; JR NZ,$C607       ; }
       li   hl,lives                   ; LD HL,($5B86)     ; {Fetch a 16 bit address from #R$5B86 (#R$CC59), if it is
       movb *hl,tmp0                   ; LD A,(HL)         ; higher than $05 then award 9(00) bonus points.
                                       ; CP $05            ;
       movb @bytes+9,a                 ; LD A,$09          ;
       cb   tmp0,@bytes+5
       jhe  print_bonus_score          ; JR NC,$C607       ; }
       li   hl,extra_text_copy         ; LD HL,$C622       ; {Points to #R$C622 and sends it to #R$5B80.
       dec  de                         ; DEC DE            ; #TABLE(default,centre)
       li   bc,>2a29                   ; LD BC,$2A29       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $2A | $02 | $05 | $00 }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; TABLE#}
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$C6E4.
       movb a,@duel_extra_life_flag         ; LD ($C6E4),A      ; }
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Move onto the next frame.
       .ret                            ; RET               ; Return.

*********************************************************************
* Process Dueller Shot.
dueller_duel_over_2:                   ; c6e5
       movb @bytes+4,a                 ; LD A,$04          ; {Writes $04 to #R$C6E3.
       movb a,@duel_lose_life_flag          ; LD ($C6E3),A      ; }
       movb a,@9(ix)                   ; LD (IX+$09),A     ; Sets the dueller frame index to $04.
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

*********************************************************************
* Draw Duel Bandit
* 
* Used by the routine at #R$C422.
duel_draw_bandit_prep:                 ; c661
       .proc
       clr  tmp2
       movb @3(ix),tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>80
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character
       .endproc                        ; RET               ; Return.

*********************************************************************
* Routine at C67F
* 
* Used by the routine at #R$C422.
duel_update_timer:                     ; c67f
       andi a,63*256                   ; AND $3F           ; {Updates dueller timer.
       socb @bytes+64,a                ; OR $40            ; 
       movb a,@1(ix)                   ; LD (IX+$01),A     ; }
       rt                              ; RET               ; Return.

*********************************************************************
* Lose A Life
* 
* Used by the routine at #R$C690.
* Jump - not call
duel_lose_life:                        ; c687
       bl   @bang                      ; CALL $C000        ; Calls the subroutine to display the "BANG" animation.
       li   hl,lives                   ; LD HL,($5B86)     ; {Decrease the lives counter by one (#R$CC59), set the
       sb   one,*hl                    ; DEC (HL)          ; zero flag if all lives are lost.
       ; AND A                         ; AND A             ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* Duel is finished
* 
* Used by the routine at #R$C422.
duel_complete:                         ; c690
* Jump - not call
       movb @duel_lose_life_flag,a          ; LD A,($C6E3)      ; {Jump to #R$C6F0 if #R$C6E3 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6F0       ; }
       b    @flash_life_image          ;                   
!
       movb @duel_bang_flag,a          ; LD A,($C6E2)      ; {Jump to #R$C687 if #R$C6E2 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C687       ; }
       b    @duel_lose_life                 ;
!
       movb @duel_extra_life_flag,a         ; LD A,($C6E4)      ; {Jump to #R$C6B1 if #R$C6E4 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6B1       ; }
       b    @duel_flash_text           ;                   
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }
*// duel_complete

*********************************************************************
* Write "Lives" text.
* 
* Used by the routines at #R$C422 and #R$C6B1.
duel_print_lives:                      ; c6a7
       .proc
       li   de,zx_screen+>10d0         ; LD DE,$50D0       ; {Helper routine called from #R$C463 used for writing #R$C655 to the screen using the colours held in #REGbc;
       li   bc,>0702                   ; LD BC,$0702       ; #TABLE(default,centre)
       bl    @print_two_tone_text      ; CALL $5B80        ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                        ; RET               ; Return.

*********************************************************************
* Duel: Gain Extra Life.
* 
* Used by the routine at #R$C690.
* Jump - not call
duel_flash_text:                       ; c6b1
       movb @bytes+8,b                 ; LD B,$08          ; {Alternates displaying #R$C65B and #R$C655 to "flash"
duel_flash_text_loop:                  ; c6b3
       .push bc                        ; PUSH BC           ; the lives indicator.
       li   hl,playfield_whitespace    ; LD HL,$C65B       ; 
       bl   @duel_print_lives          ; CALL $C6A7        ;
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_1:                ; c6bc
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6BC        ; 
       jne  duel_flash_halt_loop_1     ;                   
       li   hl,playfield_lives         ; LD HL,$C655       ; 
       bl   @duel_print_lives          ; CALL $C6A7        ;
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_2:                ; c6c7
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6C7        ; 
       jne  duel_flash_halt_loop_2     ;                   
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $C6B3        ; }
       jne  duel_flash_text_loop       ;                   
       li   hl,lives                   ; LD HL,($5B86)     ; {Increase the lives counter by one (#R$CC59).
       ab   one,*hl                    ; INC (HL)          ; }
       ; SCF                           ; SCF               ; {Sets the carry flag and returns.
       b    @return_with_carry         ; RET               ; }

*********************************************************************
* Write "Countdown" text.
* 
* Used by the routine at #R$C422.
duel_print_countdown:                  ; c6d3
       .proc
       li   hl,duel_timer              ; LD HL,$C6E0       ; {Helper routine used for writing #R$C6E0 to the screen using the colours held in #REGbc;
       li   de,zx_screen+>004f         ; LD DE,$404F       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                        ; RET               ; Return.

*********************************************************************
* Flash Life Image.
* 
* This routine flashes the last life image eight times, and returns with lives being one less and the carry flag
* being set.
* Jump - not call
flash_life_image:                      ; c6f0
       li   hl,lives                   ; LD HL,($5B86)     ; {Decrease #R$CC59 by one.
       sb   one,*hl                    ; DEC (HL)          ; }
       movb @bytes+8,b                 ; LD B,$08          ; Sets #REGb (the counter) to loop $08 times.
flash_life_image_loop:                 ; c6f6
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       ab   one,*hl                    ; INC (HL)          ; {Increase #R$CC59 by one and call #R$5B83.
       bl   @draw_life_images         ; CALL $5B83        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_1:          ; c6fe
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6FE        ; }
       jne  flash_life_image_halt_loop_1 ;                   
       .pop hl                         ; POP HL            ; 
       .push hl                        ; PUSH HL           ; 
       sb   one,*hl                    ; DEC (HL)          ; {Decrease #R$CC59 by one and call #R$5B83.
       bl   @draw_life_images          ; CALL $5B83        ; }
       .pop hl                         ; POP HL            ; 
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_2:          ; c70a
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C70A        ; }
       jne  flash_life_image_halt_loop_2 ;                   
       .pop bc                         ; POP BC            ; {Retrieves #REGb (the counter) from the stack and loop
       sb   one,b                      ; DJNZ $C6F6        ; back until finished.}
       jne  flash_life_image_loop      ;                   
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

*********************************************************************
* Sheriff's Star Page
* 
* Used by the routine at #R$C7C0.
sheriff_star:                          ; c720
       .proc
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of the screen buffer (i.e.
;       li   de,zx_screen+1             ; LD DE,$4001       ; "blanks it").
;       li   bc,>1800                   ; LD BC,$1800       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
       li   tmp0,>0458
       li   tmp1,>0006
       li   tmp2,>080a
       bl   @ti_draw_color_area
       li   hl,zx_screen+>008b         ; LD HL,$408B       ; {Points to #R$F600 and prints it to the screen using
       li   de,gfx_badge_image         ; LD DE,$F600       ; #R$5B92.
       li   bc,>5008                   ; LD BC,$5008       ;
       bl   @ti_copy_routine             ; CALL $5B92        ; }
       li   hl,header_1                ; LD HL,$C765       ; {Points to #R$C765 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1001         ; LD DE,$5001       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_2                ; LD HL,$C784       ; {Points to #R$C784 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1041         ; LD DE,$5041       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_3                ; LD HL,$C7A3       ; {Points to #R$C7A3 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1083         ; LD DE,$5083       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                            ; RET               ; Return.

*********************************************************************
* hl: address of text to print
* de: screen address
* This entry point is used by the routines at #R$5B80 and #R$C7C0.
print_two_tone_text:                   ; cbd2
       .proc
       mov  bc,@two_tone_attributes_buffer ; LD ($CBD0),BC     ; Stash the attributes at #R$CBD0.
print_two_tone_text_loop:              ; cbd6
       movb *hl,a                      ; LD A,(HL)         ; {Grab the next character in the string, if it's $FF then
       cb   a,@b255                    ; CP $FF            ; return.
       jeq  print_two_tone_text_2      ; RET Z             ; }
       cb   a,@bytes+48                ; CP $30            ; 
       jne  print_two_tone_text_1      ; JR NZ,$CBE0       ;
       movb @bytes+58,a                ; LD A,$3A          ; 
print_two_tone_text_1:                 ; cbe0
       .push hl                        ; PUSH HL           ; 
       .push de                        ; PUSH DE           ; 
       bl   @print_tt_text_space_check ; CALL $CBFC        ; 
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; 
       inc  hl                         ; INC HL            ; 
       ab   one,@e                     ; INC E             ; 
       movb @e,a                       ; LD A,E            ; 
       andi a,31*256                   ; AND $1F           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb @e,a                       ; LD A,E            ; 
       ab   @bytes+32,a                ; ADD A,$20         ; 
       movb a,@e                       ; LD E,A            ; 
       andi a,224*256                  ; AND $E0           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb d,a                        ; LD A,D            ; 
       ab   @bytes+8,a                 ; ADD A,$08         ; 
       movb a,d                        ; LD D,A            ; 
       jmp  print_two_tone_text_loop   ; JR $CBD6          ; 
print_two_tone_text_2:
       .endproc
*// print_two_tone_text

*********************************************************************
* This entry point is used by the routine at #R$5B9B.
print_tt_text_space_check:             ; cbfc
       .proc
       cb   a,@bytes+32                ; CP $20            ; {If the character is a space then jump forward to
       jne  print_tt_text_2            ; JR NZ,$CC0E       ; #R$CC0E.}
*      Space
       li   hl,gfx_empty_space          ; LD HL,$5B00       ; Needs 16 zeros
       li   bc,>1001                   ; LD BC,$1001       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .push hl                        ; PUSH HL           ; 
       bl   @ti_copy_routine             ; CALL $D5E6        ;
       .pop hl                         ; POP HL            ;
       jmp  print_tt_text_4            ; JR $CC1D          ;
*      Not space
print_tt_text_2:                       ; cc0e              ; not space
       cb   a,@bytes+65                ; CP $41            ; 
       jhe  print_tt_text_3            ; JR NC,$CC14       ;
       ab   @bytes+42,a                ; ADD A,$2A         ; 
print_tt_text_3:                       ; cc14
       sb   @bytes+65,a                ; SUB $41           ; 
;       ab   @bytes+10,a               ; ADD A,$0A         ;
       .push de                        ; PUSH DE           ; 
       bl   @draw_tt_char             ; CALL $CDAE        ;
       .pop hl                         ; POP HL            ;
*      Attributes
print_tt_text_4:                       ; cc1d
       bl   @print_tt_attribute_addr   ; CALL $CC2B        ;
       mov  @two_tone_attributes_buffer,bc ; LD BC,($CBD0)     ; {Load the stored top/ bottom attribute bytes back into
;       movb b,*hl                     ; LD (HL),B         ; #REGbc and write them to the screen.
       mov  hl,tmp1
       movb b,a
       bl   @ti_draw_attribute
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       movb @c,*hl                     ; LD (HL),C         ; }
       ai   hl,>20
       mov  hl,tmp1
       movb @c,a
       bl   @ti_draw_attribute
       .ret                            ; RET               ; Return.
*// print_tt_text_space_check

*********************************************************************
* Routine at CC2B
* 
* Used by the routine at #R$CBD0.
print_tt_attribute_addr:
       movb h,a                        ; LD A,H            ; 
       andi a,24*256                   ; AND $18           ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       ab   @bytes+88,a                ; ADD A,$58         ; 
       movb a,h                        ; LD H,A            ; 
       rt                              ; RET               ; Return.
*// print_tt_attribute_addr

*********************************************************************
* Main Playfield Initialisation.
* 
* Used by the routine at #R$C7C0.
*
* Draws Main Playfield with all three doors closed.
draw_doors_and_playfield:              ; cc3a
       .proc
       bl   @ti_draw_playfield
       movb one,a                      ; LD A,$01          ; {Calls #R$D664 with #R$CE1A set to $01.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Calls #R$D664 with #R$CE1A set to $02.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$D664 with #R$CE1A set to $03.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1         ; JP $D664          ; }
       .endproc

*********************************************************************
* Display The "Life" Images.
* 
* Used by the routines at #R$5B83, #R$C7C0 and #R$CD1B.
draw_life_images:                      ; cc5a
       .proc
*      Delete all life images
       movb @bytes+5,b                 ; LD B,$05          ; {Set up counter=$05 screen buffer=$50B6.
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ; }
delete_life_images_loop:               ; cc5f
       .push bc                        ; PUSH BC           ; {jjjss
       li   de,gfx_empty_space         ; LD DE,$5B00       ; Needs 48 zeros
       bl   @copy_life_image           ; CALL $CC84        ;
       inct hl                         ; INC HL            ;
                                       ; INC HL            ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC5F        ; }
       jne  delete_life_images_loop           ;
*      Draw life images
       movb @lives,a                   ; LD A,($CC59)      ; {If #R$CC59 are zero then return.
       ; AND A                         ; AND A             ; 
       jeq  draw_life_images_end       ; RET Z             ; }
       cb   a,@bytes+6                 ; CP $06            ; {If #R$CC59 is more than or equal to "6" then return.
       jhe  draw_life_images_end       ; RET NC            ; }
       movb a,b                        ; LD B,A            ;
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ;
draw_life_images_loop:                 ; cc77
       .push bc                        ; PUSH BC           ; 
       bl   @draw_life_image          ; CALL $CC81        ;
       inct hl                         ; INC HL            ;
                                       ; INC HL            ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC77        ; 
       jne  draw_life_images_loop      ;                   
draw_life_images_end:
       .endproc                        ; RET               ; Return.
*// draw_life_images

*********************************************************************
draw_life_image:                       ; cc81
       .proc
       li   de,gfx_lives_image         ; LD DE,$FFB8       ; {Point at the #R$FFB8 and call #R$D5E6.
       jmp  copy_life_image_1
**
copy_life_image:                       ; cc84
       .proc
copy_life_image_1:
;      .push hl                        ; PUSH HL           ;
       li   bc,>1802                   ; LD BC,$1802       ; 
       bl   @ti_copy_routine             ; CALL $D5E6        ; }
;      .pop hl                         ; POP HL            ;
       .endproc                        ; RET               ; Return.
*// draw_life_image

*********************************************************************
* Draws Deposit Cashboxes.
* 
* Used by the routine at #R$C7C0.
draw_and_check_cashboxes:
       .proc
       movb @cashbox_ref,a             ; LD A,($D45C)      ; {Converts #R$D45C into cash deposit box flag address
       movb a,@l                       ; LD L,A            ; (e.g. "1" becomes #R$CC8D and so on).
       sb   h,h                        ; LD H,$00          ; 
       li   de,door_deposited_01-1     ; LD DE,$CC8C       ;
       a    de,hl                      ; ADD HL,DE         ; }
       li   ix,door_1_flags            ; LD IX,$D165       ; {#REGa=#R$D16D.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_2_flags            ; LD IX,$D173       ; {#REGa=#R$D17B.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_3_flags            ; LD IX,$D181       ; {#REGa=#R$D189.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       li   de,door_deposited_01_06    ; LD DE,$CC99       ; #REGde=#R$CC99.
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; #REGhl=#R$CC8D.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC99.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       inc  hl                         ; INC HL            ; 
       inc  de                         ; INC DE            ; Move onto #R$CC9A.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC9A.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       bl   @draw_cashboxes            ; CALL $CCFB        ;
* check_cashboxes_completed            ; ccd3
       li   de,door_deposited_01       ; LD DE,$CC8D       ; Points to the cashbox flags (beginning at #R$CC8D).
       li   hl,cashboxes_completed_flag ; LD HL,$CA80       ; {Write $00 to #R$CA80.
       sb   *hl,*hl                    ; LD (HL),$00       ; }
       movb @bytes+12,b                ; LD B,$0C          ; Testing against all 12 cashboxes.
check_cashboxes_completed_loop:        ; ccdd
       movb *de,a                      ; LD A,(DE)         ; {Fetch the cashbox flag, return if its zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       inc  de                         ; INC DE            ; {Move onto the next cashbox (loop back to #R$CCDD) or
       sb   one,b                      ; DJNZ $CCDD        ; continue once all 12 are checked.}
       jne  check_cashboxes_completed_loop
       movb a,*hl                      ; LD (HL),A         ; {Write #REGa ($01) to #R$CA80.
       .ret                            ; RET               ; }

*********************************************************************
draw_cashbox:                          ; cce5
       .proc
       ab   a,a                        ; ADD A,A           ; {Determines whether to send #R$FF78 or #R$FF98 to
       ab   @l,a                       ; ADD A,L           ; #R$D5E6.
       movb a,@l                       ; LD L,A            ; 
       li   de,gfx_empty_box_image     ; LD DE,$FF78       ;
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; 
       jeq  draw_cashbox_1             ; JR Z,$CCF4        ;
       li   de,gfx_dollar_box_image    ; LD DE,$FF98       ;
draw_cashbox_1:                        ; ccf4
       li   bc,>1002                   ; LD BC,$1002       ; 
       bl   @ti_copy_routine           ; CALL $D5E6        ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
* Draws all the cashboxes in two blocks of 6.
draw_cashboxes:                        ; ccfb
       .proc
       li   ix,door_deposited_01       ; LD IX,$CC8D       ; {The statuses for the cashboxes begin at #R$CC8D. This routine processes them in two blocks of 6 (as they
       li   hl,zx_screen+>001f         ; LD HL,$401F       ; appear. The first block is displayed at $401F, after processing the subroutine returns and continues for the
       movb one,a                      ; LD A,$01          ; next six blocks, just altering the screen location to $4025.
       bl   @draw_cashboxes_side       ; CALL $CD0A        ;
       li   hl,zx_screen+>0025         ; LD HL,$4025       ;
       bl   @draw_cashboxes_side
       .endproc

*********************************************************************
draw_cashboxes_side:                   ; cd0a
       .proc
       movb @bytes+6,b                 ; LD B,$06          ;
draw_cashboxes_loop:                   ; cd0c
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       .push af                        ; PUSH AF           ; 
       bl   @draw_cashbox             ; CALL $CCE5        ;
       .pop af                         ; POP AF            ; 
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; 
       inc  ix                         ; INC IX            ; 
       ab   one,a                      ; INC A             ; 
       sb   one,b                      ; DJNZ $CD0C        ; }
       jne  draw_cashboxes_loop        ;
       .endproc                        ; RET               ; Return.

*********************************************************************
* Flash Lives/ Lose Life.
* 
* Used by the routine at #R$C7C0.
flash_lives:                           ; cd1b
       bl   @mute_sound
       movb @bytes+10,b                ; LD B,$0A          ; {Short pause.
       bl   @halt_loop                 ; CALL $CD64        ; }
       li   hl,lives                   ; LD HL,$CC59       ; {Point to #R$CC59. Set a counter for $05 times and stash
       movb @bytes+5,b                 ; LD B,$05          ; it.
flash_lives_loop:                      ; cd25
       .push bc                        ; PUSH BC           ; }
       sb   one,*hl                    ; DEC (HL)          ; {Decrease the number of lives by one, stash the lives
       .push hl                        ; PUSH HL           ; memory location and draw the decreased life images.
       bl   @draw_life_images          ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       bl   @halt_loop                 ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; {Grab the lives memory location, increase it by one, stash the location again and draw the now increased life
       ab   one,*hl                    ; INC (HL)          ; images (i.e. what they were on entry to the routine).
       .push hl                        ; PUSH HL           ; 
       bl   @draw_life_images          ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       bl   @halt_loop                 ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; {Loop back until the counter is zero.
       sb   one,b                      ; DJNZ $CD25        ; }
       jne  flash_lives_loop           ;                   
                                       ; LD A,(HL)         ; {Finally decrease lives by one and if they are not zero
       sb   one,*hl                    ; DEC A             ; jump to #R$CACB.
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; }
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

*********************************************************************
* Routine at CD47
* 
* Used by the routine at #R$C7C0.
died:                                  ; cd47
       bl   @mute_sound
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 2 of #R$D2FE is zero then jump to #R$CD53.
       movb a,tmp0                     ; BIT 2,A           ; 
       andi tmp0,4*256                 ;                   ; Died from bomb flag
       jeq  died_1                     ; JR Z,$CD53        ; }
       bl   @explode_bomb             ; CALL $F880        ;
       jmp  died_2                     ; JR $CD56          ;
died_1:                                ; cd53
       bl    @bang                     ; CALL $C000        ;
died_2:                                ; cd56
       bl   @reset_door_routine_flags ; CALL $CD68        ;
       li   hl,lives                   ; LD HL,$CC59       ; 
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ; Lose life
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; 
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; 
       b    @return_with_carry         ; RET               ;

*********************************************************************
* Configurable "pause".
* 
* Used by the routines at #R$C7C0 and #R$CD1B.
*
* Loops back on itself using #REGb as a counter.
halt_loop:                             ; cd64
       .proc
halt_loop_1:                           ; cd64
       bl   @ti_vsync                  ; HALT              ; {Short interrupt driven pause, and return.
       sb   one,b                      ; DJNZ $CD64        ; 
       jne  halt_loop_1                ;
       .endproc                        ; RET               ; }
*// halt_loop

*********************************************************************
* Initialise Door Flags.
* 
* Used by the routines at #R$C7C0 and #R$CD47.
*
* Populates the state flags for each door.
reset_door_routine_flags:              ; cd68
       .proc
       li   ix,door_1_flags            ; LD IX,$D165       ; {Call #R$D8A1 using #REGix=#R$D165.
       bl   @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_2_flags            ; LD IX,$D173       ; {Call #R$D8A1 using #REGix=#R$D173.
       bl   @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_3_flags            ; LD IX,$D181       ; {Call #R$D8A1 using #REGix=#R$D181.
       bl   @reset_door_routine       ; CALL $D8A1        ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* Draw Score To The Screen
* 
* Used by the routines at #R$5B98, #R$C7C0 and #R$CDC3.
draw_score:                            ; cd90
       .proc
       li   hl,score_digit_1           ; LD HL,$CD8B       ; {Starting values; #TABLE(default,centre,centre,centre,centre)
       li   de,zx_screen+>10c8         ; LD DE,$50C8       ; { =h Source | =h Screen Buffer | =h Counter }
       movb @bytes+6,b                 ; LD B,$06          ; { #R$CD8B | $50C8 | $06 }
                                                           ; TABLE#}
score_digit_loop:                      ; cd98
       .push bc                        ; PUSH BC           ; {Stash the lot.
       .push de                        ; PUSH DE           ; 
       .push hl                        ; PUSH HL           ; }
       movb *hl,a                      ; LD A,(HL)         ; {Grab the number at the source memory location;
       ; AND A                         ; AND A             ; #LIST
       jne  score_digit_non_zero       ; JR NZ,$CDA1       ; { If it's zero then add $0A (as the numbers are stored 1-2-3-4-5-6-7-8-9-0 whereas ASCII uses 0-1-2-3-4-5-6-7-8-9) }
       ab   @bytes+10,a                ; ADD A,$0A         ; { add $23 (so for example "2" will be "$25" - see #R$CDAE) }
score_digit_non_zero:                  ; cda1
       ab   @bytes+25,a                ; ADD A,$23         ; { Call #R$CDAE }
       bl   @draw_tt_char              ; CALL $CDAE        ; LIST#}
       .pop hl                         ; POP HL            ; {Retrieve our current source, destination and counter
       .pop de                         ; POP DE            ; from the stack.
       .pop bc                         ; POP BC            ; }
       inc  de                         ; INC DE            ; {Increase the screen buffer memory location by one, decrease the source memory location and loop round to
       dec  hl                         ; DEC HL            ; #R$CD98 until it is zero.
       sb   one,b                      ; DJNZ $CD98        ; }
       jne  score_digit_loop           ;                   
       .endproc                        ; RET               ; Return.

*********************************************************************
* Draw Numbering from Character Set Index.
* 
* Used by the routines at #R$CBD0 and #R$CD90.
* a: character index to draw
draw_tt_char:                          ; cdae
       .proc
       .push de                        ; PUSH DE           ; {Using $C000 as a base address, this works out the character set memory address from a given index passed
       sb   h,h                        ; LD H,$00          ; in #REGa. To give an example using "2" ($25 - see #R$CD90);
       movb a,@l                       ; LD L,A            ; #LIST
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Loads <strong>$25</strong> as the low-order byte; #REGhl=$0025) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Times by <strong>$10</strong>; #REGhl=$250) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Add <strong>$C000</strong>=#R$C250) }
       a    hl,hl                      ; ADD HL,HL         ; LIST#
       li   de,gfx_char_a              ; LD DE,$C000       ; This is then passed to #R$D5E6.
       a    de,hl                      ; ADD HL,DE         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .pop hl                         ; POP HL            ; 
       li   bc,>1001                   ; LD BC,$1001       ;
       bl   @ti_copy_routine             ; CALL $D5E6        ; }
       .endproc                        ; RET               ; Return.
*// draw_tt_char

*********************************************************************
* Apply Scoring
* 
* Used by the routine at #R$C7C0.
scoring:                              ; cdc3
       .proc
       li   ix,door_1_flags           ; LD IX,$D165       ; {Calls #R$CDDC three times with #REGix containing;
       bl   @scoring_for_door         ; CALL $CDDC        ; #LIST
       li   ix,door_2_flags           ; LD IX,$D173       ; { #R$D165 }
       bl   @scoring_for_door         ; CALL $CDDC        ; { #R$D173 }
       li   ix,door_3_flags           ; LD IX,$D181       ; { #R$D181 }
       bl   @scoring_for_door         ; CALL $CDDC        ; LIST#}
       bl   @draw_score               ; CALL $CD90        ; Call #R$CD90.
       .endproc                       ; RET               ; Return.

*********************************************************************
* Passes the higher and lower score values to #R$CDF7 for the current door.
scoring_for_door:                      ; cddc
       .proc
       li   hl,score_digit_5           ; LD HL,$CD87       ; References #R$CD87.
       movb @6(ix),b                   ; LD B,(IX+$06)     ; Retrieves #REGix+$06, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @6(ix),@6(ix)              ; LD (IX+$06),$00   ; 
       bl   @scoring_apply             ; CALL $CDF7        ; Call #R$CDF7.
       li   hl,score_digit_4           ; LD HL,$CD88       ; References #R$CD88.
       movb @7(ix),b                   ; LD B,(IX+$07)     ; Retrieves #REGix+$07, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; 
       bl   @scoring_apply             ; CALL $CDF7        ; Call #R$CDF7.
       .endproc                        ; RET               ; Return.

*********************************************************************
* Applies the door scores into the player score.
scoring_apply:                         ; cdf7
       .proc
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       bl   @scoring_base_10           ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       movb @bytes+5,@e                ; LD E,$05          ; Sets a counter to $05 (5 more digits in the score).
scoring_apply_loop:                    ; cdfe
       inc  hl                         ; INC HL            ; Move onto the next scoring digit.
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       bl   @scoring_base_10           ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       sb   one,@e                     ; DEC E             ; {Loop back to #R$CDFE until the counter is zero (and
       jne  scoring_apply_loop         ; JR NZ,$CDFE       ; all scoring digits are accounted for).}
       .endproc                        ; RET               ; Return.

*********************************************************************
* Ensures the current scoring digit remains 0-9 (if $0A then it's reset and the
* carry digit is forwarded on).
scoring_base_10:                       ; ce08
       ab   b,a                        ; ADD A,B           ; Adds current score digit with passed score.
       sb   b,b                        ; LD B,$00          ; Reset passed score to zero.
       cb   a,@bytes+10                ; CP $0A            ; {Return if result is less than $0A (base 10).
       jl   scoring_base_10_1          ; RET C             ; }
       sb   @bytes+10,a                ; SUB $0A           ; Subtract $0A to keep this digit in base 10 (e.g. "11"
                                                           ; becomes "1", "12" becomes "2", and so on).
       ab   one,b                      ; INC B             ; {Add one onto the passed score (which carries onto the
scoring_base_10_1:
       rt                              ; RET               ; next digit as it goes lowest to highest) and return.}

*********************************************************************
* Routine at D2CF
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
check_input:                           ; d2cf
       .proc
       bl   @execute_control_method    ; LD HL,($CE12)     ; #R$CE12
                                       ; LD DE,$D2D7       ; Return address
                                       ; PUSH DE           ;
                                       ; JP (HL)           ;
*      Clear
       movb a,@c                       ; LD C,A            ;
       sb   a,a                        ; XOR A             ;
       li   hl,byte_before_hit         ; LD HL,$D2FF       ;
       movb a,*hl+                     ; LD (HL),A         ; clear _d2ff
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear hit
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear right
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear left
       movb @c,a                       ; LD A,C            ; 
*      Is 1,2,3 pressed?
       movb a,tmp0                     ; BIT 4,A           ;
       andi tmp0,16*256                ;                   
       jne  controls                   ; JR NZ,$D307       ; Yes - jump
*      No, clear 1,2,3
       li   hl,two_pressed             ; LD HL,$D303       ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear two
                                       ; INC HL            ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear three
                                       ; INC HL            ;
       sb   *hl,*hl                    ; LD (HL),$00       ; clear one
*      Is right pressed?
       movb a,tmp0                     ; BIT 0,A           ; 
       andi tmp0,1*256                 ;                   
       jne  set_right                  ; JP NZ,$D386       ;
*      Is left pressed
       movb a,tmp0                     ; BIT 1,A           ; 
       andi tmp0,2*256                 ;                   
       jne  set_left                   ; JP NZ,$D38C       ;
check_input_1:
       .endproc                        ; RET               ;

* Sets the flag for indicating "right" has been pressed by the player.
set_right:                             ; d386
       li   hl,right_pressed           ; LD HL,$D301       ; {Write $01 to #R$D301 and return.
       movb one,*hl                    ; LD (HL),$01       ;
       jmp  check_input_1              ; RET               ; }
* Sets the flag for indicating "left" has been pressed by the player.
set_left:                              ; d38c
       li   hl,left_pressed            ; LD HL,$D302       ; {Write $01 to #R$D302 and return.
       movb one,*hl                    ; LD (HL),$01       ;
       jmp  check_input_1              ; RET               ; }

*********************************************************************
* Action Controls.
* 
* Used by the routine at #R$D2CF.
* 
* On entry #REGa will contain one of;
* #TABLE(default,centre,centre,centre)
* { =h Value | =h Bits | Door }
* { $10 | #EVAL($10, 2, 8) | Door 2 }
* { $11 | #EVAL($11, 2, 8) | Door 3 }
* { $12 | #EVAL($12, 2, 8) | Door 1 }
* TABLE#
* This is written to #R$D306, and then decoded into writing a $01, $02 or $03 to #R$D300 to represent which door has
* been shot at.  This routine also writes $01 to #R$D305, #R$D303 and #R$D304 to represent the same thing.
* Before returning, #REGhl is set to the screen location for displaying the shot mask/ shot image in the centre of the
* door.
controls:                              ; d307
       li   hl,controls_byte           ; LD HL,$D306       ; {Writes #REGa to #R$D306 and sets #REGhl=#R$D300.
       movb a,*hl                      ; LD (HL),A         ; 
       li   hl,hit                     ; LD HL,$D300       ; }
       movb @c,a                       ; LD A,C            ; 
       movb a,tmp0                     ; BIT 0,A           ; {If "3" was pressed then jump to #R$D33B (a check for if
       andi tmp0,1*256                 ;                   
       jne  shot_three                 ; JR NZ,$D33B       ; bit 0 is set).}
       movb a,tmp0                     ; BIT 1,A           ; {If "1" was pressed then jump to #R$D360 (a check for if
       andi tmp0,2*256                 ;                   
       jne  shot_one                   ; JR NZ,$D360       ; bit 1 is set).}
* Handles settings flags and shot drawing location for door 2.
* shot_two                             ; d317
       movb @two_pressed,a             ; LD A,($D303)      ; {If #R$D303 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@three_pressed           ; LD ($D304),A      ; {Sets the other two door flags to zero (#R$D304 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the middle door is being shot at (write
       movb one,@two_pressed           ; LD ($D303),A      ; $01 to #R$D303 and $02 to #R$D300).
                                       ; LD A,$02          ;
       movb @bytes+2,*hl               ; LD (HL),A         ; }
       li   hl,random_seed             ; LD HL,$D8AC       ; {Increase #R$D8AC by one.
       ab   one,*hl                    ; INC (HL)          ; }
       bl   @ti_draw_door_2_shot
       bl    @shot_sound_1              ; JP $6500          ; Jump to #R$6500.
       .ret
* Handles settings flags and shot drawing location for door 3.
shot_three:                            ; d33b
       movb @three_pressed,a           ; LD A,($D304)      ; {If #R$D304 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the right door is being shot at (write $01
       movb one,@three_pressed         ; LD ($D304),A      ; to #R$D304 and $03 to #R$D300).
                                       ; LD A,$03          ;
       movb @bytes+3,*hl               ; LD (HL),A         ; }
       mov  @random_seed,tmp0          ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       sla  tmp0,1                     ; SLA (HL)          ; moved to the carry flag and bit 0 reset (zeroed).}
       mov  tmp0,@random_seed
       bl   @ti_draw_door_3_shot
       bl   @shot_sound_1              ; JP $6502          ; Jump to #R$6502.
       .ret
* Handles settings flags and shot drawing location for door 1.
shot_one:                              ; d360
       movb @one_pressed,a             ; LD A,($D305)      ; {If #R$D305 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@three_pressed           ; LD ($D304),A      ; #R$D304).}
                                       ; INC A             ; {Indicate the the left door is being shot at (write $01
       movb one,@one_pressed           ; LD ($D305),A      ; to #R$D305 and $01 to #R$D300).
                                       ; LD A,$01          ;
       movb one,*hl                    ; LD (HL),A         ; }
       mov  @random_seed,tmp0          ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       sla  tmp0,1                     ; SLA (HL)          ; moved to the carry flag and bit 0 reset (zeroed).}
       mov  tmp0,@random_seed
       bl   @ti_draw_door_1_shot
       bl   @shot_sound_1              ; CALL $6504        ; Jump to #R$6504.
       .ret                            ; RET               ; Return.

*********************************************************************
* Jump Controls.
*
* Loads the 16 bit address stored at #R$CE12 into #REGhl and jumps to it.
execute_control_method:                ; 5b88
       .proc
       mov  @control_routine_alias,hl  ; LD HL,($CE12)     ;
       b    *hl                        ; JP (HL)           ;

*********************************************************************
* Reads In-Game Joystick Controls.
controls_joystick:                     ; d392
* Jump - not call
       sb   a,a
       li   tmp0,KEY_FI
       bl   @ti_check_key
       jeq  controls_joystick_1
       movb @bytes+>10,a
controls_joystick_1:
       li   tmp0,KEY_LF
       bl   @ti_check_key
       jeq  controls_joystick_2
       socb @bytes+>02,a
controls_joystick_2:
       li   tmp0,KEY_RG
       bl   @ti_check_key
       jeq  controls_joystick_3
       socb @bytes+>01,a
controls_joystick_3:
       .endproc                         ; RET               ; Return.

*********************************************************************
* Reads In-Game Keyboard Controls (1-2-3).
* 
* Used by the routine at #R$D392.
controls_keyboard:                     ; d39b
* Jump - not call
       sb   a,a                        ; LD A,$F7          ; {Read keys 1-2-3-4-5.
                                       ; IN A,($FE)        ; }
* controls_keyboard_1                  ; d39f
       li   tmp0,KEY_1                 ; BIT 0,A           ; {If "1" isn't being pressed then jump to #R$D3A6.
       bl   @ti_check_key              ;
       jeq  controls_keyboard_2        ; JR NZ,$D3A6       ; }
       movb @bytes+18,a                ; LD A,$12          ; {Set #REGa=$12 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
controls_keyboard_2:                   ; d3a6
       li   tmp0,KEY_2                 ; BIT 1,A           ; {If "2" isn't being pressed then jump to #R$D3AD.
       bl   @ti_check_key              ;
       jeq  controls_keyboard_3        ; JR NZ,$D3AD       ; }
       movb @bytes+16,a                ; LD A,$10          ; {Set #REGa=$10 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
controls_keyboard_3:                   ; d3ad
       li   tmp0,KEY_3                 ; BIT 2,A           ; {If "3" isn't being pressed then jump to #R$D3E2.
       bl   @ti_check_key              ;
       jeq  controls_input_o_p         ; JR NZ,$D3E2       ; }
       movb @bytes+17,a                ; LD A,$11          ; {Set #REGa=$11 and return.
       jmp  controls_keyboard_6                            ; RET               ; }
* Reads In-Game Controls (Left + Right).
* Used by the routine at #R$D39B.
controls_input_o_p:                    ; d3e2
       li   tmp0,KEY_O                 ; LD A,$DF          ; {Read keys P-O-I-U-Y.
       bl   @ti_check_key              ; IN A,($FE)        ; }
       jeq  controls_keyboard_5        ; CPL               ; Invert all the bits of #REGa.
       movb @bytes+2,a                 ; AND $03           ; Keep only bits 0 and 1 (i.e. we only care about "P" and
                                                           ; "O" for left and right).
       jmp  controls_keyboard_6                            ; RET               ; Return.
controls_keyboard_5:
      li   tmp0,KEY_P
       bl   @ti_check_key
       jeq  controls_keyboard_6
       movb one,a
controls_keyboard_6:
       .endproc

*********************************************************************
* Routine at D3EA
check_ready_to_scroll:                 ; d3ea
       .proc
       li   hl,door_1_routine          ; LD HL,$CE14       ; #R$CE14
       sb   a,a                        ; XOR A             ; {Sets #REGa=0 and #REGb=$06 (counter).
       li   bc,6                       ; LD B,$06          ; }
check_no_doors_active:                 ; d3f0
       socb *hl+,a                     ; OR (HL)           ;
                                       ; INC HL            ;
       dec  bc                         ; DJNZ $D3F0        ;
       jne  check_no_doors_active                          ;
       ; AND A                         ; AND A             ; 
       .pop bc                         ; POP BC            ; Pop return address off stack
       movb a,a
       jne  check_ready_to_scroll_1    ; RET NZ            ; Return to caller's caller (game_loop) if any door active
       .push bc                        ; PUSH BC           ; Push return address back
       li   hl,random_seed             ; LD HL,$D8AC       ;
       ab   one,*hl                    ; INC (HL)          ; 
                                       ; LD DE,$0400       ; (TI moved)
;      bl   @check_cashboxes_flag      ; CALL $D407       ;
       li   hl,cashboxes_completed_flag
       movb *hl,a
       jeq  check_ready_to_scroll_1    ; RET NC            ; Return move_right_or_left if cashboxes not completed
       sb   *hl,*hl
       .pop bc                         ; POP AF            ; Pop return address off stack
       .pop bc                         ; POP AF            ; Pop return address off stack
       ; AND A                         ; AND A             ;
check_ready_to_scroll_1:
       b    @return_without_carry      ; RET               ; Return to caller's caller's caller (run_phase)

*********************************************************************
;check_cashboxes_flag:                  ; d407
;       .proc
;       li   hl,cashboxes_completed_flag ; LD HL,$CA80      ;
;       movb *hl,a                      ; LD A,(HL)         ; Check the flag
;       ; AND A                         ; AND A             ;
;       jne  !                          ; RET Z             ;
;       b    @return_without_carry      ;                   ; Return without carry if not completed
;!
;       sb   *hl,*hl                    ; LD (HL),$00       ; Clear the flag
;       ; SCF                           ; SCF               ;
;       b    @return_with_carry         ; RET               ; Return with carry if completed

*********************************************************************
* This entry point is used by the routine at #R$C7C0.
move_right_or_left:                    ; d411
       .proc
       bl   @check_ready_to_scroll     ; CALL $D3EA        ;
       li   de,>0080                                       ; Number of iterations for loop to check left/right
move_right_or_left_loop:
       .push de                        ; PUSH DE           ;
       bl   @check_input               ; CALL $D2CF        ;
       movb @right_pressed,a           ; LD A,($D301)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D42D     ; 
       bl   @move_cashboxes_right      ;
!
       movb @left_pressed,a            ; LD A,($D302)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D449     ; 
       bl   @move_cashboxes_left       ;
!
       bl   @module_player
       .pop de                         ; POP DE            ; 
       dec  de                         ; DEC DE            ; 
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  move_right_or_left_loop    ; RET Z             ;
       .endproc                        ;

*********************************************************************
move_cashboxes_right:                  ; d42d
       .proc
       bl   @ti_scroll_left            ; CALL $6600        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   draw_selection_and_return  ; JR C,$D43F        ;
       movb one,*hl                    ; LD (HL),$01       ; 

draw_selection_and_return:             ; d43f
       bl   @draw_cashbox_selections  ; CALL $D45E        ;
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb a,@cashbox_ref             ; LD ($D45C),A      ;
       .endproc                        ; RET               ;

*********************************************************************
move_cashboxes_left:                   ; d449
       .proc
       bl   @ti_scroll_right           ; CALL $6700        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       sb   one,a                      ; DEC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       ; AND A                         ; AND A             ; 
       jne  draw_selection_and_return  ; JR NZ,$D43F       ;
       movb @bytes+12,*hl              ; LD (HL),$0C       ; 
       jmp  draw_selection_and_return  ; JR $D43F          ;

*********************************************************************
* Cash Deposit Box Reference.
cashbox_ref:                           ; d45c
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).
cashbox_ref_new:                       ; d45d
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).

*********************************************************************
* Routine at D45E
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
draw_cashbox_selections:               ; _d45e
       .proc
       clr  a
       movb @cashbox_ref,a             ; LD A,($D45C)      ;
       movb @bytes+56,@c               ; LD C,$38          ; Attribute black/grey
       bl   @draw_cashbox_selections_1 ; CALL $D46B       ; Remove old selection
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb @bytes+58,@c               ; LD C,$3A          ; Attribute red/grey
       bl   @draw_cashbox_selections_1
       .endproc

*********************************************************************
draw_cashbox_selections_1:             ; d46b              ; Apply new selection
       .proc
       movb @bytes+3,b                 ; LD B,$03          ; 
draw_cashbox_selections_2:             ; d46d
       .push af                        ; PUSH AF           ; 
       bl   @draw_cashbox_selection    ; CALL $D47E        ;
       .pop af                         ; POP AF            ; 
       ab   one,a                      ; INC A             ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   !                          ; CALL NC,$D47B     ; 
       movb one,a                      ;                   ; Inlined
!
       sb   one,b                      ; DJNZ $D46D        ; 
       jne  draw_cashbox_selections_2                      ;
       .ret                            ; RET               ; 

*********************************************************************
draw_cashbox_selection:                ; d47e
       .proc
                                       ; CP $07            ; In right side?
       li   hl,zx_attributes+>0005     ; LD HL,$5805       ; Right
       cb   a,@bytes+7
       jhe  draw_cashbox_selection_1   ; JR NC,$D488       ;
       li   hl,zx_attributes+>00ff     ; LD HL,$58FF       ; Left
draw_cashbox_selection_1:              ; d488
       ab   a,a                        ; ADD A,A           ; 2*a
       ab   @l,a                       ; ADD A,L           ; l=2*a-1 or l=2*a+5
       movb a,@l                       ; LD L,A            ;
       movb @c,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       inc  hl                         ; INC HL            ; 
       mov  hl,tmp1
       bl   @ti_draw_attribute
;      movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       .ret                            ; RET               ; 

*********************************************************************
* Draw Doors.
* 
* Used by the routines at #R$CC3A, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
* 
* .
* 
* Preps door frame 1.
draw_door_frame_1:                     ; d664
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_1
       .endproc

* Preps door frame 2.
draw_door_frame_2:                     ; d6d1
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_2
       .endproc
* Preps door frame 3.
draw_door_frame_3:                     ; d6df
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_3
       .endproc
* Preps door frame 4.
draw_door_frame_4:                     ; d6ed
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_4
       .endproc

*********************************************************************
* Routine at D8A1
* 
* Used by the routines at #R$CD68, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
reset_door_routine:                    ; d8a1
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Blanks the 16 bit address pointed to by one of the
                                       ; LD H,(IX+$01)     ; passed door flags (i.e. writes $0000 to one of #R$CE14,
                                       ; XOR A             ; #R$CE16, #R$CE18).
       clr  *hl                        ; LD (HL),A         ;
                                       ; INC HL            ;
                                       ; LD (HL),A         ; }
       rt                              ; RET               ; Return.

*********************************************************************
* Routine at DAEF
*
* Used by the routine at #R$CE21.
random_number_x:                     ; daef
       .proc
       a    @frame,@random_seed
       bl   @random_number             ; CALL $D8B0         ;
;       movb a,@c                       ; LD C,A            ;
;       movb @>5c78,a                   ; LD A,($5C78)      ; Get FRAMES
;       src  a,3                        ; RR C              ;
;                                       ; RR C              ;
;                                       ; RR C              ;
;       ab    @c,a                      ; ADD A,C           ;
       .endproc                         ; RET               ;

*********************************************************************
* Game status buffer entry at D8AC
random_seed:
       data >92ee

* Game status buffer entry at D8AE
random_flag:
       data >e51b

*********************************************************************
* Routine at D8B0
* 
* Used by the routines at #R$C7C0, #R$CE21, #R$CEB8 and #R$DAEF.
* 
random_number:                         ; d8b0
       .proc
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGhl for later.
       .push hl                        ; PUSH HL           ; }
                                       ; LD A,($D8AE)      ; {Decrease #R$D8AE by one.
       sb   one,@random_flag           ; DEC A             ;
                                       ; LD ($D8AE),A      ; }
       jne  random_number_1            ; JR NZ,$D8C8       ; If the result is not zero jump to #R$D8C8.
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       jmp  random_number_2            ; JR $D8D7          ;
random_number_1:                       ; d8c8
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       a    bc,hl                      ; ADD HL,BC         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
random_number_2:                       ; d8d7
       a    bc,hl                      ; ADD HL,BC         ;
       dec  hl                         ; DEC HL            ;
       mov  hl,@random_seed            ; LD ($D8AC),HL     ;
       movb @l,a                       ; LD A,L            ;
       li   hl,random_flag+1           ; LD HL,$D8AF       ;
       ab   one,*hl                    ; INC (HL)          ;
       ab   *hl,a                      ; ADD A,(HL)        ;
       .pop hl                         ; POP HL            ;
       .pop bc                         ; POP BC            ;
       .endproc                         ; RET               ; 

*********************************************************************
* Used by the routine at #R$CD47.
explode_bomb:
       .proc
       bl   @shot_sound_3
       li   bc,12                      ; LD B,$0C          ;
explode_bomb_1:                        ; f882
       .push bc                        ; PUSH BC           ; 
       bl @explode_bomb_3              ; CALL $F894        ;
       .pop bc                         ; POP BC            ; 
       dec  bc                         ; DJNZ $F882        ;
       jne  explode_bomb_1             ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color       ; OUT ($FE),A       ;
       movb @bytes+64,b                ; LD B,$40          ;
       bl   @halt_loop
       .endproc                        ; RET               ;

*********************************************************************
explode_bomb_3:                        ; f894
       .proc
       movb @bytes+56,a                ; LD A,$38          ; 
       bl   @ti_set_screen_color       ; CALL $F8B2        ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color       ; OUT ($FE),A       ;
       li   bc,4                       ; LD B,$04          ;
explode_bomb_4:                        ; f8a0
       bl   @ti_vsync                  ; HALT              ;
       dec  bc                         ; DJNZ $F8A0        ;
       jne  explode_bomb_4             ;
       movb @bytes+7,a                 ; LD A,$07          ; 
       bl   @ti_set_screen_color       ; CALL $F8B2        ;
       bl   @ti_set_border_color       ; OUT ($FE),A       ;
       li   bc,3                       ; LD B,$03          ;
explode_bomb_5:                        ; f8ae
       bl   @ti_vsync                  ; HALT              ;
       dec  bc                         ; DJNZ $F8AE        ;
       jne  explode_bomb_5             ;
       .endproc                        ; RET               ;

*********************************************************************
* This entry point is used by the routine at #R$C7C0.
scroll_dollar_sign:                    ; f960
       .proc
       bl   @play_deposit
       seto @graphics_bank_select
       li   de,gfx_dollar_image_2      ; LD DE,$F940       ; {Sends #R$F940 to #R$F9C3.
       bl   @dollar_scroll_draw        ; CALL $F9C3        ; }
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       bl   @dollar_scroll_draw        ; CALL $F9C3        ; }
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       bl   @dollar_scroll_draw        ; CALL $F9C3        ; }
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       bl   @dollar_scroll_draw        ; CALL $F9C3        ; }
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       bl   @dollar_scroll_draw        ; CALL $F9C3        ; }
*      Clear
       li   de,gfx_empty_space         ; LD DE,$5B00       ; {Sends #R$5B00 to #R$F9C3 (blanks the centrepiece).
       bl   @dollar_scroll_draw        ; CALL $F9C3        ;  Needs 32 zeros }
       .ret                            ; RET               ; Return.

*********************************************************************
* Draws the image to the screen.
* de=image to draw
dollar_scroll_draw:                    ; f9c3
       .proc
       li   tmp0,(1*32+15)*8
       mov  de,tmp1
       li   tmp2,>0202
       bl   @ti_draw_graphics
       bl   @ti_vsync
       bl   @ti_vsync
       .endproc                        ; RET               ; Return.

*********************************************************************
* Title Screen.
*
* Used by the routine at #R$C7C0.
title_screen:                          ; fe00
       .proc
       movb one,a                      ; LD A,$01          ;
       bl   @ts_draw_bandits           ; CALL $FEA4        ;
       li   hl,title_screen_game_name  ; LD HL,$FEEA       ; {Points to #R$FEEA and sends it to #R$5B80.
       li   de,zx_screen+>002b         ; LD DE,$402B       ;
       li   bc,>0703                   ; LD BC,$0703       ;
       bl    @print_two_tone_text ; CALL $5B80        ; }
       li   hl,title_screen_play       ; LD HL,$FEF4       ; {Points to #R$FEF4 and sends it to #R$FEE4.
       li   de,zx_screen+>00cb         ; LD DE,$40CB       ;
       bl   @title_screen_print       ; CALL $FEE4        ; }
       li   hl,title_screen_keys       ; LD HL,$FEFC       ; Points to #R$FEFC and sends it to #R$FEE4.
       li   de,zx_screen+>082b         ; LD DE,$482B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_joystick   ; LD HL,$FF06       ; Points to #R$FF06 and sends it to #R$FEE4.
       li   de,zx_screen+>088b         ; LD DE,$488B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_level      ; LD HL,$FF11       ; Points to #R$FF11 and sends it to #R$FEE4.
       li   de,zx_screen+>08eb         ; LD DE,$48EB       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_author     ; LD HL,$FF19       ; Points to #R$FF19 and sends it to #R$5B80.
       li   de,zx_screen+>1080         ; LD DE,$5083       ;
       li   bc,>0705                   ; LD BC,$0705       ;
       bl    @print_two_tone_text ; CALL $5B80        ;
       li   hl,title_screen_copyright  ; LD HL,$FF34       ; {Points to #R$FF34 and sends it to #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ;
       li   bc,>0704                   ; LD BC,$0704       ;
       bl    @print_two_tone_text ; CALL $5B80        ; }
       li   tmp0,bnwrag_module
       bl   @play_module
* Act on input.
title_screen_input:                    ; fe58
       movb @controller,a              ; LD A,($5CB0)      ; {If #R$5CB0 is zero (joystick) then #REGde=$0787 else #REGde=$8707. Then call the subroutine at #R$FE95.
       ; AND A                         ; AND A             ; The $07/ $87 correspond to white INK and white INK flashing for the selected control method.
       jeq  ts_select_kempston         ; JR Z,$FE63        ; #TABLE(default,centre,centre,centre,centre,centre)
       li   de,>8707                   ; LD DE,$8707       ; { =h Value | =h Ink | =h Paper | =h Bright | =h Flash }
       jmp  ts_call_flash              ; JR $FE66          ; { $07 | $07 | $00 | $00 | $00 }
ts_select_kempston:                    ; fe63
       li   de,>0787                   ; LD DE,$0787       ; { $87 | $07 | $00 | $00 | $01 }
ts_call_flash:                         ; fe66
       bl   @ts_flash_text            ; CALL $FE95        ; TABLE#}
       li   hl,controller              ; LD HL,$5CB0       ; Point #REGhl=#R$5CB0.
       li   tmp0,KEY_1
       bl   @ti_check_key
       jne  ts_set_keyboard
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1, 2, 3, 4, 5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {Jump to #R$FE86 if "1" is pressed.
;       jnc  ts_set_keyboard            ; JR NC,$FE86       ;
       li   tmp0,KEY_2
       bl   @ti_check_key
       jne  ts_set_kempston
;       ; RRA                           ; RRA               ; {Jump to #R$FE8B if "2" is pressed.
;       jnc  ts_set_kempston            ; JR NC,$FE8B       ;
       li   tmp0,KEY_N
       bl   @ti_check_key
       jne  ts_select_level
       li   tmp0,KEY_0
       bl   @ti_check_key
       jne  title_screen_return
       bl   @module_player
       bl   @ti_check_quit
       inc  @frame
       mov  @frame,tmp0
       andi tmp0,>0fff
       jne  title_screen_input
       bl   @toggle_author
       jmp  title_screen_input         ; JR $FE58          ; }
title_screen_return:
       .endproc

ts_set_keyboard:                       ; fe86
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ;
       jmp  title_screen_input         ; JR $FE58          ; }

ts_set_kempston:                       ; fe8b
       sb   a,a                        ; XOR A             ; {Writes $00 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ;
       jmp  title_screen_input         ; JR $FE58          ; }

ts_select_level:                       ; fe8f
       b    @level_select              ; JP $6380          ; }
*
ts_flash_text:                         ; fe95
       .proc
       li   bc,>0020                   ; LD BC,$0020       ; {ggg
       li   hl,zx_attributes+>012b     ; LD HL,$592B       ;
*      Attributes for 1 Keys
       movb d,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
*      Attributes for 2 Kempston
       a    bc,hl                      ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       movb @e,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ; }
*      Return
       .endproc                            ; RET               ; Return.

*********************************************************************
toggle_author:
       .proc
       mov  @frame,hl
       andi hl,>3000
       srl  hl,7
       mov  hl,bc
       ai   hl,title_screen_author
       srl  bc,5
       andi bc,1
       ai   bc,>0705
       li   de,zx_screen+>1080
       bl    @print_two_tone_text
       .endproc

*********************************************************************
* Draw bandits.
ts_draw_bandits:                        ; fea4
       .proc
*      Left bandit
       li   tmp0,>00c1
       clr  tmp1
       bl   @ti_draw_character
*      Right bandit
       li   tmp0,>00d9
       clr  tmp1
       bl   @ti_draw_character
;*      Left bandit bottom colors
;       li   tmp0,(>00c1+(8*32))*8
;       li   tmp1,>0020
;       li   tmp2,>0603
;       bl   @ti_draw_color_area
;*      Right bandit bottom colors
;       li   tmp0,(>00d9+(8*32))*8
;       li   tmp1,>0020
;       li   tmp2,>0603
;       bl   @ti_draw_color_area
       .endproc

*********************************************************************
*
title_screen_print:                    ; fee4
       .proc
       li   bc,>0702                   ; LD BC,$0702       ; {#REGb=$07, #REGc=$02 and jump to #R$5B80.
       bl   @print_two_tone_text       ; JP $5B80          ; }
       .endproc
*// title_screen_print

*********************************************************************
* Level Selection
*
* Used by the routine at #R$FE00.
level_select:                          ; 6380
       bl   @ti_clear_screen
       li   tmp0,>0500
       li   tmp1,>0028
       li   tmp2,>2008
       bl   @ti_draw_color_area
       li   tmp0,>0d00
       li   tmp1,>0020
       li   tmp2,>2003
       bl   @ti_draw_color_area
* Prints the labels to the screen.
       li   hl,level_select_one        ; LD HL,$64AC       ; {Pass #R$64AC to #R$647C (index "1").
       movb one,a                      ; LD A,$01          ;
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_three      ; LD HL,$64B3       ; {Pass #R$64B3 to #R$647C (index "2").
       movb @bytes+2,a                 ; LD A,$02          ;
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_six        ; LD HL,$64BA       ; {Pass #R$64BA to #R$647C (index "3").
       movb @bytes+3,a                 ; LD A,$03          ;
       bl   @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_choose       ; LD HL,$6492       ; {Points to #R$6492 and sends it to #R$5B80
       li   de,zx_screen+>0023         ; LD DE,$4023       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
* Prints the images to the screen.
       movb @bytes+37,a                ; LD A,$25          ; {Calls #R$643A with (#R$B450(draw | $25)) for index "1".
       movb one,b                      ; LD B,$01          ;
       bl   @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+8,a                 ; LD A,$08          ; {Calls #R$643A with (#R$7880(draw | $08)) for index "2".
       movb @bytes+2,b                 ; LD B,$02          ;
       bl   @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+25,a                ; LD A,$19          ; {Calls #R$643A with (#R$9B90(draw | $19)) for index "3".
       movb @bytes+3,b                 ; LD B,$03          ;
       bl   @level_select_graphics    ; CALL $643A        ; }

* Loop for getting user keyboard input.
       li   hl,level                   ; LD HL,$5CB1       ; Used later for setting the current level at #R$5CB1.
level_select_input:                    ; 63e5
       li   r0,KEY_1
       bl   @ti_check_key
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1-2-3-4-5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {If "1" is pressed, jump to #R$63F4.
       jne  level_select_level_1       ; JR NC,$63F4        ; }
       li   r0,KEY_2
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "2" is pressed, jump to #R$6405.
       jne  level_select_level_3       ; JR NC,$6405        ; }
       li   r0,KEY_3
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "3" is pressed, jump to #R$6416.
       jne  level_select_level_6       ; JR NC,$6416       ; }
       bl   @module_player
       jmp  level_select_input         ; JR $63E5          ; Cycle back to #R$63E5.
* Act on level being selected.
level_select_level_1:                  ; 63f4
       movb one,*hl                    ; LD (HL),$01       ; {Store $01 at #R$5CB1 and call #R$6427 with
       movb @bytes+>26,a               ; LD A,$26          ; (#R$B660(shot | $26)) for index "1".
       movb @bytes+>27,d
       movb one,b                      ; LD B,$01          ;
       bl   @ls_animate_shot           ; CALL $6427        ; }
       movb one,a                      ; LD A,$01          ; {Jump to #R$6457 with #REGhl=#R$64AC and #REGa=$01.
       li   hl,level_select_one        ; LD HL,$64AC       ;
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_3:                  ; 6405
       movb @bytes+2,*hl               ; LD (HL),$02       ; {Store $02 at #R$5CB1 and call #R$6427 with
       movb @bytes+>09,a               ; LD A,$09          ; (#R$7A90(shot | $09)) for index "2".
       movb @bytes+>29,d
       movb @bytes+2,b                 ; LD B,$02          ;
       bl   @ls_animate_shot           ; CALL $6427        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Jump to #R$6457 with #REGhl=#R$64B3 and #REGa=$02.
       li   hl,level_select_three      ; LD HL,$64B3       ;
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_6:                  ; 6416
       movb @bytes+3,*hl               ; LD (HL),$03       ; {Store $03 at #R$5CB1 and call #R$6427 with
       movb @bytes+>1a,a               ; LD A,$1A          ; (#R$9DA0(shot | $1A)) for index "3".
       movb @bytes+>28,d
       movb @bytes+3,b                 ; LD B,$03          ;
       bl   @ls_animate_shot           ; CALL $6427        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$6457 with #REGhl=#R$64BA and #REGa=$03.
       li   hl,level_select_six        ; LD HL,$64BA       ;
       b    @ls_text_flash             ; JP $6457          ; }

*********************************************************************
* Animates the selected bandit being shot.
ls_animate_shot:                       ; 6427
       .proc
       .push bc                        ; PUSH BC           ;
       bl   @level_select_graphics     ; CALL $643A        ; Call #R$643A.
       bl   @shot_sound_1              ; CALL $6500        ; Call #R$6500.
       movb @bytes+16,b                ; LD B,$10          ; {Short interrupt driven halt loop.
ls_animate_shot_halt_loop:             ; 6430
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6430        ; }
       jne  ls_animate_shot_halt_loop  ;
       .pop bc                         ; POP BC            ;
       movb d,a                        ; LD A,$27          ; {Call #R$643A with (#R$B870(floor | $27)).
       bl   @level_select_graphics     ; CALL $643A        ; }
       .endproc                        ; RET               ; Return.

*********************************************************************
* Prints the images to the screen.
* a=character index
* b=position
level_select_graphics:                 ; 643a
       .proc
       clr  tmp2
       movb b,tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>20
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character
       .endproc                        ; RET               ; Return.

*********************************************************************
* Flashes the selected level text.
*
* Jump - not call
ls_text_flash:                         ; 6457
       movb @bytes+8,b                 ; LD B,$08          ; {This prints #R$64C1 and the passed level copy alternately with a delay caused by a HALT loop
       movb a,@c                       ; LD C,A            ; (which continues execution after an interrupt is fired), the sequence repeats $08 times.
ls_text_flash_loop:                    ; 645a
       .push hl                        ; PUSH HL           ;
       .push bc                        ; PUSH BC           ;
       movb @c,a                       ; LD A,C            ;
       bl   @level_select_print       ; CALL $647C        ;
       movb @bytes+16,b                ; LD B,$10          ;
ls_flash_halt_loop_1:                  ; 6462
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6462        ;
       jne  ls_flash_halt_loop_1       ;
       li   hl,level_select_whitespace ; LD HL,$64C1       ;
       .pop bc                         ; POP BC            ;
       .push bc                        ; PUSH BC           ;
       movb @c,a                       ; LD A,C            ;
       bl   @level_select_print       ; CALL $647C        ;
       movb @bytes+16,b                ; LD B,$10          ;
ls_flash_halt_loop_2:                  ; 6470
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6470        ;
       jne  ls_flash_halt_loop_2       ;
       .pop bc                         ; POP BC            ;
       .pop hl                         ; POP HL            ;
       sb   one,b                      ; DJNZ $645A        ;
       jne  ls_text_flash_loop         ;
       movb @c,a                       ; LD A,C            ;
       bl   @level_select_print       ; CALL $647C         ; }
       .ret                            ; RET               ; Return.

*********************************************************************
* Print level select copy to the screen.
level_select_print:                    ; 647c
       .proc
       li   de,zx_screen+>1022         ; LD DE,$5022       ; {First, work out which screen position to use;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre)
       jeq  level_select_print_1       ; JR Z,$648B        ; { =h #REGa | =h Screen Address }
       li   de,zx_screen+>102d         ; LD DE,$502D       ; { $01 | $5022 }
       sb   one,a                      ; DEC A             ; { $02 | $502D }
       jeq  level_select_print_1       ; JR Z,$648B        ; { $03 | $5038 }
       li   de,zx_screen+>1038         ; LD DE,$5038       ; TABLE#}
level_select_print_1:                  ; 648b
       li   bc,>0702                   ; LD BC,$0702       ; {Then call the print routine at #R$5B80.
       bl    @print_two_tone_text      ; CALL $5B80        ; #TABLE(default,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .endproc                        ; RET               ; Return.

*********************************************************************
* High Score Entry.
*
* Used by the routine at #R$C7C0.
* ix=score_digit_6
draw_and_input_high_scores:            ; fa00
       .proc
       li   ix,score_digit_6           ; LD IX,$CD86       ; #REGhl=#R$CBB4 and
       bl    @high_scores              ; CALL $FA06        ;
       bl    @high_score_read_char      ; JP $FB62         ; Wait keypress
       .endproc

*********************************************************************
*
high_scores:                           ; fa06
       .proc
       movb @bytes+48,a                ; LD A,$30          ; {Writes "0" ($30 in ASCII) to #R$FB94.
       movb a,@high_score_line_buffer  ; LD ($FB94),A      ; }
       bl   @ti_clear_screen           ; CALL $FAD4        ; Call #R$FAD4.
       li   hl,zx_screen+>0040         ; LD HL,$4040       ; {Writes $4040 to #R$FBF0.
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ; }
       .push ix                        ; PUSH IX           ;
       bl   @hs_find_position         ; CALL $FC09        ; Call #R$FC09.
       movb a,@high_score_position     ; LD ($FB57),A      ;
       .pop ix                         ; POP IX            ;
       movb a,tmp0
                                       ; CP $1F            ;
       movb one,a                      ; LD A,$01          ;
       cb   tmp0,@bytes+31             ;                   ; Is position last?
       jne  new_high_score             ; JP Z,$FAB0        ;
       b    @draw_high_scores   ;
new_high_score:
       li   hl,zx_screen               ; LD HL,$4000       ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
*      Move name entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       bl   @hs_table_name_addr       ; CALL $FB19        ;
                                       ; LD DE,$61EF       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_name ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_name-1 ; POP HL            ;
       li   de,high_score_table_last_name+15 ; LD DE,$61FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Move score entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       sb   one,a                      ; DEC A             ;
       bl   @hs_table_score_address   ; CALL $FBFF        ;
                                       ; LD DE,$62F9       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_score ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_score-1 ; POP HL            ;
       li   de,high_score_table_last_score+5 ; LD DE,$62FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Copy new score into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       bl   @hs_table_score_address   ; CALL $FBFF        ;
       dec  hl                         ; DEC HL            ;
       .ex_de_hl                       ; EX DE,HL          ;
       .push ix                        ; PUSH IX           ;
       .pop hl                         ; POP HL            ;
       movb @bytes+6,b                 ; LD B,$06          ;
new_high_score_1:                      ; fa6f
       movb *hl,a                      ; LD A,(HL)         ;
       ab   @bytes+48,a                ; ADD A,$30         ;
       movb a,*de                      ; LD (DE),A         ;
       dec  de                         ; DEC DE            ;
       inc  hl                         ; INC HL            ;
       sb   one,b                      ; DJNZ $FA6F        ;
       jne  new_high_score_1           ;
*      Fill name buffer with spaces
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Overwrites the text at #R$5BC0 with spaces to "blank"
       li   de,high_score_name_buffer+1 ; LD DE,$5BC1      ; it out ($12 characters).
       li   bc,>0011                   ; LD BC,$0011       ;
       movb @bytes+32,*hl              ; LD (HL),$20       ;
       .ldir                           ; LDIR              ; }
       movb @b255,*hl                  ; LD (HL),$FF       ; Set a string termination character ($FF) at the end of
* Print "Write your name please"                           ; the string.
       bl   @ti_clear_screen           ; CALL $FAD4        ;
       li   hl,high_score_title        ; LD HL,$FB78       ; {Points to #R$FB78 and sends it to #R$5B80.
       li   de,zx_screen+>0802         ; LD DE,$4802       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
* Input name
       bl   @high_score_input_name    ; CALL $FB26        ;
       bl   @ti_clear_screen           ; CALL $FAD4        ;
* Copy name into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       bl   @hs_table_name_addr       ; CALL $FB19        ; a--
       .ex_de_hl                       ; EX DE,HL          ;
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ;
       li   bc,>0010                   ; LD BC,$0010       ;
       .ldir                           ; LDIR              ;
* Determine from which position to draw
       sb   @bytes+5,a                 ; SUB $05           ; position - 1 - 5
       jgt  draw_high_scores_2         ; JR NC,$FABD       ; If 5 or more higher scores start from position - 5
       jmp  draw_high_scores_1         ; JR $FABC          ; Otherwise start from top
draw_high_scores:                      ; _fab0
       li   hl,high_score_sub_head     ; LD HL,$FBB5       ; {Points to #R$FBB5 and sends it to #R$5B80.
       li   de,zx_screen               ; LD DE,$4000       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
draw_high_scores_1:                    ; fabc
       sb   a,a                        ; XOR A             ;
draw_high_scores_2:                    ; fabd
       ab   one,a                      ; INC A             ;
       movb @bytes+10,b                ; LD B,$0A          ;
draw_high_scores_3:                    ; fac0
       .push bc                        ; PUSH BC           ;
       .push af                        ; PUSH AF           ;
       bl   @hs_setup_line_buffer     ; CALL $FAE2        ;
       li   de,high_score_line_buffer  ; LD DE,$FB94       ;
       bl   @advance_2_rows_and_print ; CALL $FBD5        ;
       .pop af                         ; POP AF            ;
       .pop bc                         ; POP BC            ;
       ab   one,a                      ; INC A             ;
       cb   a,@bytes+32                ; CP $1F            ;
       jeq  draw_high_scores_4         ; RET Z             ;
       sb   one,b                      ; DJNZ $FAC0        ;
       jne  draw_high_scores_3         ;
draw_high_scores_4:
       .endproc                        ; RET               ; Return from high_scores

*********************************************************************
hs_setup_line_buffer:                  ; fae2
       .proc
       movb a,@c                       ; LD C,A            ;
       li   hl,high_score_line_buffer  ; LD HL,$FB94       ;
       sb   @bytes+10,a                ; SUB $0A           ;
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+49,*hl              ; LD (HL),$31       ;
       sb   @bytes+10,a                ; SUB $0A           ;
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+50,*hl              ; LD (HL),$32       ;
       sb   @bytes+10,a                ; SUB $0A           ;
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+51,*hl              ; LD (HL),$33       ;
       sb   @bytes+10,a                ; SUB $0A           ;
hs_setup_line_buffer_1:                ; fafa
       ab   @bytes+10,a                ; ADD A,$0A         ;
       inc  hl                         ; INC HL            ;
       ab   @bytes+48,a                ; ADD A,$30         ;
       movb a,*hl                      ; LD (HL),A         ;
       movb @c,a                       ; LD A,C            ;
       bl   @hs_table_name_addr      ; CALL $FB19        ;
       li   de,high_score_line_buffer+6 ; LD DE,$FB9A       ;
       li   bc,>0010                   ; LD BC,$0010       ;
       .ldir                           ; LDIR              ;
       ai   de,4                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
       bl   @hs_table_score_address    ; CALL $FBFF        ;
       li   bc,>0006                   ; LD BC,$0006       ;
       .ldir                           ; LDIR              ;
       .endproc                        ; RET               ;

*********************************************************************
* Works out where in the high score table to place the score.
hs_table_name_addr:                    ; fb19
       sb   one,a                      ; DEC A             ; {Using #R$6000 as a base, work out where to place the new score.
       movb a,@l                       ; LD L,A            ; #LIST
       sb   h,h                        ; LD H,$00          ; { Decrease $1B by one... }
       sla  hl,4                       ; ADD HL,HL         ; { Loads $1A as the low-order byte; #REGhl=$001A }
                                       ; ADD HL,HL         ; { Times by $10; #REGhl=$1A0 }
                                       ; ADD HL,HL         ; { Add $6000=#R$61A0 }
                                       ; ADD HL,HL         ; LIST#
                                       ; LD DE,$6000       ;
       ai   hl,high_score_table        ; ADD HL,DE         ; }
       rt                              ; RET               ; Return.

*********************************************************************
high_score_input_name:                 ; fb26
       .proc
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Stores #R$5BC0 at #R$FB55.
high_score_input_name_1:               ; fb29
       mov  hl,@high_score_name_buffer_addr ; LD ($FB55),HL     ;
       bl   @hs_print_name_buffer          ; CALL $FBF2        ; }
       bl   @high_score_read_char     ; CALL $FB62        ;
       mov  @high_score_name_buffer_addr,hl ; LD HL,($FB55)     ;
       cb   a,@bytes+13                ; CP $0D            ;
       jne  !                          ; RET Z             ;
       .endproc                        ;
!
       cb   a,@bytes+8                 ; CP $0C            ;
       jeq  high_score_input_name_3    ; JR Z,$FB58        ;
                                       ; LD C,A            ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer+16 ; CP $D1          ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; LD A,C            ;
       cb   a,@bytes+32                ; CP $20            ;
       jeq  high_score_input_name_2    ; JR Z,$FB51        ;
       cb   a,@bytes+65                ; CP $61            ;
       jl   high_score_input_name_1    ; JR C,$FB29        ;
       cb   a,@bytes+91                ; CP $7B            ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; SUB $20           ;
high_score_input_name_2:               ; fb51
       movb a,*hl+                     ; LD (HL),A         ;
                                       ; INC HL            ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

high_score_input_name_3:               ; fb58              ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer  ; CP $C1            ;
       jle  high_score_input_name_1    ; JR C,$FB29        ;
       dec  hl                         ; DEC HL            ;
       movb @bytes+32,*hl              ; LD (HL),$20       ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

high_score_name_buffer_addr:           ; fb55              ;
       data 0
high_score_position:                   ; fb57
       byte 0                          ; RRA               ;

*********************************************************************
* Returns a single keypress.
high_score_read_char:                  ; fb62
       .proc                           ; LD HL,$5C08       ; {#HTML(Keep looping around until <em>any</em> input is detected. This is achieved by writing $00 to
                                       ; LD (HL),$00       ; <a href="https://skoolkid.github.io/rom/asm/5C08.html">LAST_K</a> and looping until it's non-zero.)
high_score_read_char_loop:             ; fb67
       bl   @ti_vsync                  ; HALT              ;
       bl   @ti_keyscan                ; LD A,(HL)         ;
       movb  a,a                       ; AND A             ;
       jeq  high_score_read_char_loop  ; JR Z,$FB67        ; }
       .endproc                        ; RET               ; }

*********************************************************************
* Routine at FBD5
*
* Used by the routine at #R$FA00.
advance_2_rows_and_print:              ; fbd5
       .proc
       mov  @high_score_screen_addr,hl ; LD HL,($FBF0)     ;
       movb @l,a                       ; LD A,L            ;
       ab   @bytes+64,a                ; ADD A,$40         ;
       jnc  !
       bl   @add_8_to_h                ; CALL C,$FBEA      ;
!      movb a,@l                       ; LD L,A            ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
       li   bc,>0705                   ; LD BC,$0705       ;
       .ex_de_hl                       ; EX DE,HL          ;
       bl    @print_two_tone_text      ; CALL $5B80        ;
       .endproc                        ; RET               ;

*********************************************************************
add_8_to_h:                            ; fbea
       movb h,a                        ; LD A,H            ;
       ab   @bytes+8,a                 ; ADD A,$08         ;
       movb a,h                        ; LD H,A            ;
       sb   a,a                        ; XOR A             ;
       rt                              ; RET               ;

high_score_screen_addr:                ; fbf0:
       data >50c0                                          ; Cache

*********************************************************************
* This entry point is used by the routine at #R$FA00.
hs_print_name_buffer:                  ; fbf2
       .proc
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Points to #R$5BC0 and sends it to #R$5B80.
       li   de,zx_screen+>0887         ; LD DE,$4887       ; #TABLE(default,centre)
       li   bc,>0705                   ; LD BC,$0705       ; { =h Value | =h Ink | =h Paper | =h Bright }
       bl    @print_two_tone_text      ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
       .endproc                        ; RET               ; { $05 | $05 | $00 | $00 }
                                                           ; TABLE#}
*********************************************************************
* This entry point is used by the routine at #R$FA00.
* Calculate hl = >6200 + 6 * a
hs_table_score_address:                ; fbff
       clr  hl
       movb a,h                        ; LD C,A            ; x1
                                       ; XOR A             ;
       sla  hl,1                       ; ADD A,C           ; x2
       ab   a,h                        ; ADD A,C           ; x3
       sla  hl,1                       ; ADD A,C           ; x6
       swpb hl                         ; ADD A,A           ;
                                       ; LD L,A            ;
       ai   hl,high_score_table_scores  ; LD H,$62          ;
       rt                             ; RET               ;

*********************************************************************
* This entry point is used by the routine at #R$FA00.
* ix points to new potential high score BCD low endian
* Returns position in a
hs_find_position:                      ; fc09
       .proc
       li   hl,high_score_table_scores-6 ; LD HL,$61FA       ;
       li   bc,>0006                   ; LD BC,$0006       ;
       sb   @e,@e                      ; LD E,$00          ;
hs_find_next_digit:                    ; fc11
       ab   one,@e                     ; INC E             ;
       movb @e,a                       ; LD A,E            ;
       cb   a,@bytes+31                ; CP $1F            ;
       jhe  hs_find_return             ; RET NC            ;
       a    bc,hl                      ; ADD HL,BC         ;
* hs_cmp_1st_digit:
       movb @5(ix),a                   ; LD A,(IX+$05)     ;
       ab   @bytes+48,a                ; ADD A,$30         ;
       cb   a,*hl                      ; CP (HL)           ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_2nd_digit           ; JR Z,$FC23        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_2nd_digit:                      ; fc23
       movb @4(ix),a                   ; LD A,(IX+$04)     ;
       ab   @bytes+48,a                ; ADD A,$30         ;
                                       ; INC HL            ;
       cb   a,@1(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_3rd_digit           ; JR Z,$FC31        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_3rd_digit:                      ; fc31
       movb @3(ix),a                   ; LD A,(IX+$03)     ;
       ab   @bytes+48,a                ; ADD A,$30         ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@2(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_4th_digit           ; JR Z,$FC41        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_4th_digit:                      ; fc41
       movb @2(ix),a                   ; LD A,(IX+$02)     ;
       ab   @bytes+48,a                ; ADD A,$30         ;
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@3(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_5th_digit           ; JR Z,$FC53        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_5th_digit:                      ; fc53
       movb @1(ix),a                   ; LD A,(IX+$01)     ;
       ab   @bytes+48,a                ; ADD A,$30         ;
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@4(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jhe  hs_find_return             ; JR NC,$FC65       ;
       jmp  hs_find_next_digit         ; JR $FC11          ;
hs_find_return:                        ; fc65
       movb @e,a                       ; LD A,E            ;
       .endproc                        ; RET               ;

