**
*      West bank for the TI-99/4A

       limi 0
       lwpi wrksp
       bl   @setup_environment
       b    @start

buffer_at_5b00:                        ; Not used as buffer any longer
       bss  >40                        ; just some zeros to use for clearing

;buffer_at_5b80:
;       bss  >80

* Draw Text (alias).
* 
* This is an alias for a jump to #R$CBD2.
print_two_tone_text_alias:             ; 5b80
       b    @print_two_tone_text       ; JP $CBD2          ; 

* Displays The "Life" Images.
* 
* An alias for a jump to #R$CC5A.
draw_life_images_alias:                ; 5b83
       b    @draw_life_images          ; JP $CC5A          ;

* Lives Memory Address.
lives_addr:                            ; 5b86
       data lives                                                    ; The 16 bit memory location for the address that holds
                                                                     ; how many lives the player has remaining.
* Jump Controls.
* 
* Loads the 16 bit address stored at #R$CE12 into #REGhl and jumps to it.
jump_to_control_method:                ; 5b88
       mov  @control_routine_alias,hl  ; LD HL,($CE12)     ; 
       b    *hl                        ; JP (HL)           ;

* Scoring Preparation (alias).
* 
* Used by the routine at #R$C607.
scoring_prep_alias:                    ; 5b8c
       b    @scoring_for_door              ; JP $CDDC          ;

* Character Address (alias).
* 
* An alias for #R$D5B0 which returns the 16 bit memory location of a character
* from a given character index.
character_addr_alias:                  ; 5b8f
       b    @character_addr            ; JP $D5B0          ; 

* Draw Character (alias).
* 
* Used by the routines at #R$6380, #R$C661, #R$C720 and #R$FE00.
draw_character:                        ; 5b92
       b    @copy_routine              ; JP $D5E6          ; 

* Merge Shot (alias).
merge_shot_alias:                      ; 5b95
       b    @merge_shot                ; JP $D5FA          ; 

* Display The "Score" Images (alias).
* 
* Used by the routines at #R$C422 and #R$C607.
draw_score_alias:                      ; 5b98
       b    @draw_score                ; JP $CD90          ; 

* Dueller Number 1.
* 
* Populated initially by #R$C3EA.
dueller_1:                             ; 5bc0
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >00                                                      ; Dueller timer.
       byte >00
       byte >00                                                      ; Dueller position.
       byte >00,>00                                                  ; Screen position above dueller to display "EXTRA" or
                                                                     ; points.
       byte >00
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >00
       byte >00                                                      ; Current frame?
       byte >00                                                      ; Character index frame 1.
       byte >00                                                      ; Character index frame 2.
       byte >00                                                      ; Character index frame 3.
       byte >00
       byte >00
       byte >00
       byte >00

* Dueller Number 2.
* 
* Populated initially by #R$C3EA.
dueller_2:                             ; 5bd1
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >00                                                      ; Dueller timer.
       byte >00
       byte >00                                                      ; Dueller position.
       byte >00,>00                                                  ; Screen position above dueller to display "EXTRA" or
                                                                     ; points.
       byte >00
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >00
       byte >00                                                      ; Current frame?
       byte >00                                                      ; Character index frame 1.
       byte >00                                                      ; Character index frame 2.
       byte >00                                                      ; Character index frame 3.
       byte >00
       byte >00
       byte >00
       byte >00

* Dueller Number 3.
* 
* Populated initially by #R$C3EA.
dueller_3:                             ; 5be2
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >00                                                      ; Dueller timer.
       byte >00
       byte >00                                                      ; Dueller position.
       byte >00,>00                                                  ; Screen position above dueller to display "EXTRA" or
                                                                     ; points.
       byte >00
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >00
       byte >00                                                      ; Current frame?
       byte >00                                                      ; Character index frame 1.
       byte >00                                                      ; Character index frame 2.
       byte >00                                                      ; Character index frame 3.
       byte >00
       byte >00
       byte >00
       byte >00

* Control method
* 
* Whether to utilise keyboard or joystick for input.
controller:                            ; 5cb0
       byte >01
* #TABLE(default,centre)
* { =h Value | =h Method }
* { $00 | Kempston }
* { $01 | Keyboard }
* TABLE#

* Current Level
level:                                 ; 5cb1
       byte >01

* High Score Table
high_score_table:                       ; 6000
       text 'LUCKY LUCKE     '
       text 'BILLY THE KID   '
       text 'BUFALO BILL     '
       text 'CALAMITY JANE   '
       text 'JESSE JAMES     '
       text 'JOE DALTON      '
       text 'THE GOOD        '
       text 'JACK THE FAST   '
       text 'DAVY CROCKETT   '
       text 'PANCHO VILLA    '
       text 'ALVARO MATEOS H '
       text 'JACK DALTON     '
       text 'THOMY WILLIANS  '
       text 'LIBERTY B       '
       text 'THE UGLY        '
       text 'GRAL GRANT      '
       text 'JIMMY THE BLACK '
       text 'WILLIAM DALTON  '
       text 'THE BAD         '
       text 'GRAL CASTER     '
       text 'FRANK MATA      '
       text 'KIT WILLIANS    '
       text 'ALBERT THE HEAVY'
       text 'THE SCREW MAN   '
       text 'AVERELL DALTON  '
       text 'ANDREW THE BELL '
       text 'GRAL LEE        '
       text 'THE CHICKEN MAN '
       text 'THE BLONDE GIRL '
       text 'TOM SMITH       '
high_score_table_last_name:
       text 'UNKNOWN         '
high_score_table_scores:               ; 6200
       text '275430'
       text '265980'
       text '263230'
       text '258980'
       text '254070'
       text '255430'
       text '250990'
       text '245430'
       text '240510'
       text '241610'
       text '231940'
       text '226450'
       text '226520'
       text '223320'
       text '213230'
       text '204510'
       text '200640'
       text '195910'
       text '196900'
       text '193030'
       text '188320'
       text '176510'
       text '164760'
       text '157110'
       text '149070'
       text '139970'
       text '135150'
       text '129110'
       text '129730'
       text '125960'                   ; Tom Smith
high_score_table_last_score:
       text '000000'
;       Never used
;       text '115040'
;       text '105590'
;       text '102670'
;       text '099200'
;       text '096960'
;       text '088620'
;       text '084720'
;       text '078000'
;       text '069990'
;       text '063130'
;       text '058530'
;       text '000500'

* Level Selection
* 
* Used by the routine at #R$FE00.
level_select:                          ; 6380
;       li   de,buffer_at_5b80          ; LD DE,$5B80       ; {#REGhl points to $5B80 on entry as #REGde is also $5B80
;       li   bc,>0040                   ; LD BC,$0040       ; - this does nothing, it just creates a very short pause.
;       .ldir                           ; LDIR              ; }
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of the screen bufffer
;       li   de,zx_screen+1             ; LD DE,$4001       ; (i.e. "blanks it").
;       li   bc,>1aff                   ; LD BC,$1AFF       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
       li   tmp0,>0500
       li   tmp1,>0028
       li   tmp2,>2008
       bl   @ti_draw_color_area
;       li   hl,zx_attributes+>00a0     ; LD HL,$58A0       ; {Writes $28 to $58A0 in the attribute buffer $100 times.
;       li   de,zx_attributes+>00a1     ; LD DE,$58A1       ; #TABLE(default,centre)
;       li   bc,>0100                   ; LD BC,$0100       ; { =h Value | =h Ink | =h Paper | =h Bright }
;       movb @bytes+40,*hl              ; LD (HL),$28       ; { $28 | $00 | $05 | $00 }
;       .ldir                           ; LDIR              ; TABLE#}
       li   tmp0,>0d00
       li   tmp1,>0020
       li   tmp2,>2003
       bl   @ti_draw_color_area
;       movb @bytes+32,*hl              ; LD (HL),$20       ; {...and $20 to the attribute buffer another $5F times (following on from the previous location).
;       li   bc,>005f                   ; LD BC,$005F       ; #TABLE(default,centre)
;       .ldir                           ; LDIR              ; { =h Value | =h Ink | =h Paper | =h Bright }
;                                                           ; { $20 | $00 | $04 | $00 }
;                                                           ; TABLE#}
* Prints the labels to the screen.
       li   hl,level_select_one        ; LD HL,$64AC       ; {Pass #R$64AC to #R$647C (index "1").
       movb one,a                      ; LD A,$01          ; 
       .call @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_three      ; LD HL,$64B3       ; {Pass #R$64B3 to #R$647C (index "2").
       movb @bytes+2,a                 ; LD A,$02          ; 
       .call @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_six        ; LD HL,$64BA       ; {Pass #R$64BA to #R$647C (index "3").
       movb @bytes+3,a                 ; LD A,$03          ; 
       .call @level_select_print       ; CALL $647C        ; }
       li   hl,level_select_copy       ; LD HL,$6492       ; {Points to #R$6492 and sends it to #R$5B80
       li   de,zx_screen+>0023         ; LD DE,$4023       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
* Prints the images to the screen.
       movb @bytes+37,a                ; LD A,$25          ; {Calls #R$643A with (#R$B450(draw | $25)) for index "1".
       movb one,b                      ; LD B,$01          ; 
       .call @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+8,a                 ; LD A,$08          ; {Calls #R$643A with (#R$7880(draw | $08)) for index "2".
       movb @bytes+2,b                 ; LD B,$02          ; 
       .call @level_select_graphics    ; CALL $643A        ; }
       movb @bytes+25,a                ; LD A,$19          ; {Calls #R$643A with (#R$9B90(draw | $19)) for index "3".
       movb @bytes+3,b                 ; LD B,$03          ; 
       .call @level_select_graphics    ; CALL $643A        ; }

* Loop for getting user keyboard input.
       li   hl,level                   ; LD HL,$5CB1       ; Used later for setting the current level at #R$5CB1.
level_select_input:                    ; 63e5
       li   r0,KEY_1
       bl   @ti_check_key
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1-2-3-4-5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {If "1" is pressed, jump to #R$63F4.
       jne  level_select_level_1       ; JR NC,$63F4       ; TODO: check code. }
       li   r0,KEY_2
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "2" is pressed, jump to #R$6405.
       jne  level_select_level_3       ; JR NC,$6405       ; TODO: check code. }
       li   r0,KEY_3
       bl   @ti_check_key
;       ; RRA                           ; RRA               ; {If "3" is pressed, jump to #R$6416.
       jne  level_select_level_6       ; JR NC,$6416       ; TODO: check code. }
       jmp  level_select_input         ; JR $63E5          ; Cycle back to #R$63E5.
* Act on level being selected.
level_select_level_1:                  ; 63f4
       movb one,*hl                    ; LD (HL),$01       ; {Store $01 at #R$5CB1 and call #R$6427 with
       movb @bytes+38,a                ; LD A,$26          ; (#R$B660(shot | $26)) for index "1".
       movb one,b                      ; LD B,$01          ; 
       .call @ls_animate_shot          ; CALL $6427        ; }
       movb one,a                      ; LD A,$01          ; {Jump to #R$6457 with #REGhl=#R$64AC and #REGa=$01.
       li   hl,level_select_one        ; LD HL,$64AC       ; 
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_3:                  ; 6405
       movb @bytes+2,*hl               ; LD (HL),$02       ; {Store $02 at #R$5CB1 and call #R$6427 with
       movb @bytes+9,a                 ; LD A,$09          ; (#R$7A90(shot | $09)) for index "2".
       movb @bytes+2,b                 ; LD B,$02          ; 
       .call @ls_animate_shot          ; CALL $6427        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Jump to #R$6457 with #REGhl=#R$64B3 and #REGa=$02.
       li   hl,level_select_three      ; LD HL,$64B3       ; 
       b    @ls_text_flash             ; JP $6457          ; }
level_select_level_6:                  ; 6416
       movb @bytes+3,*hl               ; LD (HL),$03       ; {Store $03 at #R$5CB1 and call #R$6427 with
       movb @bytes+26,a                ; LD A,$1A          ; (#R$9DA0(shot | $1A)) for index "3".
       movb @bytes+3,b                 ; LD B,$03          ; 
       .call @ls_animate_shot          ; CALL $6427        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$6457 with #REGhl=#R$64BA and #REGa=$03.
       li   hl,level_select_six        ; LD HL,$64BA       ; 
       b    @ls_text_flash             ; JP $6457          ; }
* Animates the selected bandit being shot.
ls_animate_shot:                       ; 6427
       .push bc                        ; PUSH BC           ; 
       .call @level_select_graphics    ; CALL $643A        ; Call #R$643A.
       .call @shot_sound_1_alias       ; CALL $6500        ; Call #R$6500.
       movb @bytes+16,b                ; LD B,$10          ; {Short interrupt driven halt loop.
ls_animate_shot_halt_loop:             ; 6430
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6430        ; }
       jne  ls_animate_shot_halt_loop  ;                   
       .pop bc                         ; POP BC            ; 
       movb @bytes+39,a                ; LD A,$27          ; {Call #R$643A with (#R$B870(floor | $27)).
       .call @level_select_graphics    ; CALL $643A        ; }
       .ret                            ; RET               ; Return.

* Prints the images to the screen.
* a=character index
* b=position
level_select_graphics:                 ; 643a
       clr  tmp2
       movb b,tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>20
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character_pattern
;       .push bc                        ; PUSH BC           ; {Stash the current counter and convert the accumulator
;       .call @character_addr_alias     ; CALL $5B8F        ; which is holding a character ID into their memory
;                                                           ; location.}
;       .ex_de_hl                       ; EX DE,HL          ;
;       .pop af                         ; POP AF            ;
;       li   hl,zx_screen+>00a2         ; LD HL,$40A2       ; {Work out which screen position to use;
;       sb   one,a                      ; DEC A             ; #TABLE(default,centre)
;       jeq  ls_graphics_skip           ; JR Z,$644F        ; { =h #REGa | =h Screen Address }
;       li   hl,zx_screen+>00ad         ; LD HL,$40AD       ; { $01 | $40A2 }
;       sb   one,a                      ; DEC A             ; { $02 | $40AD }
;       jeq  ls_graphics_skip           ; JR Z,$644F        ; { $03 | $40B8 }
;       li   hl,zx_screen+>00b8         ; LD HL,$40B8       ; TABLE#}
;ls_graphics_skip:                      ; 644f
;       movb @bytes+88,b                ; LD B,$58          ; {Set the dimensions and call #R$5B92.
;       movb @bytes+6,@c                ; LD C,$06          ;
;       .call @draw_character           ; CALL $5B92        ; }
       .ret                            ; RET               ; Return.
* Flashes the selected level text.
ls_text_flash:                         ; 6457
       movb @bytes+8,b                 ; LD B,$08          ; {This prints #R$64C1 and the passed level copy alternately with a delay caused by a HALT loop
       movb a,@c                       ; LD C,A            ; (which continues execution after an interrupt is fired), the sequence repeats $08 times.
ls_text_flash_loop:                    ; 645a
       .push hl                        ; PUSH HL           ; 
       .push bc                        ; PUSH BC           ; 
       movb @c,a                       ; LD A,C            ; 
       .call @level_select_print       ; CALL $647C        ; 
       movb @bytes+16,b                ; LD B,$10          ; 
ls_flash_halt_loop_1:                  ; 6462
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6462        ; 
       jne  ls_flash_halt_loop_1       ;                   
       li   hl,level_select_whitespace ; LD HL,$64C1       ; 
       .pop bc                         ; POP BC            ; 
       .push bc                        ; PUSH BC           ; 
       movb @c,a                       ; LD A,C            ; 
       .call @level_select_print       ; CALL $647C        ; 
       movb @bytes+16,b                ; LD B,$10          ; 
ls_flash_halt_loop_2:                  ; 6470
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $6470        ; 
       jne  ls_flash_halt_loop_2       ;                   
       .pop bc                         ; POP BC            ; 
       .pop hl                         ; POP HL            ; 
       sb   one,b                      ; DJNZ $645A        ; 
       jne  ls_text_flash_loop         ;                   
       movb @c,a                       ; LD A,C            ; 
       .call @level_select_print       ; CALL $647C        ; }
       .ret                            ; RET               ; Return.
* Print level select copy to the screen.
level_select_print:                    ; 647c
       li   de,zx_screen+>1022         ; LD DE,$5022       ; {First, work out which screen position to use;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre)
       jeq  _648b                      ; JR Z,$648B        ; { =h #REGa | =h Screen Address }
       li   de,zx_screen+>102d         ; LD DE,$502D       ; { $01 | $5022 }
       sb   one,a                      ; DEC A             ; { $02 | $502D }
       jeq  _648b                      ; JR Z,$648B        ; { $03 | $5038 }
       li   de,zx_screen+>1038         ; LD DE,$5038       ; TABLE#}
_648b:
       li   bc,>0702                   ; LD BC,$0702       ; {Then call the print routine at #R$5B80.
       .call @print_two_tone_text_alias ; CALL $5B80        ; #TABLE(default,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Level Selection Text
level_select_copy:                     ; 6492
       text 'CHOOSE THE LEVEL PREFERED',>ff                          ; "CHOOSE THE LEVEL PREFERED"
level_select_one:                      ; 64ac
       text ' ONE  ',>ff                                             ; "ONE"
level_select_three:                    ; 64b3
       text ' THREE',>ff                                             ; "THREE"
level_select_six:                      ; 64ba
       text '  SIX ',>ff                                             ; "SIX"
level_select_whitespace:               ; 64c1
       text '      ',>ff                                             ; "WHITESPACE"

* Sounds.
* 
* Used by the routines at #R$6380, #R$C422 and #R$D307.
shot_sound_1_alias:                    ; 6500
       jmp  shot_sound_1               ; JR $6537          ; 
* This entry point is used by the routines at #R$C000 and #R$D307.
shot_sound_2_alias:                    ; 6502
       jmp  shot_sound_2               ; JR $653F          ; 
* This entry point is used by the routine at #R$D307.
shot_sound_3_alias:                    ; 6504
       jmp  shot_sound_3               ; JR $6547          ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       data 8224                                                     ; 
       byte >20,>00,>00,>00,>00                                      ; 
* Sound data.
data_sound_1:                          ; 651f
       data >0A02                                                    ; 
       data >4060                                                    ;
       data >0803                                                    ; 
       data 192                                                      ; 
data_sound_2:                          ; 6527
       data >0A02                                                    ; 
       data >2040                                                    ; 
       data >0803                                                    ; 
       data >80f0                                                    ;
data_sound_3:                          ; 652f
       data >0A02                                                    ; 
       data >4050                                                 ;
       data >0803                                                    ; 
       data >8000                                                    ;
* Shot sound 1.
shot_sound_1:                          ; 6537
       li   ix,data_sound_1            ; LD IX,$651F       ; {Calls #R$654F using #R$651F.
       .call @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 2.
shot_sound_2:                          ; 653f
       li   ix,data_sound_2            ; LD IX,$6527       ; {Calls #R$654F using #R$6527.
       .call @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
* Shot sound 3.
shot_sound_3:                          ; 6547
       li   ix,data_sound_3            ; LD IX,$652F       ; {Calls #R$654F using #R$652F.
       .call @play_shot_sound          ; CALL $654F        ; }
       .ret                            ; RET               ; Return.
play_shot_sound:                       ; 654f
       .call @shot_sound               ; CALL $655E        ; Call #R$655E.
       inc  ix                         ; INC IX            ; {Increase #REGix by 4.
       inc  ix                         ; INC IX            ; 
       inc  ix                         ; INC IX            ; 
       inc  ix                         ; INC IX            ; }
       .call @shot_sound               ; CALL $655E        ; Call #R$655E.
       .ret                            ; RET               ; Return.
shot_sound:                            ; 655e
       .ret                            ; TODO
       movb *ix,@e                     ; LD E,(IX+$00)     ; {jjj
       movb @bytes+24,a                ; LD A,$18          ; 
_6563:
       li   tmp0,24*256                ; XOR $18           ; 
       xor  tmp0,a                     ;                   
       ; OUT ($FE),A                   ; OUT ($FE),A       ; 
       movb @1(ix),@c                  ; LD C,(IX+$01)     ; 
_656a:
       li   tmp0,24*256                ; XOR $18           ; 
       xor  tmp0,a                     ;                   
       ; OUT ($FE),A                   ; OUT ($FE),A       ; }
       movb @2(ix),b                   ; LD B,(IX+$02)     ; 
shot_sound_loopback:                   ; 6571
       sb   one,b                      ; DJNZ $6571        ; 
       jne  shot_sound_loopback        ;                   
       sb   one,@c                     ; DEC C             ; 
       jne  _656a                      ; JR NZ,$656A       ; 
       movb @3(ix),d                   ; LD D,(IX+$03)     ; 
_6579:
       sb   one,d                      ; DEC D             ; 
       jne  _6579                      ; JR NZ,$6579       ; 
       sb   one,@e                     ; DEC E             ; 
       jne  _6563                      ; JR NZ,$6563       ; 
       .ret                            ; RET               ; Return.

* Routine at 6600
* 
* Used by the routine at #R$D3EA.
;scroll_right:
;       movb @bytes+11,b                ; LD B,$0B          ;
;scroll_right_loop:
;       .push bc                        ; PUSH BC           ;
;       .call @_6610                    ; CALL $6610        ;
;       .call @_6647                    ; CALL $6647        ;
;       .call @_6647                    ; CALL $6647        ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $6602        ;
;       jne  scroll_right_loop                      ;
       .ret                            ; RET               ;
;_6610:
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       li   hl,zx_screen+>006a         ; LD HL,$406A       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_6664                    ; CALL $6664        ;
;       li   hl,zx_screen+>007e         ; LD HL,$407E       ;
;       li   de,zx_screen+>007f         ; LD DE,$407F       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_66a0                    ; CALL $66A0        ;
;       li   hl,zx_attributes+>01ea     ; LD HL,$59EA       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_6681                    ; CALL $6681        ;
;       li   hl,zx_attributes+>01fe     ; LD HL,$59FE       ;
;       li   de,zx_attributes+>01ff     ; LD DE,$59FF       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_668e                    ; CALL $668E        ;
;       .ret                            ; RET               ;
;_6647:
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       li   hl,zx_screen+>102a         ; LD HL,$502A       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_6664                    ; CALL $6664        ;
;       li   hl,zx_screen+>103e         ; LD HL,$503E       ;
;       li   de,zx_screen+>103f         ; LD DE,$503F       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_66a0                    ; CALL $66A0        ;
;       .ret                            ; RET               ;
;       .ret                            ; RET               ;
;_6664:
;       movb @bytes+8,@c                ; LD C,$08          ;
;_6666:
;       movb *hl,a                      ; LD A,(HL)         ;
;       movb a,*ix                      ; LD (IX+$00),A     ;
;       inc  ix                         ; INC IX            ;
;       ab   one,h                      ; INC H             ;
;       sb   one,@c                     ; DEC C             ;
;       jne  _6666                      ; JR NZ,$6666       ;
;       movb h,a                        ; LD A,H            ;
;       sb   @bytes+8,a                 ; SUB $08           ;
;       movb a,h                        ; LD H,A            ;
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jeq  !                          ; CALL NZ,$66D2     ;
;       .call @_66d2                    ;
;!
;       sb   one,b                      ; DJNZ $6664        ;
;       jne  _6664                      ;
;       .ret                            ; RET               ;
;_6681:
;       movb *hl,a                      ; LD A,(HL)         ;
;       movb a,*ix                      ; LD (IX+$00),A     ;
;       li   de,>ffe0                   ; LD DE,$FFE0       ; -20
;       a    de,hl                      ; ADD HL,DE         ;
;       inc  ix                         ; INC IX            ;
;       sb   one,b                      ; DJNZ $6681        ;
;       jne  _6681                      ;
;       .ret                            ; RET               ;
;_668e:
;       .push bc                        ; PUSH BC           ;
;       li   bc,>001f                   ; LD BC,$001F       ;
;       movb *ix,a                      ; LD A,(IX+$00)     ;
;       .lddr                           ; LDDR              ;
;       movb a,*de                      ; LD (DE),A         ;
;       inc  ix                         ; INC IX            ;
;       dec  hl                         ; DEC HL            ;
;       dec  de                         ; DEC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $668E        ;
;       jne  _668e                      ;
;       .ret                            ; RET               ;
;_66a0:
;       .push bc                        ; PUSH BC           ;
;       .push hl                        ; PUSH HL           ;
;       .call @_66ba                    ; CALL $66BA        ;
;       .pop hl                         ; POP HL            ;
;       li   bc,>0020                   ; LD BC,$0020       ;
;       a    bc,hl                      ; ADD HL,BC         ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jeq  _66b3                      ; JR Z,$66B3        ;
;       movb h,a                        ; LD A,H            ;
;       ab   @bytes+7,a                 ; ADD A,$07         ;
;       movb a,h                        ; LD H,A            ;
;_66b3:
;       .push hl                        ; PUSH HL           ;
;       .pop de                         ; POP DE            ;
;       inc  de                         ; INC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $66A0        ;
;       jne  _66a0                      ;
;       .ret                            ; RET               ;
;_66ba:
;       .push hl                        ; PUSH HL           ;
;       .push hl                        ; PUSH HL           ;
;       li   bc,>001f                   ; LD BC,$001F       ;
;       movb *ix,a                      ; LD A,(IX+$00)     ;
;       inc  ix                         ; INC IX            ;
;       .lddr                           ; LDDR              ;
;       movb a,*de                      ; LD (DE),A         ;
;       .pop de                         ; POP DE            ;
;       .pop hl                         ; POP HL            ;
;       ab   one,h                      ; INC H             ;
;       ab   one,d                      ; INC D             ;
;       inc  de                         ; INC DE            ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jne  !                          ; RET Z             ;
;       .ret                            ;
;!
;       jmp  _66ba                      ; JR $66BA          ;
;_66d2:
;       movb h,a                        ; LD A,H            ;
;       ab   @bytes+7,a                 ; ADD A,$07         ;
;       movb a,h                        ; LD H,A            ;
;       .ret                            ; RET               ;

* This entry point is used by the routine at #R$D3EA.
;scroll_left:
;       movb @bytes+11,b                ; LD B,$0B          ;
;scroll_left_loop:
;       .push bc                        ; PUSH BC           ;
;       .call @_6710                    ; CALL $6710        ;
;       .call @_6747                    ; CALL $6747        ;
;       .call @_6747                    ; CALL $6747        ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $6702        ;
;       jne  scroll_left_loop                      ;
;       .ret                            ; RET               ;
;_6710:
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       li   hl,zx_screen+>006a         ; LD HL,$406A       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_677e                    ; CALL $677E        ;
;       li   hl,zx_screen+>0061         ; LD HL,$4061       ;
;       li   de,zx_screen+>0060         ; LD DE,$4060       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_67ba                    ; CALL $67BA        ;
;       li   hl,zx_attributes+>006a     ; LD HL,$586A       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_679b                    ; CALL $679B        ;
;       li   hl,zx_attributes+>0061     ; LD HL,$5861       ;
;       li   de,zx_attributes+>0060     ; LD DE,$5860       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+13,b                ; LD B,$0D          ;
;       .call @_67a8                    ; CALL $67A8        ;
;       .ret                            ; RET               ;
;_6747:
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       li   hl,zx_screen+>102a         ; LD HL,$502A       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_677e                    ; CALL $677E        ;
;       li   hl,zx_screen+>1021         ; LD HL,$5021       ;
;       li   de,zx_screen+>1020         ; LD DE,$5020       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_67ba                    ; CALL $67BA        ;
;       li   hl,zx_attributes+>0220     ; LD HL,$5A20       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_679b                    ; CALL $679B        ;
;       li   hl,zx_attributes+>0221     ; LD HL,$5A21       ;
;       li   de,zx_attributes+>0220     ; LD DE,$5A20       ;
;       li   ix,buffer_at_5b00          ; LD IX,$5B00       ;
;       movb @bytes+4,b                 ; LD B,$04          ;
;       .call @_67a8                    ; CALL $67A8        ;
;       .ret                            ; RET               ;
;_677e:
;       movb @bytes+8,@c                ; LD C,$08          ;
;_6780:
;       movb *hl,a                      ; LD A,(HL)         ;
;       movb a,*ix                      ; LD (IX+$00),A     ;
;       inc  ix                         ; INC IX            ;
;       ab   one,h                      ; INC H             ;
;       sb   one,@c                     ; DEC C             ;
;       jne  _6780                      ; JR NZ,$6780       ;
;       movb h,a                        ; LD A,H            ;
;       sb   @bytes+8,a                 ; SUB $08           ;
;       movb a,h                        ; LD H,A            ;
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jeq  !                          ; CALL NZ,$67EC     ;
;       .call @_67ec                    ;
;!
;       sb   one,b                      ; DJNZ $677E        ;
;       jne  _677e                      ;
;       .ret                            ; RET               ;
;_679b:
;       movb *hl,a                      ; LD A,(HL)         ;
;       movb a,*ix                      ; LD (IX+$00),A     ;
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       inc  ix                         ; INC IX            ;
;       sb   one,b                      ; DJNZ $679B        ;
;       jne  _679b                      ;
;       .ret                            ; RET               ;
;_67a8:
;       .push bc                        ; PUSH BC           ;
;       li   bc,>001f                   ; LD BC,$001F       ;
;       movb *ix,a                      ; LD A,(IX+$00)     ;
;       .ldir                           ; LDIR              ;
;       movb a,*de                      ; LD (DE),A         ;
;       inc  ix                         ; INC IX            ;
;       inc  hl                         ; INC HL            ;
;       inc  de                         ; INC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $67A8        ;
;       jne  _67a8                      ;
;       .ret                            ; RET               ;
;_67ba:
;       .push bc                        ; PUSH BC           ;
;       .push de                        ; PUSH DE           ;
;       .call @_67d4                    ; CALL $67D4        ;
;       .pop hl                         ; POP HL            ;
;       li   bc,>0020                   ; LD BC,$0020       ;
;       a    bc,hl                      ; ADD HL,BC         ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jeq  _67cd                      ; JR Z,$67CD        ;
;       movb h,a                        ; LD A,H            ;
;       ab   @bytes+7,a                 ; ADD A,$07         ;
;       movb a,h                        ; LD H,A            ;
;_67cd:
;       .push hl                        ; PUSH HL           ;
;       .pop de                         ; POP DE            ;
;       inc  hl                         ; INC HL            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $67BA        ;
;       jne  _67ba                      ;
;       .ret                            ; RET               ;
;_67d4:
;       .push de                        ; PUSH DE           ;
;       .push de                        ; PUSH DE           ;
;       li   bc,>001f                   ; LD BC,$001F       ;
;       movb *ix,a                      ; LD A,(IX+$00)     ;
;       inc  ix                         ; INC IX            ;
;       .ldir                           ; LDIR              ;
;       movb a,*de                      ; LD (DE),A         ;
;       .pop de                         ; POP DE            ;
;       .pop hl                         ; POP HL            ;
;       ab   one,h                      ; INC H             ;
;       ab   one,d                      ; INC D             ;
;       inc  hl                         ; INC HL            ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jne  !                          ; RET Z             ;
;       .ret                            ;
;!
;       jmp  _67d4                      ; JR $67D4          ;
;_67ec:
;       movb h,a                        ; LD A,H            ;
;       ab   @bytes+7,a                 ; ADD A,$07         ;
;       movb a,h                        ; LD H,A            ;
;       .ret                            ; RET               ;

* BANG!
* 
* Used by the routines at #R$C687 and #R$CD47.
bang:                                  ; c000
       bl   @ti_clear_screen           ; CALL $C046        ; Clear the screen.
       li   tmp1,>0002
       bl   @bang_color
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F000 to #R$C061.
       li   hl,gfx_bang_frame_1        ; LD HL,$F000       ;
       .call @bang_copy                ; CALL $C061        ; }
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F100 to #R$C061.
       li   hl,gfx_bang_frame_2        ; LD HL,$F100       ;
       .call @bang_copy                ; CALL $C061        ; }
       movb @bytes+3,b                 ; LD B,$03          ; {Pass #R$F200 to #R$C061.
       li   hl,gfx_bang_frame_3        ; LD HL,$F200       ;
       .call @bang_copy                ; CALL $C061        ; }
       .call @shot_sound_2_alias       ; CALL $6502        ; {Calls $6502 twice.
       .call @shot_sound_2_alias       ; CALL $6502        ; }
       movb @bytes+6,b                 ; LD B,$06          ; {Pass #R$F300 to #R$C061.
       li   hl,gfx_bang_frame_4        ; LD HL,$F300       ;
       .call @bang_copy                ; CALL $C061        ; }
       movb @bytes+5,b                 ; LD B,$05          ; {Pass #R$F400 to #R$C061.
       li   hl,gfx_bang_frame_5        ; LD HL,$F400       ;
       .call @bang_copy                ; CALL $C061        ; }
       movb @bytes+5,b                 ; LD B,$05          ; {Pass #R$F500 to #R$C061.
       li   hl,gfx_bang_frame_6        ; LD HL,$F500       ;
       .call @bang_copy                ; CALL $C061        ; }
       movb @bytes+8,b                 ; LD B,$08          ; {Blanks the display by passing a
       li   tmp1,>0000                 ; LD HL,$5000       ; "clear" part of the screen buffer
       bl   @bang_color                ; CALL $C061        ; to #R$C061.}
       movb @bytes+64,b                ; LD B,$40          ; {Jump to #R$C06D.
       jmp  bang_halt_loop             ; JP $C06D          ; }
;prep_bang:                             ; c046
;       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of
;       li   de,zx_screen+1             ; LD DE,$4001       ; the screen buffer (i.e. "blanks
;       li   bc,>17ff                   ; LD BC,$17FF       ; it").
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
;       li   hl,zx_attributes           ; LD HL,$5800       ; {Continues into the attributes buffer, and writes $02 (red ink) to every location.
;       li   de,zx_attributes+1         ; LD DE,$5801       ; #TABLE(default,centre)
;       li   bc,>02ff                   ; LD BC,$02FF       ; { =h Value | =h Ink | =h Paper | =h Bright }
;       movb @bytes+2,*hl               ; LD (HL),$02       ; { $02 | $00 | $00 | $00 }
;       .ldir                           ; LDIR              ; TABLE#}
;       .ret                            ; RET               ; Returns.
bang_copy:                             ; c061
       seto @graphics_bank_select      ; PUSH BC           ; {Sets the screen location and the
       li   tmp2,>0804                 ; LD BC,$2008       ; bang image frame sizing, then
       li   tmp0,>0860                 ; LD DE,$480C       ; calls #R$C071, issues a short
       mov  hl,tmp1                    ; EX DE,HL          ; pause and ...
       bl   @ti_draw_graphics          ; CALL $C071        ;
                                       ; POP BC            ;
bang_halt_loop:                        ; c06d
       bl   @ti_vsync                  ; HALT              ;
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C06D        ; }
       jne  bang_halt_loop             ;
       .ret                            ; RET               ; ...returns.
bang_color:
       .proc
       li   tmp0,>0860
       li   tmp2,>0804
       bl   @ti_draw_color_area
       .endproc
;bang_print:                            ; c071
;       .push bc                        ; PUSH BC           ; {Copy the bang image frame to the
;       .push hl                        ; PUSH HL           ; screen buffer.
;       sb   b,b                        ; LD B,$00          ;
;       .ex_de_hl                       ; EX DE,HL          ;
;       .ldir                           ; LDIR              ;
;       .ex_de_hl                       ; EX DE,HL          ;
;       .pop hl                         ; POP HL            ;
;       ab   one,h                      ; INC H             ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jne  !                          ; CALL Z,$C085      ;
;       .call @bang_next_line           ;
;!
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $C071        ; }
;       jne  bang_print                 ;
;       .ret                            ; RET               ; Return.
;bang_next_line:                        ; c085
;       movb h,a                        ; LD A,H            ; {Handles working out the next
;       sb   @bytes+8,a                 ; SUB $08           ; line progressively in the screen
;       movb a,h                        ; LD H,A            ; buffer.
;       movb @l,a                       ; LD A,L            ;
;       ab   @bytes+32,a                ; ADD A,$20         ;
;       movb a,@l                       ; LD L,A            ;
;       joc  !                          ; RET NC            ; TODO: check code.
;       .ret                            ;
;!
;       movb h,a                        ; LD A,H            ;
;       ab   @bytes+8,a                 ; ADD A,$08         ;
;       movb a,h                        ; LD H,A            ; }
;       .ret                            ; RET               ; Return.
;       byte >C3,>90,>EA,>04,>33,>49,>44,>46                          ;
;       byte >47,>B1,>D2,>04,>32                                      ;
*
* Draw Playfield
* 
* Used by the routine at #R$CC3A.
;draw_playfield:                        ; c300
;       movb *ix,@l                     ; LD L,(IX+$00)     ; {Set #R$D5E6 as the destination address at #R$C3B7.
;       movb @1(ix),h                   ; LD H,(IX+$01)     ;
;       mov  hl,@alias_copy_routine+1   ; LD ($C3B8),HL     ; }
;       li   hl,>4000                   ; LD HL,$4000       ; {Clears the screen buffer by writing $00 to all 6912
;       li   de,>4001                   ; LD DE,$4001       ; memory locations.
;       li   bc,>1aff                   ; LD BC,$1AFF       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
;* Draws the numbering of the deposit boxes on the left and right of the screen.
;       li   hl,>4001                   ; LD HL,$4001       ; {Points #REGhl to $4001 (screen buffer) and #REGde to
;       li   de,gfx_slot_numbers_left   ; LD DE,$DFA0       ; #R$DFA0, then calls the routine at #R$C3B7.
;       li   bc,>080c                   ; LD BC,$080C       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,>4013                   ; LD HL,$4013       ; {Points #REGhl to $4013 (screen buffer) and #REGde to
;       li   de,gfx_slot_numbers_right  ; LD DE,$E000       ; #R$E000, then calls the routine at #R$C3B7.
;       li   bc,>080c                   ; LD BC,$080C       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;* Draws the centrepiece "till" image.
;       li   hl,zx_screen+>000e         ; LD HL,$400E       ; {Points #REGhl to $400E (screen buffer) and #REGde to
;       li   de,gfx_centrepiece         ; LD DE,$E060       ; #R$E060, then calls the routine at #R$C3B7.
;       movb @bytes+24,b                ; LD B,$18          ;
;       movb @bytes+4,@c                ; LD C,$04          ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;* Draws the game play area (doors and wall sections).
;       li   hl,zx_screen+>0060         ; LD HL,$4060       ; {Points #REGhl to $4060 (screen buffer) and #REGde to
;       li   de,gfx_doors_top           ; LD DE,$E0C0       ; #R$E0C0, then calls the routine at #R$C3B7.
;       li   bc,>0820                   ; LD BC,$0820       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>0080         ; LD HL,$4080       ; {Points #REGhl to $4080 (screen buffer) and #REGde to
;       li   de,gfx_wall_left           ; LD DE,$E1C0       ; #R$E1C0, then calls the routine at #R$C3B7.
;       movb @bytes+88,b                ; LD B,$58          ;
;       movb @bytes+2,@c                ; LD C,$02          ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>0089         ; LD HL,$4089       ; {Points #REGhl to $4089 (screen buffer) and #REGde to
;       li   de,gfx_wall_middle         ; LD DE,$E270       ; #R$E270, then calls the routine at #R$C3B7.
;       movb @bytes+88,b                ; LD B,$58          ;
;       movb @bytes+4,@c                ; LD C,$04          ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>0094         ; LD HL,$4094       ; {Points #REGhl to $4094 (screen buffer) and #REGde to
;       li   de,gfx_wall_middle         ; LD DE,$E270       ; #R$E270, then calls the routine at #R$C3B7.
;       movb @bytes+88,b                ; LD B,$58          ;
;       movb @bytes+4,@c                ; LD C,$04          ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>009f         ; LD HL,$409F       ; {Points #REGhl to $409F (screen buffer) and #REGde to
;       li   de,gfx_door_frame_side     ; LD DE,$E3D0       ; #R$E3D0, then calls the routine at #R$C3B7.
;       movb @bytes+88,b                ; LD B,$58          ;
;       movb one,@c                     ; LD C,$01          ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>00e0         ; LD HL,$48E0       ; {Points #REGhl to $48E0 (screen buffer) and #REGde to
;       li   de,gfx_door_bottom         ; LD DE,$E428       ; #R$E428, then calls the routine at #R$C3B7.
;       li   bc,>0820                   ; LD BC,$0820       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;* Draws the Bank Teller desks.
;       li   hl,zx_screen+>1020         ; LD HL,$5020       ; {Points #REGhl to $5020 (screen buffer) and #REGde to
;       li   de,gfx_tellers             ; LD DE,$E528       ; #R$E528, then calls the routine at #R$C3B7.
;       li   bc,>2020                   ; LD BC,$2020       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;* Writes the "SCORE" and "LIVES" labels (these aren't text, they're images).
;       li   hl,zx_screen+>10c1         ; LD HL,$50C1       ; {Points #REGhl to $50C1 (screen buffer) and #REGde to
;       li   de,gfx_score_text_image    ; LD DE,$E928       ; #R$E928, then calls the routine at #R$C3B7.
;       li   bc,>1006                   ; LD BC,$1006       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;       li   hl,zx_screen+>10b0         ; LD HL,$50B0       ; {Points #REGhl to $50B0 (screen buffer) and #REGde to
;       li   de,gfx_lives_text_image    ; LD DE,$E988       ; #R$E988, then calls the routine at #R$C3B7.
;       li   bc,>1606                   ; LD BC,$1606       ;
;       .call @alias_copy_routine       ; CALL $C3B7        ; }
;* Copies attribute data to the screen.
;       li   hl,attributes              ; LD HL,$ED00       ; {Copies $300 bytes of attribute data from #R$ED00 to
;       li   de,zx_attributes           ; LD DE,$5800       ; $5800.
;       li   bc,>0300                   ; LD BC,$0300       ;
;       .ldir                           ; LDIR              ; }
;       .ret                            ; RET               ; Return.
;alias_copy_routine:                    ; c3b7
;       .call @copy_routine             ; CALL $D5E6        ; Draws the image pointed to in #REGde to the screen
;                                                           ; location in #REGhl using the dimensions in #REGbc.
;       .ret                            ; RET               ; Return.

* Routine at C3C0
* 
* Used by the routine at #R$C7C0.
perform_duel:
;       mov  a,@duel_counter           ; I think this was intended
       .call @perform_duel_main        ; CALL $C3DD        ; Call #R$C3DD.
                                       ; LD A,($C421)      ; Grab #R$C421.
       jnc  after_duel_1               ; JR NC,$C3C9       ; TODO: check code.
       ab   one,@duel_counter          ; INC A             ;
after_duel_1:                          ; c3c9
       movb @duel_counter,a
       movb @bytes+32,b                ; LD B,$20          ; {Interrupt driven HALT loop ($20 cycles).
after_duel_loop:                       ; c3cb
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C3CB        ; }
       jne  after_duel_loop            ;
       movb a,@e                       ; LD E,A            ; 
       mov  @lives_addr,hl             ; LD HL,($5B86)     ; {Is #R$CC59 more than $06?
       movb *hl,a                      ; LD A,(HL)         ; Get lives
       cb   a,@bytes+6                 ; CP $06            ; }
       jl   after_duel_2               ; JR C,$C3D8        ; If so, jump to #R$C3D8.
       nop                             ; NOP               ; We have 6 lives or more ?
after_duel_2:
       ; AND A                         ; AND A             ; {If #R$CC59 @duel_counter is zero then return without carry.
       movb @e,a                       ; LD A,E            ; 
       jeq  !                          ; RET NZ            ; }
       b    @return_without_carry                            ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Kicks off the duelling bonus round.
perform_duel_main:                     ; c3dd
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGde.
       .push de                        ; PUSH DE           ; }
;       li   de,buffer_at_5b80          ; LD DE,$5B80       ; {Copies $1B of data from #REGhl to #R$5B80.
;       li   bc,>001b                   ; LD BC,$001B       ;
;       .ldir                           ; LDIR              ; }
       b    @duel_prep                 ; JP $C422          ; Jump to #R$C422.

* Duel Bonus Round Data.
*
* Dueller 1 data.
duel_data:                             ; c3ea
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >80                                                      ; Dueller timer.
       byte >12                                                      ; 
       byte >01                                                      ; Dueller position (1).
       byte >C5,>40                                                  ; Screen position above dueller to display "EXTRA"
                                                                     ; or points.
       byte >00                                                      ; 
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >01                                                      ; 
       byte >01                                                      ; Current frame?
       byte >12,>13,>14                                              ; Dueller 1 frames.
       byte >00,>08,>08,>0A                                          ; 
* Dueller 2 data.
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >80                                                      ; Dueller timer.
       byte >12                                                      ; 
       byte >02                                                      ; Dueller position (2).
       byte >CD,>40                                                  ; Screen position above dueller to display "EXTRA"
                                                                     ; or points.
       byte >00                                                      ; 
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >01                                                      ; 
       byte >01                                                      ; Current frame?
       byte >15,>16,>17                                              ; Dueller 2 frames.
       byte >00,>08,>08,>0A                                          ; 
* Dueller 3 data.
       byte >00                                                      ; Dueller state ("0" is complete).
       byte >80                                                      ; Dueller timer.
       byte >12                                                      ; 
       byte >03                                                      ; Dueller position (3).
       byte >D5,>40                                                  ; Screen position above dueller to display "EXTRA"
                                                                     ; or points.
       byte >00                                                      ; 
       byte >00                                                      ; Bonus points (x100, e.g. "9" == "900").
       byte >01                                                      ; 
       byte >01                                                      ; Current frame?
       byte >18,>19,>1A                                              ; Dueller 3 frames.
       byte >00,>08,>08,>0A                                          ; 

* Buffer holding bonus text.
duel_bonus_text:                       ; c41d
       text '900',>ff                                                ; Bonus text.
* Not sure ... it is used though       ; TODO
duel_counter:                          ; c421
       byte >00                                                      ; 

* Duel Bonus Round.
* 
* Used by the routine at #R$C3C0.
duel_prep:                             ; c422
       li   hl,duel_data               ; LD HL,$C3EA       ; {Copies $33 bytes of data from #R$C3EA to #R$5BC0 (and
       li   de,dueller_1               ; LD DE,$5BC0       ; across all three duellists).
       li   bc,>0033                   ; LD BC,$0033       ; 
       .ldir                           ; LDIR              ; }
       .pop de                         ; POP DE            ;
       .pop bc                         ; POP BC            ;
       movb b,a                        ; LD A,B            ; random number from caller
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C67F with #R$5BC0.
       .call @duel_update_timer        ; CALL $C67F        ; }
       movb @c,a                       ; LD A,C            ; random number from caller
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C67F with #R$5BD1.
       .call @duel_update_timer        ; CALL $C67F        ; }
       movb d,a                        ; LD A,D            ; random number from caller
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C67F with #R$5BE2.
       .call @duel_update_timer        ; CALL $C67F        ; }
       sb   a,a                        ; XOR A             ; {Reset the flags (writes $00 to #R$C6E2, #R$C6E3 and
       li   hl,duel_bang_flag          ; LD HL,$C6E2       ; #R$C6E4).
       movb a,*hl+                     ; LD (HL),A         ; clear duel_bang_flag
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear duel_lose_life
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear duel_extra_life
       movb @duel_counter,a            ; LD A,($C421)      ; #R$C421.
       socb one,a                      ; OR $01            ; min 1
       li   de,>0001                   ; CP $20            ;
       cb   a,@bytes+32                ; LD DE,$0001       ;
       jhe  duel_clear_screen          ; JR NC,$C463       ;
       movb a,b                        ; LD B,A            ; 
       li   de,>0020                   ; LD DE,$0020       ; 
duel_prep_loop:                        ; c460              ; de = >20 - @duel_counter
       dec  de                         ; DEC DE            ; 
       sb   one,b                      ; DJNZ $C460        ; 
       jne  duel_prep_loop             ;                   
duel_clear_screen:                     ; c463
       mov  de,@duel_inner_iterations  ; LD ($C52E),DE     ; ....
* Clears down the screen buffer.
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of the screen buffer
;       li   de,zx_screen+1             ; LD DE,$4001       ; (i.e. "blanks it").
;       li   bc,>1aff                   ; LD BC,$1AFF       ;
;       sb   a,a                        ; XOR A             ;
;       movb a,*hl                      ; LD (HL),A         ;
;       .ldir                           ; LDIR              ; }
* Writes the attributes for the playfield (sky, grass, footer).
       li   tmp0,>0400
       li   tmp1,>0028
       li   tmp2,>200c
       bl   @ti_draw_color_area
;       li   hl,zx_attributes           ; LD HL,$5880       ; {Writes $28 to $5880 in the attribute buffer $180 times...
;       li   de,zx_attributes+1         ; LD DE,$5881       ; #TABLE(default,centre,centre,centre,centre)
;       li   bc,>0180                   ; LD BC,$0180       ; { =h Value | =h Ink | =h Paper | =h Bright }
;       movb @bytes+40,*hl              ; LD (HL),$28       ; { $00 | $05 | $00 | $00 }
;       .ldir                           ; LDIR              ; TABLE#}
       li   tmp0,>1000
       li   tmp1,>0020
       li   tmp2,>2004
       bl   @ti_draw_color_area
;       movb @bytes+32,*hl              ; LD (HL),$20       ; {...continuing, writes $20 $80 times...
;       li   bc,>0080                   ; LD BC,$0080       ; #TABLE(default,centre,centre,centre,centre)
;       .ldir                           ; LDIR              ; { =h Value | =h Ink | =h Paper | =h Bright }
;                                                           ; { $00 | $04 | $00 | $00 }
;                                                           ; TABLE#}
       li   tmp0,>1400
       li   tmp1,>0007
       li   tmp2,>2004
       bl   @ti_draw_color_area
;       movb @bytes+7,*hl               ; LD (HL),$07       ; {...and finally, writes $07 $7F times.
;       li   bc,>007f                   ; LD BC,$007F       ; #TABLE(default,centre,centre,centre,centre)
;       .ldir                           ; LDIR              ; { =h Value | =h Ink | =h Paper | =h Bright }
;                                                           ; { $07 | $00 | $00 | $00 }
;                                                           ; TABLE#}
* Creates the footer.
       li   hl,playfield_lives         ; LD HL,$C655       ; {Point to #R$C655 and print using #R$C6A7.
       .call @duel_print_lives         ; CALL $C6A7        ; }
       .call @draw_life_images_alias   ; CALL $5B83        ; 
       li   hl,playfield_score         ; LD HL,$C64D       ; {Point to #R$C64D and prints using #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       .call @draw_score_alias         ; CALL $5B98        ; Writes the players score.
* Initialise duellers.
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Initialise #R$5BC0 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Initialise #R$5BD1 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Initialise #R$5BE2 (draws frame 1).
       movb @10(ix),a                  ; LD A,(IX+$0A)     ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; }
* Count down 5-4-3-2-1...0!
countdown_initialise:                  ; c4c5
       movb @bytes+53,a                ; LD A,$35          ; {Initialise countdown to "5" seconds ($35 in ASCII),
countdown_loop:                        ; c4c7
       .push af                        ; PUSH AF           ; hold this at #R$C6E0.
       movb a,@duel_timer              ; LD ($C6E0),A      ; }
       .call @duel_print_countdown     ; CALL $C6D3        ; 
       movb @bytes+49,b                ; LD B,$31          ; {Short halt loop (1 second pause).
countdown_halt_loop:                   ; c4d0
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C4D0        ; }
       jne  countdown_halt_loop        ;                   
       .pop af                         ; POP AF            ; {Keep looping back to #R$C4C7 until the countdown is
       sb   one,a                      ; DEC A             ; "0" ($30 in ASCII).
       cb   a,@bytes+48                ; CP $30            ; 
       jne  countdown_loop             ; JR NZ,$C4C7       ; }
       movb @bytes+32,a                ; LD A,$20          ; {Blank the countdown timer by printing a "SPACE" ($20
       movb a,@duel_timer              ; LD ($C6E0),A      ; in ASCII) over the top of it.
       .call @duel_print_countdown     ; CALL $C6D3        ; }
       jmp  duel_outer_loop                 ; JR $C4F9          ; Jump to #R$C4F9 and start the duel!

check_any_duellers_shot:               ; c4e3
       li   ix,dueller_1               ; LD IX,$5BC0       ; {Calls #R$C530 with #R$5BC0.
       .call @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_2               ; LD IX,$5BD1       ; {Calls #R$C530 with #R$5BD1.
       .call @check_if_duellers_are_shot ; CALL $C530        ; }
       li   ix,dueller_3               ; LD IX,$5BE2       ; {Calls #R$C530 with #R$5BE2.
       .call @check_if_duellers_are_shot ; CALL $C530        ; }
       .ret                            ; RET               ; Return.
* DRAW!
duel_outer_loop:                       ; c4f9
       mov  @duel_inner_iterations,de  ; LD DE,($C52E)     ; {#REGde=#R$C52E and push it on the stack.
duel_inner_loop:                       ; c4fd
       .push de                        ; PUSH DE           ; }
       .call @check_any_duellers_shot  ; CALL $C4E3        ;
       .pop de                         ; POP DE            ; 
       dec  de                         ; DEC DE            ; 
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  duel_inner_loop            ; JR NZ,$C4FD       ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_2               ; LD IX,$5BD1       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_3               ; LD IX,$5BE2       ; 
       .call @update_dueller_status    ; CALL $C58B        ;
       li   ix,dueller_1               ; LD IX,$5BC0       ; 
       movb @8(ix),a                   ; LD A,(IX+$08)     ; Any duellers left?
       socb @25(ix),a                  ; OR (IX+$19)       ; 
       socb @42(ix),a                  ; OR (IX+$2A)       ; 
       jne  !                          ; JP Z,$C690        ; 
       b    @duel_complete             ;                   
!
       jmp  duel_outer_loop                 ; JR $C4F9          ;

duel_inner_iterations:                 ; c52e
       data 31                                             ;

check_if_duellers_are_shot:            ; c530
       .call @duel_check_fire_at_3     ; CALL $C543        ;
       .call @check_if_dueller_is_shot ; CALL $C56B        ;
       .call @duel_check_fire_at_1     ; CALL $C550        ;
       .call @check_if_dueller_is_shot ; CALL $C56B        ;
       .call @duel_check_fire_at_2     ; CALL $C55D        ;
       .call @check_if_dueller_is_shot ; CALL $C56B        ;
       .ret                            ; RET               ; Return.
duel_check_fire_at_3:                  ; c543
       .call @jump_to_control_method   ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       movb a,tmp0                     ; BIT 0,A           ; right {If bit 0 is not zero then return setting #REGa to
       movb @bytes+3,a                 ;
       andi tmp0,1*256                 ; LD A,$03          ; $03.
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
       .ret                            ; RET               ; }
duel_check_fire_at_1:                  ; c550
       .call @jump_to_control_method   ; CALL $5B88        ; Calls #R$5B88.
       movb a,tmp0                     ; BIT 4,A           ; {Return if bit 4 of #REGa is zero.
       andi tmp0,16*256                ;                   
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       movb a,tmp0                     ; BIT 1,A           ; left {If bit 1 is not zero then return setting #REGa to
       movb one,a                      ;
       andi tmp0,2*256                 ; LD A,$01          ; $01.
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; {Set #REGa to zero and return.
       .ret                            ; RET               ; }
duel_check_fire_at_2:                         ; c55d
       .call @jump_to_control_method   ; CALL $5B88        ;
       movb a,tmp0                     ; BIT 4,A           ; 
       andi tmp0,16*256                ;                   
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       movb a,tmp0
       sb   a,a                        ; AND $03           ;
       andi a,3*256                    ; LD A,$00          ;
       jeq  !                          ; RET NZ            ;
       .ret                            ;                   
!
       movb @bytes+2,a                 ; LD A,$02          ; 
       .ret                            ; RET               ; Return.
check_if_dueller_is_shot:              ; c56b
       cb   a,@3(ix)                   ; CP (IX+$03)       ; {If player fires at dueller then
       jeq  dueller_is_shot            ; JR Z,$C575        ; jump to #R$C575.}
       sb   @13(ix),@13(ix)            ; LD (IX+$0D),$00   ; 
       .ret                            ; RET               ; Return.
dueller_is_shot:                       ; c575
       movb @13(ix),a                  ; LD A,(IX+$0D)     ; 
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       movb one,a                      ; LD A,$01          ; 
       movb a,@13(ix)                  ; LD (IX+$0D),A     ; 
       movb a,*ix                      ; LD (IX+$00),A     ; Set dueller state to $01.
       .ret                            ; RET               ; Return.

* This entry point is used by the routines at #R$C607 and #R$C6E5.
duel_shot_sound:
       .push ix                        ; PUSH IX           ; 
       .call @shot_sound_1_alias       ; CALL $6500        ; 
       .pop ix                         ; POP IX            ; 
       .ret                            ; RET               ;

update_dueller_status:
       movb @8(ix),a                   ; LD A,(IX+$08)     ; {If IX+$08 is zero then return.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       movb @9(ix),a                   ; LD A,(IX+$09)     ; {If dueller frame index is $01 then jump to #R$C5A1.
       sb   one,a                      ; DEC A             ; 
       jeq  update_dueller_status_1    ; JR Z,$C5A1        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $02 then jump to #R$C5B5.
       jeq  update_dueller_status_2    ; JR Z,$C5B5        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $03 then jump to #R$C5BD.
       jeq  update_dueller_status_3    ; JR Z,$C5BD        ; }
       sb   one,a                      ; DEC A             ; {If dueller frame index is $04 then jump to #R$C5CF.
       jeq  update_dueller_status_4    ; JR Z,$C5CF        ; }
       jmp  update_dueller_status_5    ; JR $C5DD          ; Jump to #R$C5DD.
update_dueller_status_1:               ; c5a1
       li   hl,dueller_shot            ; LD HL,$C6E5       ; #R$C6E5.
       .call @dueller_down             ; CALL $C5EB        ; 
       sb   one,@1(ix)                 ; DEC (IX+$01)      ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; 
       movb @11(ix),a                  ; LD A,(IX+$0B)     ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; 
       .ret                            ; RET               ; 
update_dueller_status_2:               ; c5b5
       sb   one,@16(ix)                ; DEC (IX+$10)      ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; 
       .ret                            ; RET               ; 
update_dueller_status_3:               ; c5bd
       li   hl,dueller_down_1          ; LD HL,$C5F6       ;
       .call @dueller_down             ; CALL $C5EB        ; 
       sb   one,@2(ix)                 ; DEC (IX+$02)      ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       movb a,@8(ix)                   ; LD (IX+$08),A     ; 
       ab   one,a                      ; INC A             ; 
       movb a,@duel_bang_flag          ; LD ($C6E2),A      ; 
       .ret                            ; RET               ; 
update_dueller_status_4:               ; c5cf
       sb   one,@14(ix)                ; DEC (IX+$0E)      ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       ab   one,@9(ix)                 ; INC (IX+$09)      ; 
       movb @12(ix),a                  ; LD A,(IX+$0C)     ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; 
       .ret                            ; RET               ; 
update_dueller_status_5:                       ; c5dd
       sb   one,@15(ix)                ; DEC (IX+$0F)      ; 
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       movb @bytes+2,a                 ; LD A,$02          ; 
       .call @duel_draw_bandit_prep    ; CALL $C661        ; 
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; 
       .ret                            ; RET               ; 

* Routine at C5EB
* 
* Used by the routine at #R$C422.
dueller_down:                          ; c5eb
       movb *ix,a                      ; LD A,(IX+$00)     ; {Check if the current duellers state is zero (complete),
       ; AND A                         ; AND A             ; return if so.
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; {Mark the current dueller as complete.
       movb a,*ix                      ; LD (IX+$00),A     ; }
       .pop af                         ; POP AF            ; {Restore #REGa and jump to whatever address is held by
       b    *hl                        ; JP (HL)           ; Branches to dueller_down_1 (!)
dueller_down_1:                        ; c5f6
       movb @2(ix),a                   ; LD A,(IX+$02)     ; 
       srl  a,1                        ; SRL A             ; 
                                       ; CP $09            ;
       movb @4(ix),@e                  ; LD E,(IX+$04)     ; 
       movb @5(ix),d                   ; LD D,(IX+$05)     ;
       cb   a,@bytes+9
       jhe  duel_points                ; JR NC,$C628       ;
       socb one,a                      ; OR $01            ; 

* Displays The Bonus Score Text.
* 
* Used by the routine at #R$C628.
print_bonus_score:                     ; c607
       movb a,@7(ix)                   ; LD (IX+$07),A     ; {Stores the ASCII representation of the number at #R$C41D (it adds ASCII "0") so for example 1 ends up being
       li   hl,duel_bonus_text         ; LD HL,$C41D       ; 1 + $30 = $31 (e.g. "1" in ASCII).
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*hl                      ; LD (HL),A         ; }
       li   bc,>2928                   ; LD BC,$2928       ; {Print using #R$5B80.
       .call @print_two_tone_text_alias ; CALL $5B80        ; #TABLE(default,centre,centre,centre,centre)
                                                           ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; { $28 | $00 | $05 | $00 }
                                                           ; TABLE#}
       .call @scoring_prep_alias       ; CALL $5B8C        ; 
       .call @draw_score_alias         ; CALL $5B98        ; 
       ab   one,@9(ix)                 ; INC (IX+$09)      ; 
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

* "Extra" text.
extra_text_copy:                       ; c622
       text 'EXTRA',>ff

* Displays "Extra" and Bonus Score text.
* 
* Handles whether to display points or "EXTRA" above each downed Bandit.
duel_points:                           ; c628
       movb @duel_extra_life,a         ; LD A,($C6E4)      ; {If #R$C6E4 is NOT zero then award 9(00) bonus points.
       ; AND A                         ; AND A             ; 
       movb @bytes+9,a                 ; LD A,$09          ;
       movb @duel_extra_life,tmp0
       jne  print_bonus_score          ; JR NZ,$C607       ; }
       mov  @lives_addr,hl             ; LD HL,($5B86)     ; {Fetch a 16 bit address from #R$5B86 (#R$CC59), if it is
       movb *hl,tmp0                   ; LD A,(HL)         ; higher than $05 then award 9(00) bonus points.
                                       ; CP $05            ;
       movb @bytes+9,a                 ; LD A,$09          ;
       cb   tmp0,@bytes+5
       jhe  print_bonus_score          ; JR NC,$C607       ; }
       li   hl,extra_text_copy         ; LD HL,$C622       ; {Points to #R$C622 and sends it to #R$5B80.
       dec  de                         ; DEC DE            ; #TABLE(default,centre)
       li   bc,>2a29                   ; LD BC,$2A29       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $2A | $02 | $05 | $00 }
                                                           ; { $29 | $01 | $05 | $00 }
                                                           ; TABLE#}
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$C6E4.
       movb a,@duel_extra_life         ; LD ($C6E4),A      ; }
       ab   one,@9(ix)                 ; INC (IX+$09)      ; Move onto the next frame.
       .ret                            ; RET               ; Return.

* Playfield Text
playfield_score:                       ; c64d
       text ' SCORE ',>ff
playfield_lives:                       ; c655
       text 'LIVES',>ff
playfield_whitespace:                  ; c65b
       text '     ',>ff

* Draw Duel Bandit
* 
* Used by the routine at #R$C422.
duel_draw_bandit_prep:                 ; c661
       clr  tmp2
       movb @3(ix),tmp2
       swpb tmp2
       dec  tmp2
       sla  tmp2,1
       mov  @ti_door_positions(tmp2),tmp0
       ai   tmp0,>80
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       bl   @ti_draw_character_pattern
;       .call @character_addr_alias     ; CALL $5B8F        ; Fetch the address of the character from the given index
;                                                           ; in #REGa.
;       .ex_de_hl                       ; EX DE,HL          ;
;       movb @3(ix),a                   ; LD A,(IX+$03)     ; Retrieve the character position.
;       li   hl,zx_screen+>0804         ; LD HL,$4804       ; {If this character is in position "1" then point to the
;       sb   one,a                      ; DEC A             ; screen buffer at $4804 and jump to #R$C677.
;       jeq  duel_draw_bandit           ; JR Z,$C677        ; }
;       li   hl,zx_screen+>080c         ; LD HL,$480C       ; {If this character is in position "2" then point to the
;       sb   one,a                      ; DEC A             ; screen buffer at $480C and jump to #R$C677.
;       jeq  duel_draw_bandit           ; JR Z,$C677        ; }
;       li   hl,zx_screen+>0814         ; LD HL,$4814       ; Else this character is in position "3" so point to the
;                                                           ; screen buffer at $4814.
;duel_draw_bandit:                      ; c677
;       movb @bytes+88,b                ; LD B,$58          ; {Call the draw routine with the image dimensions.
;       movb @bytes+6,@c                ; LD C,$06          ;
;       .call @draw_character           ; CALL $5B92        ; }
       .ret                            ; RET               ; Return.

* Routine at C67F
* 
* Used by the routine at #R$C422.
duel_update_timer:                     ; c67f
       andi a,63*256                   ; AND $3F           ; {Updates dueller timer.
       socb @bytes+64,a                ; OR $40            ; 
       movb a,@1(ix)                   ; LD (IX+$01),A     ; }
       .ret                            ; RET               ; Return.

* Lose A Life
* 
* Used by the routine at #R$C690.
lose_life:                             ; c687 TODO
       .call @bang                     ; CALL $C000        ; Calls the subroutine to display the "BANG" animation.
       mov  @lives_addr,hl             ; LD HL,($5B86)     ; {Decrease the lives counter by one (#R$CC59), set the
       sb   one,*hl                    ; DEC (HL)          ; zero flag if all lives are lost.
       ; AND A                         ; AND A             ; }
       .ret                            ; RET               ; Return.

* Is The Duel Finished?
* 
* Used by the routine at #R$C422.
duel_complete:                         ; c690
       movb @duel_lose_life,a          ; LD A,($C6E3)      ; {Jump to #R$C6F0 if #R$C6E3 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6F0       ; }
       b    @flash_life_image          ;                   
!
       movb @duel_bang_flag,a          ; LD A,($C6E2)      ; {Jump to #R$C687 if #R$C6E2 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C687       ; }
       b    @lose_life                 ;                   
!
       movb @duel_extra_life,a         ; LD A,($C6E4)      ; {Jump to #R$C6B1 if #R$C6E4 is not zero.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; JP NZ,$C6B1       ; }
       b    @duel_flash_text           ;                   
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Write "Lives" text.
* 
* Used by the routines at #R$C422 and #R$C6B1.
duel_print_lives:                      ; c6a7
       li   de,zx_screen+>10d0         ; LD DE,$50D0       ; {Helper routine called from #R$C463 used for writing #R$C655 to the screen using the colours held in #REGbc;
       li   bc,>0702                   ; LD BC,$0702       ; #TABLE(default,centre)
       .call @print_two_tone_text_alias ; CALL $5B80        ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Duel: Gain Extra Life.
* 
* Used by the routine at #R$C690.
duel_flash_text:                       ; c6b1
       movb @bytes+8,b                 ; LD B,$08          ; {Alternates displaying #R$C65B and #R$C655 to "flash"
duel_flash_text_loop:                  ; c6b3
       .push bc                        ; PUSH BC           ; the lives indicator.
       li   hl,playfield_whitespace    ; LD HL,$C65B       ; 
       .call @duel_print_lives         ; CALL $C6A7        ; 
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_1:                ; c6bc
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6BC        ; 
       jne  duel_flash_halt_loop_1     ;                   
       li   hl,playfield_lives         ; LD HL,$C655       ; 
       .call @duel_print_lives         ; CALL $C6A7        ; 
       movb @bytes+16,b                ; LD B,$10          ; 
duel_flash_halt_loop_2:                ; c6c7
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6C7        ; 
       jne  duel_flash_halt_loop_2     ;                   
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $C6B3        ; }
       jne  duel_flash_text_loop       ;                   
       mov  @lives_addr,hl             ; LD HL,($5B86)     ; {Increase the lives counter by one (#R$CC59).
       ab   one,*hl                    ; INC (HL)          ; }
       ; SCF                           ; SCF               ; {Sets the carry flag and returns.
       b    @return_with_carry         ; RET               ; }

* Write "Countdown" text.
* 
* Used by the routine at #R$C422.
duel_print_countdown:                  ; c6d3
       li   hl,duel_timer              ; LD HL,$C6E0       ; {Helper routine used for writing #R$C6E0 to the screen using the colours held in #REGbc;
       li   de,zx_screen+>004f         ; LD DE,$404F       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Duel Countdown Timer
duel_timer:                            ; c6e0
       byte >20
       byte >FF

* Duel Shot Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_bang_flag:                        ; c6e2
       byte >00                                                      ; Holds $00/ $01 to indicate player has been shot.

* Duel Lost Life Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_lose_life:                        ; c6e3
       byte >00                                                      ; Holds $00/ $01 to indicate player should lose a life (as
                                                                     ; they shot too quickly).

* Duel Extra Life Flag.
* 
* See #R$C690 for the clearest example of usage.
duel_extra_life:                       ; c6e4
       byte >00                                                      ; Holds $00/ $01 to indicate player has gained an extra
                                                                     ; life.

* Process Dueller Shot.
dueller_shot:                          ; c6e5
       movb @bytes+4,a                 ; LD A,$04          ; {Writes $04 to #R$C6E3.
       movb a,@duel_lose_life          ; LD ($C6E3),A      ; }
       movb a,@9(ix)                   ; LD (IX+$09),A     ; Sets the dueller frame index to $04.
       b    @duel_shot_sound           ; JP $C583          ; Jump to #R$C583.

* Flash Life Image.
* 
* This routine flashes the last life image eight times, and returns with lives being one less and the carry flag
* being set.
flash_life_image:                      ; c6f0
       mov  @lives_addr,hl             ; LD HL,($5B86)     ; {Decrease #R$CC59 by one.
       sb   one,*hl                    ; DEC (HL)          ; }
       movb @bytes+8,b                 ; LD B,$08          ; Sets #REGb (the counter) to loop $08 times.
flash_life_image_loop:                 ; c6f6
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       ab   one,*hl                    ; INC (HL)          ; {Increase #R$CC59 by one and call #R$5B83.
       .call @draw_life_images_alias   ; CALL $5B83        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_1:          ; c6fe
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C6FE        ; }
       jne  flash_life_image_halt_loop_1 ;                   
       .pop hl                         ; POP HL            ; 
       .push hl                        ; PUSH HL           ; 
       sb   one,*hl                    ; DEC (HL)          ; {Decrease #R$CC59 by one and call #R$5B83.
       .call @draw_life_images_alias   ; CALL $5B83        ; }
       .pop hl                         ; POP HL            ; 
       movb @bytes+16,b                ; LD B,$10          ; {Interrupt driven halt loop.
flash_life_image_halt_loop_2:          ; c70a
       bl   @ti_vsync                  ; HALT              ;
       sb   one,b                      ; DJNZ $C70A        ; }
       jne  flash_life_image_halt_loop_2 ;                   
       .pop bc                         ; POP BC            ; {Retrieves #REGb (the counter) from the stack and loop
       sb   one,b                      ; DJNZ $C6F6        ; back until finished.}
       jne  flash_life_image_loop      ;                   
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Data block at C71E
       byte >22,>FB

* Sheriff's Star Page
* 
* Used by the routine at #R$C7C0.
sheriff_star:                          ; c720
       li   hl,zx_screen               ; LD HL,$4000       ; {Writes $00 to all 6144 bytes of the screen buffer (i.e.
       li   de,zx_screen+1             ; LD DE,$4001       ; "blanks it").
       li   bc,>1800                   ; LD BC,$1800       ; 
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ldir                           ; LDIR              ; }
       li   bc,>02ff                   ; LD BC,$02FF       ; {Continues into the attributes buffer, and writes $06 to every location.
       movb @bytes+6,*hl               ; LD (HL),$06       ; #TABLE(default,centre,centre,centre,centre)
       .ldir                           ; LDIR              ; { =h Value | =h Ink | =h Paper | =h Bright }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,zx_screen+>008b         ; LD HL,$408B       ; {Points to #R$F600 and prints it to the screen using
       li   de,gfx_badge_image         ; LD DE,$F600       ; #R$5B92.
       li   bc,>5008                   ; LD BC,$5008       ;
       .call @draw_character           ; CALL $5B92        ; }
       li   hl,header_1                ; LD HL,$C765       ; {Points to #R$C765 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1001         ; LD DE,$5001       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_2                ; LD HL,$C784       ; {Points to #R$C784 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1041         ; LD DE,$5041       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       li   hl,header_3                ; LD HL,$C7A3       ; {Points to #R$C7A3 and prints it to the screen using #R$5B80.
       li   de,zx_screen+>1083         ; LD DE,$5083       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0702                   ; LD BC,$0702       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $02 | $02 | $00 | $00 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Sheriff's Star Page Text
header_1:                              ; c765
       text '      THIS IS YOUR STAR       ',>ff
header_2:                              ; c784
       text 'YOU ARE THE SOFT CITY SHERIFF ',>ff
header_3:                              ; c7a3
       text '    NOW DO YOUR WORK     ',>ff

;* Unused
;       byte >C3,>90,>00

* New Game
start:                                 ; c7c0
       mov  @>83c0,hl                  ; LD HL,($5C78)     ; TODO #HTML(Fetch <a
                                                           ; href="https://skoolkid.github.io/rom/asm/5C78.html">FRAMES</a>
                                                           ; as a random number seed.)
       mov  hl,@random_seed            ; LD ($D8AC),HL     ; Write it to #R$D8AC.
main_loop:
       bl   @ti_clear_screen
       .call @new_game                  ; CALL $C7E5        ; Call #R$C7E5.
;       li   hl,zx_screen               ; LD HL,$4000       ; {Clears the screen buffer by
;       li   de,zx_screen+1             ; LD DE,$4001       ; writing $00 to all 6912 memory
;       li   bc,>1aff                   ; LD BC,$1AFF       ; locations.
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
       bl   @ti_clear_screen
       movb @bytes+64,b                ; LD B,$80          ; {Calls #R$CD64 with the counter
       .call @halt_loop                ; CALL $CD64        ; $80.}
;      li   hl,copied_5b80             ; LD HL,$CBB4       ; {Jump to #R$FA00 with
       li   ix,score_digit_6           ; LD IX,$CD86       ; #REGhl=#R$CBB4 and
       .call @draw_and_input_high_scores ; JP $FA00        ; #REGix=#R$CD86.}
       jmp  main_loop
* Displays the title screen and on return, sets the control method and
* initiates variables for a new game.
new_game:                              ; c7e5
;      li   hl,copied_5b80             ; LD HL,$CBB4       ; {Calls #R$FE00 with
       .call @title_screen             ; CALL $FE00        ; #REGhl=#R$CBB4.}
**
* Init new game
       sb   b,b                        ; LD B,$00          ; Unused.
* Setup input control routine
       movb @controller,a              ; LD A,($5CB0)      ; {Grab the value stored at #R$5CB0
       li   hl,controls_keyboard       ; LD HL,$D39B       ; and if it is $01 then jump ahead
       sb   one,a                      ; DEC A             ; to #R$C7F9 which writes #R$D39B
       jeq  set_control_alias          ; JR Z,$C7F9        ; to #R$CE12.}
       li   hl,controls_joystick       ; LD HL,$D392       ; {Write #R$D392 to #R$CE12.
set_control_alias:                     ; c7f9
       mov  hl,@control_routine_alias  ; LD ($CE12),HL     ; }
* Resets all game variables/ states ready for a new game.
       li   hl,score_digit_6           ; LD HL,$CD86       ; {Clears the score (writes $00
       li   de,score_digit_5           ; LD DE,$CD87       ; over seven bytes from #R$CD86).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       .ldir                           ; LDIR              ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Initialise #R$CC59 to $03.
       movb a,@lives                   ; LD ($CC59),A      ; } Starting_lives
       li   hl,>0101                   ; LD HL,$0101       ; {Initialise #R$D45C to $0101.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CE14, #R$CE16 and
       mov  hl,@door_1_routine         ; LD ($CE14),HL     ; #R$CE18 (sets them to $0000).
       mov  hl,@door_2_routine         ; LD ($CE16),HL     ; 
       mov  hl,@door_3_routine         ; LD ($CE18),HL     ; }
       li   hl,>2020                   ; LD HL,$2020       ; {Clear #R$CA58 and #R$CA5A to
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; $2020 (ASCII space-space).
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Set the border to black.
       bl   @ti_set_border_color          ; OUT ($FE),A       ; }
       ab   one,a                      ; INC A             ; {Write $01 to #R$CBCF.
       movb a,@duel_parameter          ; LD ($CBCF),A      ; }
       .call @init_progress            ; CALL $CA6C        ; 
       .call @set_day_attr             ; CALL $C959        ; 
       .call @cls_display_day         ; CALL $CA64         ;
       movb @bytes+3,a                 ; LD A,$03          ; {Writes $03 to #R$CE1B.
       movb a,@chooser_countdown_init  ; LD ($CE1B),A      ; }
       li   hl,>0500                   ; LD HL,$0500       ; {Writes $0500 to #R$CE1C.
       mov  hl,@delay                  ; LD ($CE1C),HL     ; }
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$D191.
       movb a,@sheriff_star_flag       ; LD ($D191),A      ; }
**
*      Execute levels
       movb @level,a                   ; LD A,($5CB1)      ; {Grabs the #R$5CB1, if it's phase
       li   hl,phase                   ; LD HL,$CA4A       ; 1 then jump to #R$C878 with
       sb   one,a                      ; DEC A             ; #REGhl=#R$CA4A.
       jeq  level_1                    ; JR Z,$C878        ; }
*      Level 2 or 3
       .call @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       .call @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       sb   one,a                      ; DEC A             ; 
       jeq  level_2                    ; JR Z,$C88F        ;
*      Level 3
       .call @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       .call @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       .call @reduce_delay             ; CALL $C941        ;
       ab   one,*hl                    ; INC (HL)          ; Add one to the phase
       jmp  level_3                    ; JR $C8B6          ;
level_1:                               ; c878
       li   hl,choose_default_set      ; LD HL,$CE42       ; {Writes #R$CE42 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_bandit_3         ; LD HL,$CE6F       ; {Writes #R$CE6F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  level_2                    ; RET C             ; TODO: check code.
       .ret                            ;
level_2:
       li   hl,choose_bandit_2         ; LD HL,$CE5F       ; {Writes #R$CE5F to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_julius           ; LD HL,$CE55       ; {Writes #R$CE55 to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_bandit_4         ; LD HL,$CE7E       ; {Writes #R$CE7E to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  level_3                    ; RET C             ; TODO: check code.
       .ret                            ;
level_3:
       li   hl,choose_bandit_5         ; LD HL,$CE8D       ; {Writes #R$CE8D to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @set_dusk_attr            ; CALL $C95E        ; 
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,choose_bandit_6         ; LD HL,$CE9C       ; {Writes #R$CE9C to #R$CE1F.
       mov  hl,@chooser_routine_ptr    ; LD ($CE1F),HL     ; }
       .call @reduce_delay             ; CALL $C941        ;
       .call @set_night_attr           ; CALL $C963        ; 
       .call @run_phase                ; CALL $CA81        ;
       jnc  level_3_1                  ; RET C             ; TODO: check code.
       .ret                            ;                   
level_3_1:                             ; c8f0
       .call @set_day_attr             ; CALL $C959        ;
       .call @cls_display_day          ; CALL $CA64        ;
       movb @bytes+7,b                 ; LD B,$07          ; 
level_3_2:                             ; c8f8
       .push bc                        ; PUSH BC           ; 
       .call @run_phase                ; CALL $CA81        ;
       .pop bc                         ; POP BC            ; 
       jnc  !                          ; RET C             ; TODO: check code.
       .ret                            ;                   
!
       .push bc                        ; PUSH BC           ; 
       .call @reduce_delay             ; CALL $C941        ;
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $C8F8        ; 
       jne  level_3_2                  ;                   ; Do 7 times
       .call @set_dusk_attr            ; CALL $C95E        ; 
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       .call @set_night_attr           ; CALL $C963        ; 
       .call @run_phase                ; CALL $CA81        ;
       jnc  !                          ; RET C             ; TODO: check code. 
       .ret                            ;                   
!
       li   hl,sheriff_star_flag       ; LD HL,$D191       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       ; AND A                         ; AND A             ; 
       jeq  level_3_1                  ; JR Z,$C8F0        ;
;       li   hl,copied_5b80             ; LD HL,$CBB4       ;
;       li   de,buffer_at_5b80          ; LD DE,$5B80       ;
;       li   bc,>0040                   ; LD BC,$0040       ;
;       .ldir                           ; LDIR              ;
       .call @sheriff_star             ; CALL $C720        ; Call #R$C720.
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .call @halt_loop                ; CALL $CD64        ; 
level_3_3:                             ; c936
       sb   a,a                        ; XOR A             ; 
       ; IN A,($FE)                    ; IN A,($FE)        ; 
       socb @bytes+224,a               ; OR $E0            ; 
       ab   one,a                      ; INC A             ; 
       jeq  level_3_3                  ; JR Z,$C936        ;
       nop                             ; NOP               ; 
       jmp  level_3_1                  ; JR $C8F0          ;

* Reduce delay by 64
reduce_delay:                          ; c941
       .push af                        ; PUSH AF           ; 
       .push hl                        ; PUSH HL           ; 
       mov  @delay,hl                  ; LD HL,($CE1C)     ;
       li   bc,>0040                   ; LD BC,$0040       ; 
       ; AND A                         ; AND A             ; 
       s    bc,hl                      ; SBC HL,BC         ; 
       movb h,a                        ; LD A,H            ; 
       socb @l,a                       ; OR L              ; 
       jne  reduce_delay_1             ; JR NZ,$C953       ;
       li   hl,>0040                   ; LD HL,$0040       ; 
reduce_delay_1:                        ; c953
       mov  hl,@delay                  ; LD ($CE1C),HL     ;
       .pop hl                         ; POP HL            ; 
       .pop af                         ; POP AF            ; 
       .ret                            ; RET               ;

* Sets the door attributes for the "time of day".
set_day_attr:                          ; c959
       li   hl,door_attr_day           ; LD HL,$C96F       ; {Call #R$C966 using #R$C96F.
       jmp  set_door_attr              ; JR $C966          ; }
set_dusk_attr:                         ; c95e
       li   hl,door_attr_dusk          ; LD HL,$C987       ; {Call #R$C966 using #R$C987.
       jmp  set_door_attr              ; JR $C966          ; }
set_night_attr:                        ; c963
       li   hl,door_attr_night         ; LD HL,$C99F       ; Call #R$C966 using #R$C99F.
* Note this is for the opened door background hence it starts from frame 2 (as
* frame 1 is a closed door).
set_door_attr:                         ; c966 TODO
       li   de,door_frame_2_attrs      ; LD DE,$D6B9       ; {Copies $18 bytes of data to
       li   bc,>0018                   ; LD BC,$0018       ; #R$D6B9, then return.
       .ldir                           ; LDIR              ;
       .ret                            ; RET               ; }
* Door frame attribute data for each day phase.
door_attr_day:                         ; c96f
       byte >28,>28,>30,>30,>30,>30,>30,>30                          ; 
       byte >28,>28,>28,>28,>30,>30,>30,>30                          ; 
       byte >28,>28,>28,>28,>28,>28,>30,>28                          ; 
door_attr_dusk:                        ; c987
       byte >0D,>0D,>30,>30,>30,>30,>30,>30                          ; 
       byte >0D,>0D,>0D,>0D,>30,>30,>30,>30                          ; 
       byte >0D,>0D,>0D,>0D,>0D,>0D,>30,>0D                          ; 
door_attr_night:                       ; c99f
       byte >05,>05,>30,>30,>30,>30,>30,>30                          ; 
       byte >05,>05,>05,>05,>30,>30,>30,>30                          ; 
       byte >05,>05,>05,>05,>05,>05,>30,>05                          ;

* Clears the cashbox flags, clears the screen and displays the phase number.
init_game_loop:                        ; c9b7
       li   hl,>0101                   ; LD HL,$0101       ; {Writes $0101 to #R$D45C.
       mov  hl,@cashbox_ref            ; LD ($D45C),HL     ; }
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Clear down the deposit flags
       li   de,door_deposited_02       ; LD DE,$CC8E       ; (copies $00 to each from
       li   bc,>000d                   ; LD BC,$000D       ; #R$CC8D).
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ldir                           ; LDIR              ; }
       sb   a,a                        ; XOR A             ; {Call #R$C9D0 (using $00).
       .call @clear_screen             ; CALL $C9D0        ; }
       .call @display_phase            ; JR $C9DD          ; Jump to #R$C9DD.
       .ret

* This routine has the ability to write any value across the screen buffer, however it's only ever called with
* #REGa=$00 (clear screen).
clear_screen:                          ; c9d0
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Clears the screen buffer by
;       li   de,zx_screen+1             ; LD DE,$4001       ; writing $00 to all 6912 memory
;       li   bc,>1aff                   ; LD BC,$1AFF       ; locations.
;       movb a,*hl                      ; LD (HL),A         ;
;       .ldir                           ; LDIR              ;
       .ret                            ; RET               ; }

* Displays the current "phase".
display_phase:                         ; c9dd
       li   hl,phase_copy              ; LD HL,$CA4E       ; {Copies #R$CA4E into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ; 
       .ldir                           ; LDIR              ; }
       mov  @phase_ascii,hl            ; LD HL,($CA5A)     ; {Writes #R$CA5A to #R$CA5C (at
;       mov  hl,@progress_buffer+5      ; LD ($CA61),HL     ; $CA61 - just overwriting the
                                                           ; numeric part).}
       movb h,*de+
       movb @l,*de
       li   hl,phase                   ; LD HL,$CA4A       ; {Call #R$CA19 with #R$CA4A.
       .call @progress_base_10         ; CALL $CA19        ; }


;       mov  @progress_buffer+5,hl      ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA5A.
       movb @progress_buffer+5,h
       movb @progress_buffer+6,@l
       mov  hl,@phase_ascii            ; LD ($CA5A),HL     ; }
       .ret                            ; RET               ; Return.

* Displays the current "day".
display_day:                           ; c9fb
       li   hl,day_copy                ; LD HL,$CA53       ; {Copies #R$CA53 into #R$CA5C ($05
       li   de,progress_buffer         ; LD DE,$CA5C       ; bytes of text data).
       li   bc,>0005                   ; LD BC,$0005       ; 
       .ldir                           ; LDIR              ; }
       mov  @day_ascii,hl              ; LD HL,($CA58)     ; {Writes #R$CA58 to #R$CA5C (at
;       mov  hl,@progress_buffer+5      ; LD ($CA61),HL     ; $CA61 - just overwriting the
                                                           ; numeric part).}
       movb h,*de+
       movb @l,*de
       li   hl,day                     ; LD HL,$CA4C       ; {Call #R$CA19 with #R$CA4C.
       .call @progress_base_10         ; CALL $CA19        ; }
;       mov  @progress_buffer+5,hl      ; LD HL,($CA61)     ; {Writes $CA61 back to #R$CA58.
       movb @progress_buffer+5,h
       movb @progress_buffer+6,@l
       mov  hl,@day_ascii              ; LD ($CA58),HL     ; }
       .ret                            ; RET               ; Return.

* This routine is for converting progress numbers into ASCII. On entry #REGhl
* will be either #R$CA4A or #R$CA4C.
progress_base_10:                      ; ca19
       movb *hl,a                      ; LD A,(HL)         ; {If the passed number is not more
       ab   one,a                      ; INC A             ; than 10 jump to #R$CA27.
       cb   a,@bytes+10                ; CP $0A            ; 
       jhe  progress_divisible_10      ; JR NC,$CA27       ; }
       movb a,*hl                      ; LD (HL),A         ; {Stores the ASCII representation of the number at $CA62 (for #R$CA5C). It adds ASCII "0" so for example 1
       ab   @bytes+48,a                ; ADD A,$30         ; ends up being 1 + $30 = $31 (e.g. "1" in ASCII).
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; }
       jmp  print_progress             ; JR $CA38          ; Jump to #R$CA38.
* Ensures the progress digit remains 0-9. On entry #REGhl will be either
* #R$CA4A or #R$CA4C.
progress_divisible_10:                 ; ca27
       sb   *hl,*hl                    ; LD (HL),$00       ; Reset the current progress digit
                                                           ; to $00.
       inc  hl                         ; INC HL            ; Use the secondary digit of the
                                                           ; currently focused progress.
* Note this doesn't account for a third digit and so leads to eventual corruption. Once past day/ phase "99", this
* will display "00" and past "09" the first ASCII digit doesn't point to any usable image data. Note however, this
* occurs after ~4 hours of game play so isn't especially an issue.
       ab   one,*hl                    ; INC (HL)          ; Increase this second digit by
                                                           ; one.
       movb *hl,a                      ; LD A,(HL)         ; {Add ASCII "0" so for example 1 ends up being 1 + $30 = $31 (e.g. "1" in ASCII). Write this number to $CA61
       ab   @bytes+48,a                ; ADD A,$30         ; (for #R$CA5C).
       movb a,@progress_buffer+5       ; LD ($CA61),A      ; }
       dec  hl                         ; DEC HL            ; Move back to point to the
                                                           ; original location of #REGhl.
       movb *hl,a                      ; LD A,(HL)         ; {Again, add ASCII "0" for this
       ab   @bytes+48,a                ; ADD A,$30         ; digit too. Write this number to
       movb a,@progress_buffer+6       ; LD ($CA62),A      ; $CA62 (for #R$CA5C).}
* Prints the current progress buffer message to the screen.
print_progress:                        ; ca38
       li   hl,progress_buffer         ; LD HL,$CA5C       ; {Prints #R$CA5C to the screen buffer at $486C using #R$CBD2.
       li   de,zx_screen+>086c         ; LD DE,$486C       ; #TABLE(default,centre,centre,centre,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text      ; CALL $CBD2        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
       movb @bytes+80,b                ; LD B,$50          ; {Interrupt driven HALT loop ($50
progress_halt_loop:                    ; ca46
       bl   @ti_vsync                  ; HALT              ; cycles).
       sb   one,b                      ; DJNZ $CA46        ; }
       jne  progress_halt_loop         ;                   
       .ret                            ; RET               ; Return.

* Game variables
phase:                                 ; ca4a
       data >0600                      ; BCD low endian
day:                                   ; ca4c
       data >0100                      ; BCD low endian
phase_copy:                            ; ca4e
       text 'PHASE'                                                  ; 
day_copy:                              ; ca53
       text ' DAY '                                                  ; 
       even
day_ascii:                             ; ca58
       text ' 1'                                                     ; 
       even
phase_ascii:                           ; ca5a
       text ' 6'                                                     ; 
progress_buffer:                       ; ca5c
       text 'PHASE 6',>ff                                            ; 

* Clears the screen and displays the day number.
cls_display_day:                       ; ca64
       sb   a,a                        ; XOR A             ; {Clears the screen by passing $00
       .call @clear_screen             ; CALL $C9D0        ; to #R$C9D0.}
       .call @display_day              ; CALL $C9FB        ; Call #R$C9FB.
       .ret                            ; RET               ; Return.

* Clear down the day/ progress states.
init_progress:                         ; ca6c
       li   hl,>0000                   ; LD HL,$0000       ; {Clears #R$CA4A and #R$CA4C
       mov  hl,@phase                  ; LD ($CA4A),HL     ; (writes $0000 to them).
       mov  hl,@day                    ; LD ($CA4C),HL     ; }
       movb @bytes+32,a                ; LD A,$20          ; {Writes ASCII space ($20) to $CA61 and ASCII "0" ($30) to $CA62 (i.e. writes " 0" to the numeric portion of
       li   hl,progress_buffer+5       ; LD HL,$CA61       ; #R$CA5C).
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       movb @bytes+48,a                ; LD A,$30          ; 
       movb a,*hl                      ; LD (HL),A         ; }
       .ret                            ; RET               ; Return.

cashboxes_completed_flag:              ; ca80
       byte >00                                                      ; 

run_phase:                             ; ca81
       .call @init_and_run_game_loop   ; CALL $CAC8        ;
       jnc  phase_completed            ; RET C             ; TODO: check code.
       b    @return_with_carry         ;
phase_completed:
*      Flash cashboxes
       movb @bytes+16,b                ; LD B,$10          ;
cashboxes_flash_loop:                  ; ca87
       .push bc                        ; PUSH BC           ; 
       movb b,a                        ; LD A,B            ; 
       andi a,1*256                    ; AND $01           ; 
       .call @set_all_deposit_flags    ; CALL $CAB9        ;
       movb @bytes+16,b                ; LD B,$10          ; 
       .call @halt_loop                ; CALL $CD64        ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CA87        ; 
       jne  cashboxes_flash_loop       ;                   
       movb @bytes+48,b                ; LD B,$30          ; 
       .call @halt_loop                ; CALL $CD64        ; 
       movb b,a                        ; LD A,B            ; 
       .call @set_all_deposit_flags    ; CALL $CAB9        ;
* Duel
       bl   @random_number             ; CALL $D8B0        ;
       movb a,b                        ; LD B,A            ;
       ; LD A,R                        ; LD A,R            ;
       movb a,@c                       ; LD C,A            ; bc random
       ab   b,a                        ; ADD A,B           ; 
       movb a,d                        ; LD D,A            ; d random
       movb @duel_parameter,a          ; LD A,($CBCF)      ;
;      li   hl,copied_5b80             ; LD HL,$CBB4       ;
       .call @perform_duel             ; CALL $C3C0        ;
       movb a,@duel_parameter          ; LD ($CBCF),A      ; a=@duel_counter
       sb   b,b                        ; LD B,$00          ; 
       .call @halt_loop                ; JP $CD64          ;
       b    @return_without_carry

* Set all deposit flags to a
set_all_deposit_flags:                 ; cab9
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; {Writes #REGa across all the
       li   de,door_deposited_02       ; LD DE,$CC8E       ; deposit flags (copies to each
       li   bc,>000d                   ; LD BC,$000D       ; from #R$CC8D).
       movb a,*hl                      ; LD (HL),A         ; 
       .ldir                           ; LDIR              ; }
       b    @draw_and_check_cashboxes  ; JP $CC9B          ; Jump to #R$CC9B.
*
init_and_run_game_loop:                ; cac8
       .call @init_game_loop           ; CALL $C9B7        ;
* This entry point is used by the routines at #R$CD1B and #R$CD47.
next_life:
                                       ; XOR A             ; {Writes $00 to #R$D2FE.
       movb @zero,@player_died_status  ; LD ($D2FE),A      ; }
       .call @draw_entire_playfield    ; CALL $CAD4        ;
       jmp  game_loop                  ; JR $CAE7          ;
* Why is this a routine?
draw_entire_playfield:                 ; cad4
       .call @reset_door_routine_flags ; CALL $CD68        ;
       .call @draw_doors_and_playfield ; CALL $CC3A        ;
       .call @draw_life_images         ; CALL $CC5A        ;
       .call @draw_and_check_cashboxes           ; CALL $CC9B        ;
       .call @draw_score               ; CALL $CD90        ;
       .call @draw_cashbox_selections  ; CALL $D45E        ;
       .ret                            ; RET               ; 
game_loop:                           ; cae7
;       movb @bytes+127,a               ; LD A,$7F          ; {Read keys SPACE, FULL-STOP, M,
;       ; IN A,($FE)                    ; IN A,($FE)        ; N, & B.}
;       ; RRA                           ; RRA               ;
;       joc  read_keys_1                ; JR C,$CAFB        ; Jump if space not pressed TODO: check code.
;       movb @b254,a                    ; LD A,$FE          ; {Read keys SHIFT, Z, X, C, & V.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ;
;       joc  read_keys_1                ; JR C,$CAFB        ; Jump if shift not pressed TODO: check code.
;       li   hl,copied_5b80             ; LD HL,$CBB4       ; Space and shift pressed
;       .call @_fd80                    ; CALL $FD80        ; TODO leave game and return to title screen
;read_keys_1:                           ; cafb
       li   tmp0,KEY_Z
       bl   @ti_check_key
;       movb @b254,a                    ; LD A,$FE          ; {Read keys SHIFT, Z, X, C, & V.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       movb a,tmp0                     ; BIT 1,A           ; Key Z
;       andi tmp0,2*256                 ;
       jeq  read_keys_3                ; JR NZ,$CB0B       ;
read_keys_2:                           ; cb03              ; Z pressed. Enter pause mode until X pressed.
       li   tmp0,KEY_X
       bl   @ti_check_key
;       movb @b254,a                    ; LD A,$FE          ; {Read keys SHIFT, Z, X, C, & V.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       movb a,tmp0                     ; BIT 2,A           ; Key X
;       andi tmp0,4*256                 ;
        jeq  read_keys_2                ; JR NZ,$CB03       ;
read_keys_3:                           ; cb0b
       .call @check_input              ; CALL $D2CF        ;
       mov  @delay,bc                  ; LD BC,($CE1C)     ;
delay_loop:                            ; cb12
       dec  bc                         ; DEC BC            ;
                                       ; LD A,B            ;
                                       ; OR C              ;
       jne  delay_loop                 ; JR NZ,$CB12       ;
       .call @move_right_or_left       ; CALL $D411        ;
;       .call @clear_255_bytes_at_5b00  ; CALL $CBA6        ;
* Door 1 handling
       li   ix,door_1_flags            ; LD IX,$D165       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_1_routine,hl         ; LD HL,$CE14       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser        ;                   ; If no door_1_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_1_routine       ; JR Z,$CB3F        ;
                                       ; LD HL,($CE14)     ;
!      li   de,after_door_1_routine    ; LD DE,$CB3F       ;
       .push de                        ; PUSH DE           ; Set return address
       movb one,@door_frame_ref        ; LD A,$01          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 1 routine
after_door_1_routine:                  ; cb3f
* Door 2 handling
       li   ix,door_2_flags            ; LD IX,$D173       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_2_routine,hl         ; LD HL,$CE16       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser                            ; If no door_2_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_2_routine       ; JR Z,$CB61        ;
                                       ; LD HL,($CE16)     ;
!      li   de,after_door_2_routine    ; LD DE,$CB61       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+2,@door_frame_ref   ; LD A,$02          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 2 routine
after_door_2_routine:                  ; _cb61
* Door 3 handling
       li   ix,door_3_flags            ; LD IX,$D181       ;
       sb   @8(ix),@8(ix)              ; LD (IX+$08),$00   ; clear count-down
       mov  @door_3_routine,hl         ; LD HL,$CE18       ;
                                       ; LD A,(HL)         ;
                                       ; INC HL            ;
                                       ; OR (HL)           ;
                                       ; PUSH AF           ;
       jne  !                          ; CALL Z,$CE21      ; 
       .call @character_chooser                            ; If no door_3_routine, call character_chooser
                                       ; POP AF            ;
       jmp  after_door_3_routine       ; JR Z,$CB83        ;
                                       ; LD HL,($CE18)     ;
!      li   de,after_door_3_routine    ; LD DE,$CB83       ;
       .push de                        ; PUSH DE           ; Set return address
       movb @bytes+3,@door_frame_ref   ; LD A,$03          ;
                                       ; LD ($CE1A),A      ;
       b    *hl                        ; JP (HL)           ; Execute door 3 routine
after_door_3_routine:                  ; cb83
* Check status
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 0 of #R$D2FE is not zero
       movb a,tmp0                     ; BIT 0,A           ; then jump to #R$CD47.
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,$CD47       ; }
       b    @died                     ;
!
       movb a,tmp0                     ; BIT 1,A           ; {Else if bit 1 is not zero, jump
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,$CD1B       ; to #R$CD1B.}
       b    @flash_lives               ;                   
!
       .call @scoring                  ; CALL $CDC3        ; Call #R$CDC3.
       li   hl,deposit_flag            ; LD HL,$D190       ; {If #R$D190 is not zero then call
       movb *hl,a                      ; LD A,(HL)         ; #R$CBA0 (also, writes $00 to
       ; AND A                         ; AND A             ; #R$D190 to clear it).
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  !                          ; CALL NZ,$CBA0     ; }
       .call @got_a_deposit                    ;
!
       b    @game_loop                 ; JP $CAE7          ;
got_a_deposit:                         ; cba0
       .call @scroll_dollar_sign       ; CALL $F960        ;
       b    @draw_and_check_cashboxes  ; JP $CC9B          ;
;clear_255_bytes_at_5b00:               ; cba6
;       li   hl,buffer_at_5b00          ; LD HL,$5B00       ; {Blanks $FF bytes from #R$5B00
;       li   de,buffer_at_5b00+1        ; LD DE,$5B01       ; onwards, then returns.
;       li   bc,>00ff                   ; LD BC,$00FF       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ;
        .ret                            ; RET               ; }
;copied_5b80:                           ; cbb4
;       byte >C3,>D2,>CB,>C3,>5A,>CC,>59,>CC                          ; {Copied to $5B80.
;       byte >2A,>12,>CE,>E9,>C3,>DC,>CD,>C3                          ;
;       byte >B0,>D5,>C3,>E6,>D5,>C3,>FA,>D5                          ;
;       byte >C3,>90,>CD                                              ; }
duel_parameter:                         ; cbcf                       ; This always appear to be 1
       byte >01                                                      ; 

* Draw Text.
two_tone_attributes_buffer:            ; cbd0
       data 1797                                                     ; Stores the attributes; top attribute/ bottom attribute.

* hl: address of text to print
* de: screen address
* This entry point is used by the routines at #R$5B80 and #R$C7C0.
print_two_tone_text:                   ; cbd2
       mov  bc,@two_tone_attributes_buffer ; LD ($CBD0),BC     ; Stash the attributes at #R$CBD0.
print_two_tone_text_loop:              ; cbd6
       movb *hl,a                      ; LD A,(HL)         ; {Grab the next character in the string, if it's $FF then
       cb   a,@b255                    ; CP $FF            ; return.
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       cb   a,@bytes+48                ; CP $30            ; 
       jne  print_two_tone_text_1      ; JR NZ,$CBE0       ;
       movb @bytes+58,a                ; LD A,$3A          ; 
print_two_tone_text_1:                 ; cbe0
       .push hl                        ; PUSH HL           ; 
       .push de                        ; PUSH DE           ; 
       .call @print_tt_text_space_check ; CALL $CBFC        ; 
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; 
       inc  hl                         ; INC HL            ; 
       ab   one,@e                     ; INC E             ; 
       movb @e,a                       ; LD A,E            ; 
       andi a,31*256                   ; AND $1F           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb @e,a                       ; LD A,E            ; 
       ab   @bytes+32,a                ; ADD A,$20         ; 
       movb a,@e                       ; LD E,A            ; 
       andi a,224*256                  ; AND $E0           ; 
       jne  print_two_tone_text_loop   ; JR NZ,$CBD6       ; 
       movb d,a                        ; LD A,D            ; 
       ab   @bytes+8,a                 ; ADD A,$08         ; 
       movb a,d                        ; LD D,A            ; 
       jmp  print_two_tone_text_loop   ; JR $CBD6          ; 

* This entry point is used by the routine at #R$5B9B.
print_tt_text_space_check:             ; cbfc
       cb   a,@bytes+32                ; CP $20            ; {If the character is a space then jump forward to
       jne  print_tt_text_2            ; JR NZ,$CC0E       ; #R$CC0E.}
*      Space
       li   hl,buffer_at_5b00          ; LD HL,$5B00       ; Needs 16 zeros
       li   bc,>1001                   ; LD BC,$1001       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .push hl                        ; PUSH HL           ; 
       .call @copy_routine             ; CALL $D5E6        ;
       .pop hl                         ; POP HL            ;
       jmp  print_tt_text_4            ; JR $CC1D          ;
*      Not space
print_tt_text_2:                       ; cc0e              ; not space
       cb   a,@bytes+65                ; CP $41            ; 
       jhe  print_tt_text_3            ; JR NC,$CC14       ;
       ab   @bytes+42,a                ; ADD A,$2A         ; 
print_tt_text_3:                       ; cc14
       sb   @bytes+65,a                ; SUB $41           ; 
;       ab   @bytes+10,a               ; ADD A,$0A         ;
       .push de                        ; PUSH DE           ; 
       .call @draw_tt_char             ; CALL $CDAE        ;
       .pop hl                         ; POP HL            ;
*      Attributes
print_tt_text_4:                       ; cc1d
      .call @print_tt_attribute_addr   ; CALL $CC2B        ;
       mov  @two_tone_attributes_buffer,bc ; LD BC,($CBD0)     ; {Load the stored top/ bottom attribute bytes back into
;       movb b,*hl                     ; LD (HL),B         ; #REGbc and write them to the screen.
       mov  hl,tmp1
       movb b,a
       bl   @ti_draw_attribute
;       li   de,>0020                   ; LD DE,$0020       ;
;       a    de,hl                      ; ADD HL,DE         ;
;       movb @c,*hl                     ; LD (HL),C         ; }
       ai   hl,>20
       mov  hl,tmp1
       movb @c,a
       bl   @ti_draw_attribute
       .ret                            ; RET               ; Return.

* Routine at CC2B
* 
* Used by the routine at #R$CBD0.
print_tt_attribute_addr:
       movb h,a                        ; LD A,H            ; 
       andi a,24*256                   ; AND $18           ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       sra  a,1                        ; SRA A             ; 
       ab   @bytes+88,a                ; ADD A,$58         ; 
       movb a,h                        ; LD H,A            ; 
       .ret                            ; RET               ; Return.

* Buffer for holding #R$D5E6 address.
buffer_copy_routine:                   ; cc38
       data copy_routine

* Main Playfield Initialisation.
* 
* Used by the routine at #R$C7C0.
* 
* .
* 
* Draws Main Playfield with all three doors closed.
draw_doors_and_playfield:              ; cc3a
       bl   @ti_draw_playfield
;       li   ix,buffer_copy_routine     ; LD IX,$CC38       ; {Draw the main game playfield.
;       .call @draw_playfield           ; CALL $C300        ; }
       movb one,a                      ; LD A,$01          ; {Calls #R$D664 with #R$CE1A set to $01.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+2,a                 ; LD A,$02          ; {Calls #R$D664 with #R$CE1A set to $02.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1        ; CALL $D664        ; }
       movb @bytes+3,a                 ; LD A,$03          ; {Jump to #R$D664 with #R$CE1A set to $03.
       movb a,@door_frame_ref          ; LD ($CE1A),A      ; 
       bl   @draw_door_frame_1         ; JP $D664          ; }
       .ret

* Number of lives remaining
lives:                                 ; cc59
       byte >00

* Display The "Life" Images.
* 
* Used by the routines at #R$5B83, #R$C7C0 and #R$CD1B.
draw_life_images:                      ; cc5a
*      Delete all life images
       movb @bytes+5,b                 ; LD B,$05          ; {Set up counter=$05 screen buffer=$50B6.
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ; }
delete_life_images_loop:               ; cc5f
       .push bc                        ; PUSH BC           ; {jjjss
       li   de,buffer_at_5b00          ; LD DE,$5B00       ; Needs 48 zeros
       .call @copy_life_image          ; CALL $CC84        ;
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC5F        ; }
       jne  delete_life_images_loop           ;
*      Draw life images
       movb @lives,a                   ; LD A,($CC59)      ; {If #R$CC59 are zero then return.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       cb   a,@bytes+6                 ; CP $06            ; {If #R$CC59 is more than or equal to "6" then return.
       jl   !                          ; RET NC            ; }
       .ret                            ;                   
!
       movb a,b                        ; LD B,A            ; 
       li   hl,zx_screen+>10b6         ; LD HL,$50B6       ;
draw_life_images_loop:                 ; cc77
       .push bc                        ; PUSH BC           ; 
       .call @draw_life_image          ; CALL $CC81        ;
       inc  hl                         ; INC HL            ; 
       inc  hl                         ; INC HL            ; 
       .pop bc                         ; POP BC            ; 
       sb   one,b                      ; DJNZ $CC77        ; 
       jne  draw_life_images_loop      ;                   
       .ret                            ; RET               ; Return.
draw_life_image:                       ; cc81
       li   de,gfx_lives_image         ; LD DE,$FFB8       ; {Point at the #R$FFB8 and call #R$D5E6.
copy_life_image:                       ; cc84
       .push hl                        ; PUSH HL           ; 
       li   bc,>1802                   ; LD BC,$1802       ; 
       .call @copy_routine             ; CALL $D5E6        ; }
       .pop hl                         ; POP HL            ; 
       .ret                            ; RET               ; Return.

* Deposit Flags.
* 
* Stores whether a deposit has been made for each door.
door_deposited_01:                     ; cc8d
       byte >00
door_deposited_02:                     ; cc8e
       byte >00
door_deposited_03:                     ; cc8f
       byte >00
door_deposited_04:                     ; cc90
       byte >00
door_deposited_05:                     ; cc91
       byte >00
door_deposited_06:                     ; cc92
       byte >00
door_deposited_07:                     ; cc93
       byte >00
door_deposited_08:                     ; cc94
       byte >00
door_deposited_09:                     ; cc95
       byte >00
door_deposited_10:                     ; cc96
       byte >00
door_deposited_11:                     ; cc97
       byte >00
door_deposited_12:                     ; cc98
       byte >00

* Probably represents each block of six deposit flags.
door_deposited_01_06:                  ; cc99
       byte >00
door_deposited_07_12:                  ; cc9a
       byte >00

* Draws Deposit Cashboxes.
* 
* Used by the routine at #R$C7C0.
draw_and_check_cashboxes:
       movb @cashbox_ref,a             ; LD A,($D45C)      ; {Converts #R$D45C into cash deposit box flag address
       movb a,@l                       ; LD L,A            ; (e.g. "1" becomes #R$CC8D and so on).
       sb   h,h                        ; LD H,$00          ; 
       li   de,door_deposited_01-1     ; LD DE,$CC8C       ;
       a    de,hl                      ; ADD HL,DE         ; }
       li   ix,door_1_flags            ; LD IX,$D165       ; {#REGa=#R$D16D.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_2_flags            ; LD IX,$D173       ; {#REGa=#R$D17B.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       inc  hl                         ; INC HL            ; 
       li   ix,door_3_flags            ; LD IX,$D181       ; {#REGa=#R$D189.
       movb @8(ix),a                   ; LD A,(IX+$08)     ; }
       socb *hl,a                      ; OR (HL)           ; 
       movb a,*hl                      ; LD (HL),A         ; 
       li   de,door_deposited_01_06    ; LD DE,$CC99       ; #REGde=#R$CC99.
       li   hl,door_deposited_01       ; LD HL,$CC8D       ; #REGhl=#R$CC8D.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC99.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       inc  hl                         ; INC HL            ; 
       inc  de                         ; INC DE            ; Move onto #R$CC9A.
       movb *de,a                      ; LD A,(DE)         ; Fetch the flag for #R$CC9A.
       socb *hl,a                      ; OR (HL)           ; Run a logical OR against the contents of #REGhl.
       movb a,*hl                      ; LD (HL),A         ; Writes this back into #REGhl (setting the flag).
       .call @draw_cashboxes           ; CALL $CCFB        ;
check_cashboxes_completed:             ; ccd3
       li   de,door_deposited_01       ; LD DE,$CC8D       ; Points to the cashbox flags (beginning at #R$CC8D).
       li   hl,cashboxes_completed_flag ; LD HL,$CA80       ; {Write $00 to #R$CA80.
       sb   *hl,*hl                    ; LD (HL),$00       ; }
       movb @bytes+12,b                ; LD B,$0C          ; Testing against all 12 cashboxes.
check_cashboxes_completed_loop:        ; ccdd
       movb *de,a                      ; LD A,(DE)         ; {Fetch the cashbox flag, return if its zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       inc  de                         ; INC DE            ; {Move onto the next cashbox (loop back to #R$CCDD) or
       sb   one,b                      ; DJNZ $CCDD        ; continue once all 12 are checked.}
       jne  check_cashboxes_completed_loop
       movb a,*hl                      ; LD (HL),A         ; {Write #REGa ($01) to #R$CA80.
       .ret                            ; RET               ; }

draw_cashbox:                          ; cce5
       ab   a,a                        ; ADD A,A           ; {Determines whether to send #R$FF78 or #R$FF98 to
       ab   @l,a                       ; ADD A,L           ; #R$D5E6.
       movb a,@l                       ; LD L,A            ; 
       li   de,gfx_empty_box_image     ; LD DE,$FF78       ;
       movb *ix,a                      ; LD A,(IX+$00)     ; 
       ; AND A                         ; AND A             ; 
       jeq  draw_cashbox_1             ; JR Z,$CCF4        ;
       li   de,gfx_dollar_box_image    ; LD DE,$FF98       ;
draw_cashbox_1:                        ; ccf4
       li   bc,>1002                   ; LD BC,$1002       ; 
       .call @copy_routine             ; CALL $D5E6        ; }
       .ret                            ; RET               ; Return.

* Draws all the cashboxes in two blocks of 6.
draw_cashboxes:                        ; ccfb
       li   ix,door_deposited_01       ; LD IX,$CC8D       ; {The statuses for the cashboxes begin at #R$CC8D. This routine processes them in two blocks of 6 (as they
       li   hl,zx_screen+>001f         ; LD HL,$401F       ; appear. The first block is displayed at $401F, after processing the subroutine returns and continues for the
       movb one,a                      ; LD A,$01          ; next six blocks, just altering the screen location to $4025.
       .call @draw_cashboxes_side      ; CALL $CD0A        ;
       li   hl,zx_screen+>0025         ; LD HL,$4025       ;
draw_cashboxes_side:                   ; cd0a
       movb @bytes+6,b                 ; LD B,$06          ; 
draw_cashboxes_loop:                   ; cd0c
       .push bc                        ; PUSH BC           ; 
       .push hl                        ; PUSH HL           ; 
       .push af                        ; PUSH AF           ; 
       .call @draw_cashbox             ; CALL $CCE5        ;
       .pop af                         ; POP AF            ; 
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; 
       inc  ix                         ; INC IX            ; 
       ab   one,a                      ; INC A             ; 
       sb   one,b                      ; DJNZ $CD0C        ; }
       jne  draw_cashboxes_loop        ;
       .ret                            ; RET               ; Return.

* Flash Lives/ Lose Life.
* 
* Used by the routine at #R$C7C0.
flash_lives:                           ; cd1b
       movb @bytes+10,b                ; LD B,$0A          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       li   hl,lives                   ; LD HL,$CC59       ; {Point to #R$CC59. Set a counter for $05 times and stash
       movb @bytes+5,b                 ; LD B,$05          ; it.
flash_lives_loop:                      ; cd25
       .push bc                        ; PUSH BC           ; }
       sb   one,*hl                    ; DEC (HL)          ; {Decrease the number of lives by one, stash the lives
       .push hl                        ; PUSH HL           ; memory location and draw the decreased life images.
       .call @draw_life_images              ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; {Grab the lives memory location, increase it by one, stash the location again and draw the now increased life
       ab   one,*hl                    ; INC (HL)          ; images (i.e. what they were on entry to the routine).
       .push hl                        ; PUSH HL           ; 
       .call @draw_life_images              ; CALL $CC5A        ; }
       movb @bytes+16,b                ; LD B,$10          ; {Short pause.
       .call @halt_loop                ; CALL $CD64        ; }
       .pop hl                         ; POP HL            ; 
       .pop bc                         ; POP BC            ; {Loop back until the counter is zero.
       sb   one,b                      ; DJNZ $CD25        ; }
       jne  flash_lives_loop           ;                   
                                       ; LD A,(HL)         ; {Finally decrease lives by one and if they are not zero
       sb   one,*hl                    ; DEC A             ; jump to #R$CACB.
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; }
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; {Set the carry flag and return.
       b    @return_with_carry         ; RET               ; }

* Routine at CD47
* 
* Used by the routine at #R$C7C0.
died:                                  ; cd47
       movb @player_died_status,a      ; LD A,($D2FE)      ; {If bit 2 of #R$D2FE is zero then jump to #R$CD53.
       movb a,tmp0                     ; BIT 2,A           ; 
       andi tmp0,4*256                 ;                   
       jeq  died_1                     ; JR Z,$CD53        ; }
       .call @explode_bomb             ; CALL $F880        ;
       jmp  died_2                     ; JR $CD56          ;
died_1:                                ; cd53
       .call @bang                     ; CALL $C000        ; 
died_2:                                ; cd56
       .call @reset_door_routine_flags ; CALL $CD68        ;
       li   hl,lives                   ; LD HL,$CC59       ; 
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ; Lose life
                                       ; LD (HL),A         ;
       jeq  !                          ; JP NZ,$CACB       ; 
       b    @next_life                 ;
!
       ; SCF                           ; SCF               ; 
       b    @return_with_carry         ; RET               ;

* Configurable "pause".
* 
* Used by the routines at #R$C7C0 and #R$CD1B.
*
* Loops back on itself using #REGb as a counter.
halt_loop:                             ; cd64
       bl   @ti_vsync                     ; HALT              ; {Short interrupt driven pause, and return.
       sb   one,b                      ; DJNZ $CD64        ; 
       jne  halt_loop                  ;                   
       .ret                            ; RET               ; }

* Initialise Door Flags.
* 
* Used by the routines at #R$C7C0 and #R$CD47.
*
* Populates the state flags for each door.
reset_door_routine_flags:              ; cd68
       li   ix,door_1_flags            ; LD IX,$D165       ; {Call #R$D8A1 using #REGix=#R$D165.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_2_flags            ; LD IX,$D173       ; {Call #R$D8A1 using #REGix=#R$D173.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       li   ix,door_3_flags            ; LD IX,$D181       ; {Call #R$D8A1 using #REGix=#R$D181.
       .call @reset_door_routine       ; CALL $D8A1        ; }
       .ret                            ; RET               ; Return.
*
* Score (6 bytes)
score_digit_6:                         ; cd86
       byte >00
score_digit_5:                         ; cd87
       byte >00
score_digit_4:                         ; cd88
       byte >00
score_digit_3:                         ; cd89
       byte >00
score_digit_2:                         ; cd8a
       byte >00
score_digit_1:                         ; cd8b
       byte >00

* Game status buffer entry at CD8C
       byte >00

* Game status buffer entry at CD8D
       byte >07,>4F,>52                                              ; ???

* Draw Score To The Screen
* 
* Used by the routines at #R$5B98, #R$C7C0 and #R$CDC3.
draw_score:                            ; cd90
       li   hl,score_digit_1           ; LD HL,$CD8B       ; {Starting values; #TABLE(default,centre,centre,centre,centre)
       li   de,zx_screen+>10c8         ; LD DE,$50C8       ; { =h Source | =h Screen Buffer | =h Counter }
       movb @bytes+6,b                 ; LD B,$06          ; { #R$CD8B | $50C8 | $06 }
                                                           ; TABLE#}
score_digit_loop:                      ; cd98
       .push bc                        ; PUSH BC           ; {Stash the lot.
       .push de                        ; PUSH DE           ; 
       .push hl                        ; PUSH HL           ; }
       movb *hl,a                      ; LD A,(HL)         ; {Grab the number at the source memory location;
       ; AND A                         ; AND A             ; #LIST
       jne  score_digit_non_zero       ; JR NZ,$CDA1       ; { If it's zero then add $0A (as the numbers are stored 1-2-3-4-5-6-7-8-9-0 whereas ASCII uses 0-1-2-3-4-5-6-7-8-9) }
       ab   @bytes+10,a                ; ADD A,$0A         ; { add $23 (so for example "2" will be "$25" - see #R$CDAE) }
score_digit_non_zero:                  ; cda1
       ab   @bytes+25,a                ; ADD A,$23         ; { Call #R$CDAE }
       .call @draw_tt_char              ; CALL $CDAE        ; LIST#}
       .pop hl                         ; POP HL            ; {Retrieve our current source, destination and counter
       .pop de                         ; POP DE            ; from the stack.
       .pop bc                         ; POP BC            ; }
       inc  de                         ; INC DE            ; {Increase the screen buffer memory location by one, decrease the source memory location and loop round to
       dec  hl                         ; DEC HL            ; #R$CD98 until it is zero.
       sb   one,b                      ; DJNZ $CD98        ; }
       jne  score_digit_loop           ;                   
       .ret                            ; RET               ; Return.

* Draw Numbering from Character Set Index.
* 
* Used by the routines at #R$CBD0 and #R$CD90.
* a: character index to draw
draw_tt_char:                          ; cdae
       .push de                        ; PUSH DE           ; {Using $C000 as a base address, this works out the character set memory address from a given index passed
       sb   h,h                        ; LD H,$00          ; in #REGa. To give an example using "2" ($25 - see #R$CD90);
       movb a,@l                       ; LD L,A            ; #LIST
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Loads <strong>$25</strong> as the low-order byte; #REGhl=$0025) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Times by <strong>$10</strong>; #REGhl=$250) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Add <strong>$C000</strong>=#R$C250) }
       a    hl,hl                      ; ADD HL,HL         ; LIST#
       li   de,gfx_char_a              ; LD DE,$C000       ; This is then passed to #R$D5E6.
       a    de,hl                      ; ADD HL,DE         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .pop hl                         ; POP HL            ; 
       li   bc,>1001                   ; LD BC,$1001       ;
       .call @copy_routine             ; CALL $D5E6        ; }
       .ret                            ; RET               ; Return.

* Apply Scoring
* 
* Used by the routine at #R$C7C0.
scoring:                               ; cdc3
       li   ix,door_1_flags            ; LD IX,$D165       ; {Calls #R$CDDC three times with #REGix containing;
       .call @scoring_for_door         ; CALL $CDDC        ; #LIST
       li   ix,door_2_flags            ; LD IX,$D173       ; { #R$D165 }
       .call @scoring_for_door         ; CALL $CDDC        ; { #R$D173 }
       li   ix,door_3_flags            ; LD IX,$D181       ; { #R$D181 }
       .call @scoring_for_door         ; CALL $CDDC        ; LIST#}
       .call @draw_score               ; CALL $CD90        ; Call #R$CD90.
       .ret                            ; RET               ; Return.
* Passes the higher and lower score values to #R$CDF7 for the current door.
scoring_for_door:                      ; cddc
       li   hl,score_digit_5           ; LD HL,$CD87       ; References #R$CD87.
       movb @6(ix),b                   ; LD B,(IX+$06)     ; Retrieves #REGix+$06, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @6(ix),@6(ix)              ; LD (IX+$06),$00   ; 
       .call @scoring_apply            ; CALL $CDF7        ; Call #R$CDF7.
       li   hl,score_digit_4           ; LD HL,$CD88       ; References #R$CD88.
       movb @7(ix),b                   ; LD B,(IX+$07)     ; Retrieves #REGix+$07, stores it in #REGb then reset it
                                                           ; to zero.
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; 
       .call @scoring_apply            ; CALL $CDF7        ; Call #R$CDF7.
       .ret                            ; RET               ; Return.
* Applies the door scores into the player score.
scoring_apply:                         ; cdf7
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       .call @scoring_base_10          ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       movb @bytes+5,@e                ; LD E,$05          ; Sets a counter to $05 (5 more digits in the score).
scoring_apply_loop:                    ; cdfe
       inc  hl                         ; INC HL            ; Move onto the next scoring digit.
       movb *hl,a                      ; LD A,(HL)         ; {Pass the current score digit to #R$CE08 and overwrite
       .call @scoring_base_10          ; CALL $CE08        ; the digit with the result.
       movb a,*hl                      ; LD (HL),A         ; }
       sb   one,@e                     ; DEC E             ; {Loop back to #R$CDFE until the counter is zero (and
       jne  scoring_apply_loop         ; JR NZ,$CDFE       ; all scoring digits are accounted for).}
       .ret                            ; RET               ; Return.
* Ensures the current scoring digit remains 0-9 (if $0A then it's reset and the
* carry digit is forwarded on).
scoring_base_10:                       ; ce08
       ab   b,a                        ; ADD A,B           ; Adds current score digit with passed score.
       sb   b,b                        ; LD B,$00          ; Reset passed score to zero.
       cb   a,@bytes+10                ; CP $0A            ; {Return if result is less than $0A (base 10).
       jhe  !                          ; RET C             ; }
       .ret                            ;                   
!
       sb   @bytes+10,a                ; SUB $0A           ; Subtract $0A to keep this digit in base 10 (e.g. "11"
                                                           ; becomes "1", "12" becomes "2", and so on).
       ab   one,b                      ; INC B             ; {Add one onto the passed score (which carries onto the
       .ret                            ; RET               ; next digit as it goes lowest to highest) and return.}

* Control Method Routine Alias.
* 
* Points to either #R$D392 or #R$D39B depending on the chosen control method.
control_routine_alias:                 ; ce12
       data controls_keyboard                              ; 16 bit memory location of either the keyboard or
                                                           ; joystick control routines.

* Door Routine Buffer.
* 
* These buffers point to the routines for character/ door actions for each door that are currently "in-play".
* Some example routines would be;
* #TABLE(default,centre,centre)
* { =h Routine | =h Door }
* { #R$D192 | "Normal" Bandit }
* { #R$D1DC | Bowie }
* { #R$D201 | Customer }
* { #R$D241 | Julius }
* { #R$D289 | "Drawing" Bandit }
* TABLE#
* And will also hold the door closing routines as well.
door_1_routine:                        ; ce14
       data 0                                                        ; Door 1 character/ door routine in-play.
door_2_routine:                        ; ce16
       data 0                                                        ; Door 2 character/ door routine in-play.
door_3_routine:                        ; ce18
       data 0                                                        ; Door 3 character/ door routine in-play.

* Door Frame Reference
* 
* Only one door is "active" at a time, this status buffer points to the
* "currently in-focus door".
door_frame_ref:                        ; ce1a
       byte >03                                                      ; #TABLE(default,centre,centre)
                                                                     ; { =h Value | =h Which One }
                                                                     ; { $01 | Door 1 }
                                                                     ; { $02 | Door 2 }
                                                                     ; { $03 | Door 3 }
                                                                     ; TABLE#

* Game status buffer entry at CE1B
chooser_countdown_init:                ; ce1b copied to _ce1e
       byte >03
delay:                                 ; ce1c
       data >0380
chooser_countdown:                     ; ce1e
       byte >03
* Defines the entry point for the choosing routines. Note, this isn't for one choice - they chain into each other
* this simply points to where the chain starts.
chooser_routine_ptr:                   ; ce1f
       data choose_bandit_5

* Choose Door Character.
* 
* Used by the routine at #R$C7C0.
* 
* The characters available on a particular level are determined by #R$CE1F.
* #TABLE(default,centre,centre)
* { =h Initialisation Routine | =h Door }
* { #R$CE42 | Door 1 }
* { #R$CE8D | Door 2 }
* { #R$D18A | Door 3 }
* TABLE#
* ix=door flags (door_1_flags, door_2_flags, door_3_flags)
* hl=door routine (door_1_routine, door_2_routine, door_3_routine)
*
character_chooser:                     ; ce21
* Wait 3 times before letting us in
       li   hl,chooser_countdown       ; LD HL,$CE1E       ; {Decrease #R$CE1E by one.
                                       ; LD A,(HL)         ;
       sb   one,*hl                    ; DEC A             ;
                                       ; LD (HL),A         ; }
       jeq  !                          ; RET NZ            ; Return if not zero.
       .ret                            ;                   
!
* Door also has a count-down
       movb @chooser_countdown_init,*hl ; LD A,($CE1B)      ; {Copies #R$CE1B into #R$CE1E.
                                       ; LD (HL),A         ; }
                                       ; LD A,(IX+$09)     ; {Decrease ????? by one.
       sb   one,@9(ix)                 ; DEC A             ; #TABLE(default,centre,centre)
                                       ; LD (IX+$09),A     ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       jeq  chooser                    ; RET NZ            ; Return if not zero.
       .ret                            ;
chooser:                               ; ce34
*      Reset door count-down to random value
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,31*256                   ; AND $1F           ; Keep bits 0-4 (so 0-31).
       socb @bytes+8,a                 ; OR $08            ; {Set bit 3 and write the resulting value to;
       movb a,@9(ix)                   ; LD (IX+$09),A     ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16E | Door 1 }
                                                           ; { #R$D17C | Door 2 }
                                                           ; { #R$D18A | Door 3 }
                                                           ; TABLE#}
       mov  @chooser_routine_ptr,hl    ; LD HL,($CE1F)     ; {Jump to the memory address contained at #R$CE1F.
       b    *hl                        ; JP (HL)           ; .
* Handles choosing one of the initial "default" characters. A
* character is always chosen here, so this is the end of the
* choosing routine.
choose_default_set:                    ; ce42
       .call @gen_random_number        ; CALL $DAEF        ; Call #R$DAEF.
       andi a,3*256                    ; AND $03           ; Keep only bits 0 and 1 (which determine the type of
                                                           ; character).
       jeq  init_bandit_open           ; JR Z,$CEB8        ; {Determines which character initialisation to run;
       sb   one,a                      ; DEC A             ; #TABLE(default,centre,centre)
       jne  !                          ; JP Z,$CEFC        ; { =h #REGa | =h Initialisation Routine }
       b    @init_bowie                ;                   
!
       sb   one,a                      ; DEC A             ; { $00 | #R$CEB8 }
       jne  !                          ; JP Z,$CF5E        ; { $01 | #R$CEFC }
       b    @init_customer_close       ;                   
!
       sb   one,a                      ; DEC A             ; { $02 | #R$CF5E }
       b    @init_customer_open        ; JP $CF2B          ; { $03 | #R$CF2B }
                                                           ; TABLE#}
* Handles whether or not to choose Julius.
choose_julius:                         ; ce55
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,12*256                   ; AND $0C           ; {Keep only bits 2 and 3. Jump to the next character "test" if
       jne  choose_bandit_2            ; JR NZ,$CE5F       ; this is a non-zero number at #R$CE5F.}
       b    @init_julius_open          ; JP $CFB7          ; Jump to #R$CFB7.
* Handles whether or not to choose Bandit 2.
choose_bandit_2:                       ; ce5f
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,152*256                  ; AND $98           ; {Keep only bits 3, 4 and 7. Jump to the next character "test" if
       jne  choose_bandit_3            ; JR NZ,$CE6F       ; this is a non-zero number at #R$CE6F.}
       li   hl,bandit_2_source         ; LD HL,$D119       ; Set source character data to #R$D119.
       li   de,bandit_2_buffer         ; LD DE,$D124       ; Set target character buffer to #R$D124.
       b    @choose_action             ; JP $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 3.
choose_bandit_3:                       ; ce6f
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,49*256                   ; AND $31           ; {Keep only bits 0, 4 and 5. Jump to the next character "test" if
       jne  choose_default_set         ; JR NZ,$CE42       ; this is a non-zero number then jump back to the #R$CE42.
                                                           ; }
       li   hl,bandit_3_source         ; LD HL,$D0C1       ; Set source character data to #R$D0C1.
       li   de,bandit_3_buffer         ; LD DE,$D0CC       ; Set target character buffer to #R$D0CC.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 4.
choose_bandit_4:                       ; ce7e
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,131*256                  ; AND $83           ; {Keep only bits 0, 1 and 7. Jump to the next character "test" if
       jne  choose_julius              ; JR NZ,$CE55       ; this is a non-zero number #R$CE55.}
       li   hl,bandit_4_source         ; LD HL,$D0D7       ; Set source character data to #R$D0D7.
       li   de,bandit_4_buffer         ; LD DE,$D0E2       ; Set target character buffer to #R$D0E2.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 5.
choose_bandit_5:                       ; ce8d
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,88*256                   ; AND $58           ; {Keep only bits 3, 4 and 6. Jump to the next character "test" if
       jne  choose_bandit_4            ; JR NZ,$CE7E       ; this is a non-zero number #R$CE7E.}
       li   hl,bandit_5_source         ; LD HL,$D0ED       ; Set source character data to #R$D0ED.
       li   de,bandit_5_buffer         ; LD DE,$D0F8       ; Set target character buffer to #R$D0F8.
       jmp  choose_action              ; JR $CEA9          ; Jump to #R$CEA9.
* Handles whether or not to choose Bandit 6.
choose_bandit_6:                       ; ce9c
       bl   @random_number            ; CALL $D8B0        ; Call #R$D8B0.
       andi a,113*256                  ; AND $71           ; {Keep only bits 0, 4, 5 and 6. Jump to the next character "test" if
       jne  choose_bandit_5            ; JR NZ,$CE8D       ; this is a non-zero number #R$CE8D.}
       li   hl,bandit_6_source         ; LD HL,$D103       ; Set source character data to #R$D103.
       li   de,bandit_6_buffer         ; LD DE,$D10E       ; Set target character buffer to #R$D10E.
* Stashes the chosen character source/ buffer to the door state buffer.
choose_action:                         ; cea9
       mov  hl,@12(ix)                 ; LD (IX+$0C),L     ; {Writes the character source memory address to one of the following (depending on which door is currently
                                       ; LD (IX+$0D),H     ; being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D171 | Door 1 }
                                                           ; { #R$D17F | Door 2 }
                                                           ; { #R$D18D | Door 3 }
                                                           ; TABLE#}
       movb de,@10(ix)                 ; LD (IX+$0A),E     ; {Writes the character target/ buffer memory address to one of the following (depending on which door is
                                       ; LD (IX+$0B),D     ; currently being actioned);
                                                           ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#}
       b    @init_bandit_draw_open                     ; JP $D019          ; Jump to #R$D019.

* Character Initialisations.
* 
* Used by the routines at #R$CE21 and #R$D48F.
* 
* .
* 
* Writes a "bandit opening the door" to the door flags/ cache.
init_bandit_open:                      ; ceb8
       li   de,prep_bandit_open        ; LD DE,$D192       ; {Writes #R$D192 to the address contained
*      Set hl = pointer to pointer to door routine
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
*      Set pointer to door routine to prep_bandit_open
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
*      Set hl = pointer to bandit data
       li   hl,bandit_open_source      ; LD HL,$D076       ; {Handles copying $0007 bytes of data from the address contained
*      Set de = pointer to door source data
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
*      Copy 7 bytes from bandit data to door source data
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D076.}
*      Set the flag
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F and return.
                                       ; LD ($D18F),A      ;
       .ret                            ; RET               ; }
* Writes a "bandit closing the door" to the door flags/ cache.
init_bandit_close:                     ; ced8
       li   de,prep_bandit_close       ; LD DE,$D1B7       ; {Writes #R$D1B7 to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov de,*hl                      ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,bandit_close_source                   ; LD HL,$D07D       ; {Handles copying $0007 bytes of data from the address contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .ldir                           ; LDIR              ; { #R$D167 | Door 1 }
                                                           ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D07D.}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Writes $01 to #R$D18F.
                                       ; LD ($D18F),A      ; }
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; Score?
       .ret                            ; RET               ; 
* Writes "Bowie" to the door flags/ cache.
init_bowie:                            ; cefc
       li   de,prep_bowie              ; LD DE,$D1DC       ; {Writes #R$D1DC to the address contained
       mov *ix,hl                      ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,8*256                    ; AND $08           ; 
       li   hl,bowie_source            ; LD HL,$D084       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jeq  init_bowie_set_flag        ; JR Z,$CF16        ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_bowie_set_flag:                   ; cf16
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>0009                   ; LD BC,$0009       ; 
       .ldir                           ; LDIR              ; 
       li   de,bowie_shot_action       ; LD DE,$D863       ; 
       mov  de,@4(ix)                  ; LD (IX+$04),E     ;
                                       ; LD (IX+$05),D     ;
       .ret                            ; RET               ; 
* Writes a "customer opening the door" to the door flags/ cache.
init_customer_open:                    ; cf2b
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,130*256                  ; AND $82           ; 
       li   hl,customer_open_source_2  ; LD HL,$D0A1       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_open_set_flag    ; JR NZ,$CF45       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_cust_open_set_flag:               ; cf45
       li   hl,customer_open_source_1  ; LD HL,$D09C       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ; 
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ; 
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes a "customer closing the door" to the door flags/ cache.
init_customer_close:                   ; cf5e
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Writes #R$D201 to the address contained
                                       ; LD H,(IX+$01)     ; at (depending on which door is currently being actioned);
       li   de,prep_customer           ; LD DE,$D201       ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,65*256                   ; AND $41           ; 
       li   hl,customer_close_source_2 ; LD HL,$D092       ;
       sb   *hl,*hl                    ; LD (HL),$00       ;
       movb a,a
       jne  init_cust_close_set_flag   ; JR NZ,$CF78       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_cust_close_set_flag:              ; cf78
       li   hl,customer_close_source_1 ; LD HL,$D08D       ;
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000f                   ; LD BC,$000F       ; 
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ;
       ; AND A                         ; AND A             ; 
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes a "customer being shot" to the door flags/ cache.
init_customer_shot:                    ; cf91
       li   de,prep_customer_shot      ; LD DE,$D226       ; {Writes #R$D226 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; {Loads e.g. #R$D167 (depending on which door is currently
                                       ; LD D,(IX+$03)     ; being actioned) into #REGde.}
       li   hl,customer_shot_source    ; LD HL,$D0AB       ; #REGhl=#R$D0AB.
       ai   de,6                       ; INC DE            ; {Increase #REGde by $06.
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ; }
       li   bc,>0003                   ; LD BC,$0003       ; {Copies three sequential bytes of data from #REGhl to
       .ldir                           ; LDIR              ; #REGde.}
       li   hl,copy_char_data_flag     ; LD HL,$D18F       ; {Writes $01 to #R$D18F and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }
* Writes "Julius opening the door" to the door flags/ cache.
init_julius_open:                      ; cfb7
       li   de,prep_julius_open        ; LD DE,$D241       ; {Writes #R$D241 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_open_source      ; LD HL,$D0AE       ;
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       bl   @random_number            ; CALL $D8B0        ; 
       andi a,32*256                   ; AND $20           ; 
       jne  init_julius_open_set_flag  ; JR NZ,$CFD1       ; 
       movb one,*hl                    ; LD (HL),$01       ; 
init_julius_open_set_flag:             ; cfd1
       mov  @2(ix),de                  ; LD E,(IX+$02)     ;
                                       ; LD D,(IX+$03)     ;
       li   bc,>000a                   ; LD BC,$000A       ; 
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ; 
* Writes "Julius closing the door" to the door flags/ cache.
init_julius_close:                     ; cfdd
       movb one,@julius_close_source   ; LD A,$01          ; {Writes $01 to #R$D0B8.
                                       ; LD ($D0B8),A      ; }
julius_callback:                       ; cfe2
       li   de,prep_julius_close       ; LD DE,$D265       ; {Writes #R$D265 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       li   hl,julius_close_source     ; LD HL,$D0B8       ; {Handles copying $0009 bytes of data from the address (plus 1) contained
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; at (depending on which door is currently being actioned);
                                       ; LD D,(IX+$03)     ; #TABLE(default,centre,centre)
       inc  de                         ; INC DE            ; { =h Address | =h Door }
       li   bc,>0009                   ; LD BC,$0009       ; { #R$D167 | Door 1 }
       .ldir                           ; LDIR              ; { #R$D175 | Door 2 }
                                                           ; { #R$D183 | Door 3 }
                                                           ; TABLE#
                                                           ; to #R$D0B8.}
       movb one,@copy_char_data_flag   ; LD A,$01          ;
                                       ; LD ($D18F),A      ;
       li   hl,julius_close_source     ; LD HL,$D0B8       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   a,a                        ; XOR A             ; 
       movb a,@7(ix)                   ; LD (IX+$07),A     ; 
       movb a,@6(ix)                   ; LD (IX+$06),A     ; 
       movb a,*hl                      ; LD (HL),A         ; 
       .ret                            ; RET               ; 

* Routine at D019
* 
* Used by the routine at #R$CE21.
init_bandit_draw_open:                 ; d019
       li   de,prep_bandit_draw_open   ; LD DE,$D289       ; {Writes #R$D289 to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#}
       mov  @12(ix),hl                 ; LD L,(IX+$0C)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0D)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D171 | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17F | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18D | #R$D183 | Door 3 }
                                                           ; TABLE#}
       .ret                            ; RET               ; Return.

* Routine at D037
set_state_init_bandit_draw_close:      ; d037
       movb one,a                      ; LD A,$01          ; {Writes $01 to the address contained
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       movb a,*hl                      ; LD (HL),A         ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; This is the first byte of character state data.}
init_bandit_draw_close:                ; d040
       li   de,prep_bandit_draw_close  ; LD DE,$D2AD       ; {Writes #R$D2AD to the address contained
       mov  *ix,hl                     ; LD L,(IX+$00)     ; at (depending on which door is currently being actioned);
                                       ; LD H,(IX+$01)     ; #TABLE(default,centre,centre,centre)
       mov  de,*hl                     ; LD (HL),E         ; { =h Address | =h Door | =h Target }
                                       ; INC HL            ; { #R$D165 | Door 1 | #R$CE14 }
                                       ; LD (HL),D         ; { #R$D173 | Door 2 | #R$CE16 }
                                                           ; { #R$D181 | Door 3 | #R$CE18 }
                                                           ; TABLE#
                                                           ; This is copying the actual source data into the cache where it can be manipulated by the game events.
                                                           ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Copies $000B bytes of data from (depending on which door is currently being actioned);
                                       ; LD H,(IX+$0B)     ; #TABLE(default,centre,centre)
       mov  @2(ix),de                  ; LD E,(IX+$02)     ; { =h Source | =h Destination | =h Door }
                                       ; LD D,(IX+$03)     ; { #R$D16F | #R$D167 | Door 1 }
       li   bc,>000b                   ; LD BC,$000B       ; { #R$D17D | #R$D175 | Door 2 }
       .ldir                           ; LDIR              ; { #R$D18B | #R$D183 | Door 3 }
                                                           ; TABLE#}
       movb one,@copy_char_data_flag   ; LD A,$01          ; {Initialise #R$D18F (writes $01 to it).
                                       ; LD ($D18F),A      ; }
       mov  @10(ix),hl                 ; LD L,(IX+$0A)     ; {Loads #REGa with the flag from the address contained
                                       ; LD H,(IX+$0B)     ; at (depending on which door is currently being actioned);
       movb *hl,a                      ; LD A,(HL)         ; #TABLE(default,centre,centre)
                                                           ; { =h Address | =h Door }
                                                           ; { #R$D16F | Door 1 }
                                                           ; { #R$D17D | Door 2 }
                                                           ; { #R$D18B | Door 3 }
                                                           ; TABLE#
                                                           ; As per #R$D037, this should be $01.}
       movb @bytes+2,@7(ix)            ; LD (IX+$07),$02   ; Score?
       ; AND A                         ; AND A             ;
       movb a,a
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   @7(ix),@7(ix)              ; LD (IX+$07),$00   ; Score?
       sb   *hl,*hl                    ; LD (HL),$00       ; 
       .ret                            ; RET               ; Return.

* Bandit open close
bandit_open_source:                            ; Used in init_bandit_open
       byte >01,>08,>08,>08,>60,>08,>08        ; State and timers
bandit_close_source:                           ; Used in init_bandit_close
       byte >01,>0B,>0B,>0B,>0B,>0B,>0B
* Bowie
bowie_source:                                  ; Used in init_bowie
       byte >01,>1B,>01,>08,>08,>08,>80,>08,>08
* Customer close
customer_close_source_1:                       ; Used in init_customer_close
       byte >0A,>0B,>0C,>0D,>0E
customer_close_source_2:                       ; Used in init_customer_close
       byte >00,>01,>08,>08,>08
       byte >40,>10,>08,>08,>08
* Customer open
customer_open_source_1:                        ; Used in init_customer_open
       byte >03,>04,>05,>06,>07
customer_open_source_2:                        ; Used in init_customer_open
       byte >01,>01,>08,>08,>08
       byte >38,>0C,>06,>08,>08
* Customer shot
customer_shot_source:                          ; Used in init_customer_shot
       byte >01,>0B,>0B
* Julius open/close
julius_open_source:                            ; Used in init_julius_open
       byte >00,>00,>01,>08,>08,>08,>50,>08
       byte >08,>80
julius_close_source:                           ; Used in init_julius_close
       byte >00,>01,>0B,>0B,>0B,>0B,>0B,>0B    ; {??
       byte >0B                                ; }
* Bandit 3.
bandit_3_source:
       byte >00,>10,>0F,>11,>02,>01,>08,>08    ; {Bandit 3 source data.
       byte >08,>40,>40                        ; }
bandit_3_buffer:
       byte >00,>10,>0F,>11,>02,>01,>0B,>0B    ; {Bandit 3 buffer.
       byte >0B,>0B,>0B                        ; }
* Bandit 4.
bandit_4_source:
       byte >00,>12,>13,>14,>02,>01,>08,>08    ; {Bandit 4 source data.
       byte >08,>30,>40                        ; }
bandit_4_buffer:
       byte >00,>12,>13,>14,>02,>01,>0B,>0B    ; {Bandit 4 buffer.
       byte >0B,>0B,>0B                        ; }
* Bandit 5.
bandit_5_source:
       byte >00,>15,>16,>17,>02,>01,>08,>08    ; {Bandit 5 source data.
       byte >08,>20,>38                        ; }
bandit_5_buffer:
       byte >00,>15,>16,>17,>02,>01,>0B,>0B    ; {Bandit 5 buffer.
       byte >0B,>0B,>0B                        ; }
* Bandit 6.
bandit_6_source:
       byte >00,>18,>19,>1A,>02,>01,>08,>08    ; {Bandit 6 source data.
       byte >08,>10,>38                        ; }
bandit_6_buffer:
       byte >00,>18,>19,>1A,>02,>01,>0B,>0B    ; {Bandit 6 buffer.
       byte >0B,>0B,>0B                        ; }
* Bandit 2.
bandit_2_source:
       byte >00,>08,>08,>09,>07,>01,>08,>08    ; {Bandit 2 source data.
       byte >08,>01,>30                        ; }
bandit_2_buffer:
       byte >00,>08,>08,>09,>07,>01,>0B,>0B    ; {Bandit 2 buffer.
       byte >0B,>0B,>0B                        ; }
* Door data/buffer?
door_1_data_buffer:
       byte >00,>10,>0F,>11,>02,>04,>00,>00
       byte >00,>0D,>40,>10,>08,>00,>00,>20
       byte >20,>20
door_2_data_buffer:
       byte >00,>08,>08,>09,>07,>05,>00,>00
       byte >00,>00,>00
       byte >10,>08,>00,>00,>20,>20,>20
door_3_data_buffer:
       byte >03,>04,>05,>06,>07,>01,>02,>0B    ; {Target
       byte >00,>00,>1E                        ; }
       byte >0C,>06,>08,>08,>20,>20,>20

* Door 1 Flags.
door_1_flags:                          ; d165 (IX+$00)
       data door_1_routine
door_1_source:                         ; d167 (IX+$02)
       data door_1_data_buffer
door_1_bowie_action:                   ; d169 (IX+$04)
       data bowie_bomb_action
door_1_scoring:                        ; d16b (IX+$06)
       data 0
door_1_cash_action:                    ; d16d (IX+$08)
       byte >00
door_1_count_down:                     ; d16e (IX+$09)
       byte >08
door_1_char_buffer:                    ; d16f (IX+$0a)
       data bandit_3_buffer
door_1_char_source:                    ; d171 (IX+$0c)
       data bandit_3_source

* Door 2 Flags.
door_2_flags:                          ; d173
       data door_2_routine
door_2_source:                         ; d175
       data door_2_data_buffer
door_2_bowie_action:                   ; d177
       data bowie_bomb_action
door_2_scoring:                        ; d179
       data 0
door_2_cash_action:                    ; d17b
       byte >00
door_2_count_down:                     ; d17c
       byte >06
door_2_char_buffer:                    ; d17d
       data bandit_2_buffer
door_2_char_source:                    ; d17f
       data bandit_2_source

* Door 3 Flags.
door_3_flags:                          ; d181
       data door_3_routine
door_3_source:                         ; d183
       data door_3_data_buffer
door_3_bowie_action:                   ; d185
       data bowie_bomb_action
door_3_scoring:                        ; d187
       data 0
door_3_cash_action:                    ; d189
       byte >00
door_3_count_down:                     ; d18a
       byte >1D
door_3_char_buffer:                    ; d18b
       data bandit_3_buffer
door_3_char_source:                    ; d18d
       data bandit_3_source

* Game status buffer entry at D18F
copy_char_data_flag:
       byte >00

* Game status buffer entry at D190
deposit_flag:                          ; d190
       byte >00

* Game status buffer entry at D191
sheriff_star_flag:
       byte >01

* Copy Source Character Data To Character State Data.
*
* Handles copying a "normal" bandit into the bandit state cache at #R$D71E.
prep_bandit_open:                      ; d192
*      Set hl = pointer to door source data
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
*      Copy 7 bytes from door source data to bandit state
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       .call @bandit_open_routing      ; CALL $D725        ; Call #R$D725 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
*      If flag is set then reset and copy state data back to door source data
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* And copying a successful bandit encounter to close the door.
prep_bandit_close:                     ; d1b7
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0007 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_state_ref        ; LD DE,$D71E       ; #TABLE(default,centre,centre)
       li   bc,>0007                   ; LD BC,$0007       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D71E.}
       .call @bandit_close_routing     ; CALL $D771        ; Call #R$D771 to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying Bowie state data into the state cache at #R$D7C5.
prep_bowie:                            ; d1dc
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $0009 bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bowie_good_bad          ; LD DE,$D7C5       ; #TABLE(default,centre,centre)
       li   bc,>0009                   ; LD BC,$0009       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D7C5.}
       .call @bowie_routing            ; CALL $D7CE        ; Call #R$D7CE to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying customer state data into the state cache at #R$D48F.
prep_customer:                         ; d201
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       .call @customer_routing         ; CALL $D49E        ; Call #R$D49E to begin this characters actions.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Else copy the (swapped) source back to the new target
       .ret                            ; RET               ; and return.}
* Handles copying customer "is shot" state data into the state cache at
* #R$D48F.
prep_customer_shot:                    ; d226
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000F bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,customer_frame_1        ; LD DE,$D48F       ; #TABLE(default,centre,centre)
       li   bc,>000f                   ; LD BC,$000F       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D48F.}
       .call @customer_shot            ; CALL $D57B        ; Call #R$D57B.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop de                         ; POP DE            ; 
       .pop hl                         ; POP HL            ; }
       .ex_de_hl                       ; EX DE,HL          ; Swap the source and target.
       .ldir                           ; LDIR              ; {Copy the (swapped) source back to the new target and
       .ret                            ; RET               ; return.}
* Handles copying Julius state data into the state cache at #R$D8E5.
prep_julius_open:                      ; d241
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       .call @julius_open_routing      ; CALL $D8EF        ; Call #R$D8EF.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* And copying a successful Julius encounter to close the door.
prep_julius_close:                     ; d265
       movb @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000A bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,julius_good_bad         ; LD DE,$D8E5       ; #TABLE(default,centre,centre)
       li   bc,>000a                   ; LD BC,$000A       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$D8E5.}
       .call @julius_close_routing     ; CALL $D997        ; Call #R$D997.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ;
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a                   ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* Handles copying a "drawing bandit" into the bandit state cache at #R$DA0C.
prep_bandit_draw_open:                 ; d289
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       .call @bandit_draw_open_routing ; CALL $DA17        ; Call #R$DA17.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. Write $00 to it. If it wasn't zero
       ; AND A                         ; AND A             ; then return.
                                       ; LD A,$00          ;
       movb @zero,@copy_char_data_flag ; LD ($D18F),A      ;
       movb a,a
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }
* And copying a successful "drawing bandit" encounter to close the door.
prep_bandit_draw_close:                ; d2ad
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Handles copying $000B bytes of data from the address contained
                                       ; LD H,(IX+$03)     ; at (depending on which door is currently being actioned);
       li   de,bandit_draw             ; LD DE,$DA0C       ; #TABLE(default,centre,centre)
       li   bc,>000b                   ; LD BC,$000B       ; { =h Address | =h Door }
       .push hl                        ; PUSH HL           ; { #R$D167 | Door 1 }
       .push de                        ; PUSH DE           ; { #R$D175 | Door 2 }
       .push bc                        ; PUSH BC           ; { #R$D183 | Door 3 }
       .ldir                           ; LDIR              ; TABLE#
                                                           ; to #R$DA0C.}
       .call @bandit_draw_close_routing ; CALL $DA85        ; Call #R$DA85.
       .pop bc                         ; POP BC            ; {Restore the source, target and counter from above.
       .pop hl                         ; POP HL            ; 
       .pop de                         ; POP DE            ; }
       movb @copy_char_data_flag,a     ; LD A,($D18F)      ; {Check if #R$D18F is zero. If it wasn't zero then
       ; AND A                         ; AND A             ; return.
       ; TODO: suspicious that flag is not set to 0
       movb a,@copy_char_data_flag     ; LD ($D18F),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .ldir                           ; LDIR              ; {Copy the source to the target again and return.
       .ret                            ; RET               ; }

* Routine at D2CF
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
check_input:                           ; d2cf
       mov  @control_routine_alias,hl  ; LD HL,($CE12)     ; #R$CE12
       li   de,check_input_1           ; LD DE,$D2D7       ; Return address
       .push de                        ; PUSH DE           ; 
       b    *hl                        ; JP (HL)           ;
check_input_1:                         ; d2d7
*      Clear
       movb a,@c                       ; LD C,A            ;
       sb   a,a                        ; XOR A             ;
       li   hl,byte_before_hit         ; LD HL,$D2FF       ;
       movb a,*hl+                     ; LD (HL),A         ; clear _d2ff
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear hit
                                       ; INC HL            ;
       movb a,*hl+                     ; LD (HL),A         ; clear right
                                       ; INC HL            ;
       movb a,*hl                      ; LD (HL),A         ; clear left
       movb @c,a                       ; LD A,C            ; 
*      Is 1,2,3 pressed?
       movb a,tmp0                     ; BIT 4,A           ;
       andi tmp0,16*256                ;                   
       jne  controls                   ; JR NZ,$D307       ; Yes - jump
*      No, clear 1,2,3
       li   hl,two_pressed             ; LD HL,$D303       ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear two
                                       ; INC HL            ;
       sb   *hl,*hl+                   ; LD (HL),$00       ; clear three
                                       ; INC HL            ;
       sb   *hl,*hl                    ; LD (HL),$00       ; clear one
*      Is right pressed?
       movb a,tmp0                     ; BIT 0,A           ; 
       andi tmp0,1*256                 ;                   
       jeq  !                          ; JP NZ,$D386       ; 
       b    @set_right                 ;                   
!
*      Is left pressed
       movb a,tmp0                     ; BIT 1,A           ; 
       andi tmp0,2*256                 ;                   
       jeq  !                          ; JP NZ,$D38C       ; 
       b    @set_left                  ;                   
!
       .ret                            ; RET               ;

player_died_status:                    ; d2fe
       byte >02                        ;
byte_before_hit:
       byte >00                        ; just cleared - not used
* Player Shot. Which door player is shooting at.
hit:                                   ; d300
       byte >00                                                      ; #TABLE(default,centre,centre)
                                                                     ; { =h Value | =h What }
                                                                     ; { $00 | No shot/ inactive }
                                                                     ; { $01 | Door 1 }
                                                                     ; { $02 | Door 2 }
                                                                     ; { $03 | Door 3 }
                                                                     ; TABLE#

* Player Left/ Right.
*
* These flags don't control left/ right movement they just indicate whether
* keys are being pressed/ joystick used.
right_pressed:                         ; d301
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "right".
left_pressed:                          ; d302
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "left".

* Player Shooting.
two_pressed:                           ; d303
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "2".
three_pressed:                         ; d304
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "3".
one_pressed:                           ; d305
       byte >00                                                      ; Defaults to $00, holds $01 when the player is pressing
                                                                     ; "1".
controls_byte:                         ; d306
       byte >11                                                      ; Holds the controls in one byte.
                                                                     ; #TABLE(default,centre,centre,centre)
                                                                     ; { =h Value | =h Bits | Door }
                                                                     ; { $10 | #EVAL($10, 2, 8) | Door 2 }
                                                                     ; { $11 | #EVAL($11, 2, 8) | Door 3 }
                                                                     ; { $12 | #EVAL($12, 2, 8) | Door 1 }
                                                                     ; TABLE#
* Action Controls.
* 
* Used by the routine at #R$D2CF.
* 
* On entry #REGa will contain one of;
* #TABLE(default,centre,centre,centre)
* { =h Value | =h Bits | Door }
* { $10 | #EVAL($10, 2, 8) | Door 2 }
* { $11 | #EVAL($11, 2, 8) | Door 3 }
* { $12 | #EVAL($12, 2, 8) | Door 1 }
* TABLE#
* This is written to #R$D306, and then decoded into writing a $01, $02 or $03 to #R$D300 to represent which door has
* been shot at.  This routine also writes $01 to #R$D305, #R$D303 and #R$D304 to represent the same thing.
* Before returning, #REGhl is set to the screen location for displaying the shot mask/ shot image in the centre of the
* door.
controls:                              ; d307
       li   hl,controls_byte           ; LD HL,$D306       ; {Writes #REGa to #R$D306 and sets #REGhl=#R$D300.
       movb a,*hl                      ; LD (HL),A         ; 
       li   hl,hit                     ; LD HL,$D300       ; }
       movb @c,a                       ; LD A,C            ; 
       movb a,tmp0                     ; BIT 0,A           ; {If "3" was pressed then jump to #R$D33B (a check for if
       andi tmp0,1*256                 ;                   
       jne  shot_three                 ; JR NZ,$D33B       ; bit 0 is set).}
       movb a,tmp0                     ; BIT 1,A           ; {If "1" was pressed then jump to #R$D360 (a check for if
       andi tmp0,2*256                 ;                   
       jne  shot_one                   ; JR NZ,$D360       ; bit 1 is set).}
* Handles settings flags and shot drawing location for door 2.
shot_two:                              ; d317
       movb @two_pressed,a             ; LD A,($D303)      ; {If #R$D303 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@three_pressed           ; LD ($D304),A      ; {Sets the other two door flags to zero (#R$D304 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the middle door is being shot at (write
       movb one,@two_pressed           ; LD ($D303),A      ; $01 to #R$D303 and $02 to #R$D300).
                                       ; LD A,$02          ;
       movb @bytes+2,*hl               ; LD (HL),A         ; }
       li   hl,random_seed             ; LD HL,$D8AC       ; {Increase #R$D8AC by one.
       ab   one,*hl                    ; INC (HL)          ; }
       bl   @ti_draw_door_2_shot
;       li   hl,zx_screen+>082f         ; LD HL,$482F       ; {Sets the screen location for this shot to $482F and
;       .push hl                        ; PUSH HL           ; stash it.}
;       .call @draw_shot_mask           ; CALL $D3B4        ; Draw the shot mask.
;       .pop hl                         ; POP HL            ; {Grab the screen location again, and now draw the shot.
;       .call @draw_gun_shot            ; CALL $D3CB        ; }
       b    @shot_sound_1_alias        ; JP $6500          ; Jump to #R$6500.
* Handles settings flags and shot drawing location for door 3.
shot_three:                            ; d33b
       movb @three_pressed,a           ; LD A,($D304)      ; {If #R$D304 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@one_pressed             ; LD ($D305),A      ; #R$D305).}
                                       ; INC A             ; {Indicate the the right door is being shot at (write $01
       movb one,@three_pressed         ; LD ($D304),A      ; to #R$D304 and $03 to #R$D300).
                                       ; LD A,$03          ;
       movb @bytes+3,*hl               ; LD (HL),A         ; }
       li   hl,random_seed             ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       ; SLA (HL)                      ; SLA (HL)          ; todo moved to the carry flag and bit 0 reset (zeroed).}
       bl   @ti_draw_door_3_shot
;       li   hl,zx_screen+>083a         ; LD HL,$483A       ; {Sets the screen location for this shot to $483A and
;       .push hl                        ; PUSH HL           ; stash it.}
;       .call @draw_shot_mask           ; CALL $D3B4        ; Draw the shot mask.
;       .pop hl                         ; POP HL            ; {Grab the screen location again, and now draw the shot.
;       .call @draw_gun_shot            ; CALL $D3CB        ; }
       b    @shot_sound_2_alias        ; JP $6502          ; Jump to #R$6502.
* Handles settings flags and shot drawing location for door 1.
shot_one:                              ; d360
       movb @one_pressed,a             ; LD A,($D305)      ; {If #R$D305 is not zero then return.
       ; AND A                         ; AND A             ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb a,@two_pressed             ; LD ($D303),A      ; {Sets the other two door flags to zero (#R$D303 and
       movb a,@three_pressed           ; LD ($D304),A      ; #R$D304).}
                                       ; INC A             ; {Indicate the the left door is being shot at (write $01
       movb one,@one_pressed           ; LD ($D305),A      ; to #R$D305 and $01 to #R$D300).
                                       ; LD A,$01          ;
       movb one,*hl                    ; LD (HL),A         ; }
       li   hl,random_seed             ; LD HL,$D8AC       ; {Shifts the value at #R$D8AC to the left with bit 7
       ; SLA (HL)                      ; SLA (HL)          ; todo moved to the carry flag and bit 0 reset (zeroed).}
       bl   @ti_draw_door_1_shot
;       li   hl,zx_screen+>0824         ; LD HL,$4824       ; {Sets the screen location for this shot to $4824 and
;       .push hl                        ; PUSH HL           ; stash it.}
;       .call @draw_shot_mask           ; CALL $D3B4        ; Draw the shot mask.
;       .pop hl                         ; POP HL            ; {Grab the screen location again, and now draw the shot.
;       .call @draw_gun_shot            ; CALL $D3CB        ; }
;       .call @shot_sound_3_alias       ; CALL $6504        ; Jump to #R$6504.
       .ret                            ; RET               ; Return.
* Sets the flag for indicating "right" has been pressed by the player.
set_right:                             ; d386
       li   hl,right_pressed           ; LD HL,$D301       ; {Write $01 to #R$D301 and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }
* Sets the flag for indicating "left" has been pressed by the player.
set_left:                              ; d38c
       li   hl,left_pressed            ; LD HL,$D302       ; {Write $01 to #R$D302 and return.
       movb one,*hl                    ; LD (HL),$01       ; 
       .ret                            ; RET               ; }

* Reads In-Game Joystick Controls.
controls_joystick:                     ; d392
       sb   a,a
       li   tmp0,KEY_FI
       bl   @ti_check_key
       jeq  controls_joystick_1
       movb @bytes+>10,a
controls_joystick_1:
       li   tmp0,KEY_LF
       bl   @ti_check_key
       jeq  controls_joystick_2
       socb @bytes+>02,a
controls_joystick_2:
       li   tmp0,KEY_RG
       bl   @ti_check_key
       jeq  controls_joystick_3
       socb @bytes+>01,a
controls_joystick_3:
;       li   bc,>00df                   ; LD BC,$00DF       ;
;       ; IN A,($0C)                    ; IN A,($0C)        ; #HTML(Reads input from the Kempston joystick (see <a
;                                                           ; href="../reference/pokes.html">POKES</a>)).
;       ; AND A                         ; AND A             ; {If there's nothing to read fall back to #R$D39B anyway.
;       jeq  controls_keyboard          ; JR Z,$D39B        ; }
       .ret                            ; RET               ; Return.

* Reads In-Game Keyboard Controls (1-2-3).
* 
* Used by the routine at #R$D392.
controls_keyboard:                     ; d39b
       sb   a,a                        ; LD A,$F7          ; {Read keys 1-2-3-4-5.
                                       ; IN A,($FE)        ; }
controls_input_1:                      ; d39f
       li   tmp0,KEY_1                 ; BIT 0,A           ; {If "1" isn't being pressed then jump to #R$D3A6.
       bl   @ti_check_key              ;
       jeq  controls_input_2           ; JR NZ,$D3A6       ; }
       movb @bytes+18,a                ; LD A,$12          ; {Set #REGa=$12 and return.
       .ret                            ; RET               ; }
controls_input_2:                      ; d3a6
       li   tmp0,KEY_2                 ; BIT 1,A           ; {If "2" isn't being pressed then jump to #R$D3AD.
       bl   @ti_check_key              ;
       jeq  controls_input_3           ; JR NZ,$D3AD       ; }
       movb @bytes+16,a                ; LD A,$10          ; {Set #REGa=$10 and return.
       .ret                            ; RET               ; }
controls_input_3:                      ; d3ad
       li   tmp0,KEY_3                 ; BIT 2,A           ; {If "3" isn't being pressed then jump to #R$D3E2.
       bl   @ti_check_key              ;
       jeq  controls_input_o_p         ; JR NZ,$D3E2       ; }
       movb @bytes+17,a                ; LD A,$11          ; {Set #REGa=$11 and return.
       .ret                            ; RET               ; }

* Draw Gun Shot Mask.
* 
* Used by the routine at #R$D307.
;draw_shot_mask:                        ; d3b4
;       li   de,shot_mask_image         ; LD DE,$FF58       ; {Point to #R$FF58 and set the image dimensions.
;       li   bc,>0802                   ; LD BC,$0802       ; }
;       .push hl                        ; PUSH HL           ; Stash the screen location.
;       .call @merge_shot               ; CALL $D5FA        ; Calls #R$D5FA.
;       ; HALT                          ; HALT              ; {Very short pause.
;       ; HALT                          ; HALT              ; }
;       .pop hl                         ; POP HL            ; Grab the screen location.
;       li   de,shot_mask_image         ; LD DE,$FF58       ; {Point to #R$FF58 and set the image dimensions.
;       li   bc,>0802                   ; LD BC,$0802       ; }
;       .call @merge_shot               ; CALL $D5FA        ; Calls #R$D5FA.
       .ret                            ; RET               ; Return.

* Draw Gun Shot.
* 
* Used by the routine at #R$D307.
;draw_gun_shot:                         ; d3cb
;       li   de,shot_image              ; LD DE,$FF68       ; {Point to #R$FF68 and set the image dimensions.
;       li   bc,>0802                   ; LD BC,$0802       ; }
;       .push hl                        ; PUSH HL           ; Stash the screen location.
;       .call @merge_shot               ; CALL $D5FA        ; Calls #R$D5FA.
;       ; HALT                          ; HALT              ; {Very short pause.
;       ; HALT                          ; HALT              ; }
;       .pop hl                         ; POP HL            ; Grab the screen location.
;       li   de,shot_image              ; LD DE,$FF68       ; {Point to #R$FF68 and set the image dimensions.
;       li   bc,>0802                   ; LD BC,$0802       ; }
;       .call @merge_shot               ; CALL $D5FA        ; Calls #R$D5FA.
       .ret                            ; RET               ; Return.

* Reads In-Game Controls (Left + Right).
* 
* Used by the routine at #R$D39B.
controls_input_o_p:                    ; d3e2
       li   tmp0,KEY_O                 ; LD A,$DF          ; {Read keys P-O-I-U-Y.
       bl   @ti_check_key              ; IN A,($FE)        ; }
       jeq  !                          ; CPL               ; Invert all the bits of #REGa.
       movb @bytes+2,a                 ; AND $03           ; Keep only bits 0 and 1 (i.e. we only care about "P" and
                                                           ; "O" for left and right).
       .ret                            ; RET               ; Return.
!      li   tmp0,KEY_P
       bl   @ti_check_key
       jeq  !
       movb one,a
!      .ret

* Routine at D3EA
check_ready_to_scroll:                 ; d3ea
       li   hl,door_1_routine          ; LD HL,$CE14       ; #R$CE14
       sb   a,a                        ; XOR A             ; {Sets #REGa=0 and #REGb=$06 (counter).
       li   bc,6                       ; LD B,$06          ; }
check_no_doors_active:                 ; d3f0
       socb *hl+,a                     ; OR (HL)           ;
                                       ; INC HL            ;
       dec  bc                         ; DJNZ $D3F0        ;
       jne  check_no_doors_active                        ;
       ; AND A                         ; AND A             ; 
       .pop bc                         ; POP BC            ; Pop return address off stack
       movb a,a
       jeq  !                          ; RET NZ            ; 
       .ret                            ;                   ; Return to caller's caller (game_loop) if any door active
!
       .push bc                        ; PUSH BC           ; Push return address back
       li   hl,random_seed             ; LD HL,$D8AC       ;
       ab   one,*hl                    ; INC (HL)          ; 
                                       ; LD DE,$0400       ; (TI moved)
       .call @check_cashboxes_flag     ; CALL $D407       ;
       joc  !                          ; RET NC            ; Return move_right_or_left if cashboxes not completed
       .ret                            ;                   ;
!
       .pop bc                         ; POP AF            ; Pop return address off stack
       .pop bc                         ; POP AF            ; Pop return address off stack
       ; AND A                         ; AND A             ;
       b    @return_without_carry      ; RET               ; Return to caller's caller's caller (run_phase)

check_cashboxes_flag:                  ; d407
       li   hl,cashboxes_completed_flag ; LD HL,$CA80      ;
       movb *hl,a                      ; LD A,(HL)         ; Check the flag
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; 
       b    @return_without_carry      ;                   ; Return without carry if not completed
!
       sb   *hl,*hl                    ; LD (HL),$00       ; Clear the flag
       ; SCF                           ; SCF               ; 
       b    @return_with_carry         ; RET               ; Return with carry if completed

* This entry point is used by the routine at #R$C7C0.
move_right_or_left:                    ; d411
       .call @check_ready_to_scroll    ; CALL $D3EA        ;
       li   de,>0100                                       ; Number of iterations for loop to check left/right
move_right_or_left_loop:
       .push de                        ; PUSH DE           ; de=>400
       .call @check_input              ; CALL $D2CF        ;
       movb @right_pressed,a           ; LD A,($D301)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D42D     ; 
       .call @move_cashboxes_right     ;
!
       movb @left_pressed,a            ; LD A,($D302)      ;
       ; AND A                         ; AND A             ; 
       jeq  !                          ; CALL NZ,$D449     ; 
       .call @move_cashboxes_left      ;
!
       .pop de                         ; POP DE            ; 
       dec  de                         ; DEC DE            ; 
                                       ; LD A,D            ;
                                       ; OR E              ;
       jne  move_right_or_left_loop    ; RET Z             ;
       .ret                            ;
                                       ; JR $D414          ;
move_cashboxes_right:                  ; d42d
       bl   @ti_scroll_left            ; CALL $6600        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   one,a                      ; INC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   draw_selection_and_return  ; JR C,$D43F        ;
       movb one,*hl                    ; LD (HL),$01       ; 
draw_selection_and_return:             ; d43f
       .call @draw_cashbox_selections  ; CALL $D45E        ;
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb a,@cashbox_ref             ; LD ($D45C),A      ;
       .ret                            ; RET               ; 
move_cashboxes_left:                   ; d449
       bl   @ti_scroll_right           ; CALL $6700        ;
       li   de,>0100                   ; LD DE,$0400       ;
       li   hl,cashbox_ref_new         ; LD HL,$D45D       ;
       movb *hl,a                      ; LD A,(HL)         ; 
       sb   one,a                      ; DEC A             ; 
       movb a,*hl                      ; LD (HL),A         ; 
       ; AND A                         ; AND A             ; 
       jne  draw_selection_and_return  ; JR NZ,$D43F       ;
       movb @bytes+12,*hl              ; LD (HL),$0C       ; 
       jmp  draw_selection_and_return  ; JR $D43F          ;

* Cash Deposit Box Reference.
cashbox_ref:                           ; d45c
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).
cashbox_ref_new:                       ; d45d
       byte >01                                                      ; Holds 01-12 which refer to the deposit cash boxes
                                                                     ; (#R$CC8D onwards).

* Routine at D45E
* 
* Used by the routines at #R$C7C0 and #R$D3EA.
draw_cashbox_selections:               ; _d45e
       clr  a
       movb @cashbox_ref,a             ; LD A,($D45C)      ;
       movb @bytes+56,@c               ; LD C,$38          ; Attribute black/grey
       .call @draw_cashbox_selections_1 ; CALL $D46B       ; Remove old selection
       movb @cashbox_ref_new,a         ; LD A,($D45D)      ;
       movb @bytes+58,@c               ; LD C,$3A          ; Attribute red/grey
draw_cashbox_selections_1:             ; d46b              ; Apply new selection
       movb @bytes+3,b                 ; LD B,$03          ; 
draw_cashbox_selections_2:             ; d46d
       .push af                        ; PUSH AF           ; 
       .call @draw_cashbox_selection   ; CALL $D47E        ;
       .pop af                         ; POP AF            ; 
       ab   one,a                      ; INC A             ; 
       cb   a,@bytes+13                ; CP $0D            ; 
       jl   !                          ; CALL NC,$D47B     ; 
       .call @back_to_first_cashbox                    ;
!
       sb   one,b                      ; DJNZ $D46D        ; 
       jne  draw_cashbox_selections_2                      ;
       .ret                            ; RET               ; 
back_to_first_cashbox:                 ; d47b
       movb one,a                      ; LD A,$01          ; 
       .ret                            ; RET               ; 
draw_cashbox_selection:                ; d47e
                                       ; CP $07            ; In right side?
       li   hl,zx_attributes+>0005     ; LD HL,$5805       ; Right
       cb   a,@bytes+7
       jhe  draw_cashbox_selection_1   ; JR NC,$D488       ;
       li   hl,zx_attributes+>00ff     ; LD HL,$58FF       ; Left
draw_cashbox_selection_1:              ; d488
       ab   a,a                        ; ADD A,A           ; 2*a
       ab   @l,a                       ; ADD A,L           ; l=2*a-1 or l=2*a+5
       movb a,@l                       ; LD L,A            ;
       movb @c,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       inc  hl                         ; INC HL            ; 
       mov  hl,tmp1
       bl   @ti_draw_attribute
;      movb @c,*hl                     ; LD (HL),C         ; Draw attribute
       .ret                            ; RET               ; 

* Customer Logic.
*
* Character state variables/ flags.
customer_frame_1:                      ; d48f
       byte >03                                                      ; Character frame index 1.
customer_frame_2:                      ; d490
       byte >04                                                      ; Character frame index 2.
customer_frame_3:                      ; d491
       byte >05                                                      ; Character frame index 3.
customer_frame_4:                      ; d492
       byte >06                                                      ; Character frame index 4.
customer_frame_5:                      ; d493
       byte >07                                                      ; Character frame index 5.
customer_flag_uncover:                 ; d494
       byte >01                                                      ; Represents whether the customer will move to uncover a bandit
                                                                     ; ($00 "normal" / $01 "uncover" action).
customer_state_ref:                    ; d495
       byte >02                                                      ; The current character state.
customer_1_timer:                      ; d496
       byte >0B                                                      ; Character timer 1.
customer_2_timer:                      ; d497
       byte >00                                                      ; Character timer 2.
customer_3_timer:                      ; d498
       byte >00                                                      ; Character timer 3.
customer_4_timer:                      ; d499
       byte >1E                                                      ; Character timer 4.
customer_5_timer:                      ; d49a
       byte >0C                                                      ; Character timer 5.
customer_6_timer:                      ; d49b
       byte >06                                                      ; Character timer 6.
customer_7_timer:                      ; d49c
       byte >08                                                      ; Character timer 7.
customer_8_timer:                      ; d49d
       byte >08                                                      ; Character timer 8.
* This routine looks at the current character state and routes to the correct
* subroutine.
customer_routing:                      ; d49e
       li   hl,customer_state_ref      ; LD HL,$D495       ; {#REGa=#R$D495.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  customer_open_1            ; JR Z,$D4BD        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  customer_open_2            ; JR Z,$D4CD        ; { $01 | #R$D4BD }
       sb   one,a                      ; DEC A             ; { $02 | #R$D4CD }
       jeq  customer_open_3            ; JR Z,$D4DD        ; { $03 | #R$D4DD }
       sb   one,a                      ; DEC A             ; { $04 | #R$D4ED }
       jeq  customer_open_4            ; JR Z,$D4ED        ; { $05 | #R$D524 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D540 }
       jne  !                          ; JP Z,$D524        ; { $07 | #R$D559 }
       b    @customer_uncover          ;                   
!
       sb   one,a                      ; DEC A             ; { $08 | #R$D56C }
       jne  !                          ; JP Z,$D540        ; TABLE#
       b    @customer_close_3          ;                   
!
       sb   one,a                      ; DEC A             ; 
       jne  !                          ; JP Z,$D559        ; 
       b    @customer_close_2          ;                   
!
       b    @customer_close_1          ; JP $D56C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
customer_open_1:                       ; d4bd
                                       ; LD A,($D496)      ; {Decrease #R$D496 by one, return if result is not
       sb   one,@customer_1_timer      ; DEC A             ; zero.
                                       ; LD ($D496),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
customer_open_2:                       ; d4cd
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_3         ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
customer_open_3:                       ; d4dd
                                       ; LD A,($D498)      ; {Decrease #R$D498 by one, return if result is not
       sb   one,@customer_3_timer      ; DEC A             ; zero.
                                       ; LD ($D498),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 timer...
customer_open_4:                       ; d4ed
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D499)      ; {Decrease #R$D499 by one, return if result is not
       sb   one,@customer_4_timer      ; DEC A             ; zero.
                                       ; LD ($D499),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb @customer_flag_uncover,a   ; LD A,($D494)      ; {Jump to #R$D516 if #R$D494 is not zero.
       ; AND A                         ; AND A             ; 
       jne  customer_hands_up          ; JR NZ,$D516       ; }
       movb @bytes+7,*hl               ; LD (HL),$07       ; Set #R$D495 to use state $07 (#R$D559 on the next call
                                                           ; to #R$D49E).
       movb @customer_frame_1,a        ; LD A,($D48F)      ; {Call #R$D6DF using the character frame index from
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D48F.}
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; Issue 500 points (by writing $05 to the high order
                                                           ; byte of, e.g. #R$D16B).
                                       ; LD A,$01          ; {Register this as a deposit (by writing $01 to e.g.
       movb one,@8(ix)                 ; LD (IX+$08),A     ; #R$D16D).}
       movb one,@deposit_flag          ; LD ($D190),A      ; Writes $01 to #R$D190.
       .ret                            ; RET               ; Return.
* Handle customer putting their hands up.
customer_hands_up:                     ; d516
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_2,a        ; LD A,($D490)      ; Grab the character frame index from #R$D490.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles customer uncovering a "hidden" bandit action.
customer_uncover:                      ; d524
       li   de,init_customer_shot      ; LD DE,$CF91       ; {Calls #R$D5A3 with #REGde=#R$CF91.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D49A)      ; {Decrease #R$D49A by one, return if result is not
       sb   one,@customer_5_timer      ; DEC A             ; zero.
                                       ; LD ($D49A),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
                                       ; LD A,($D495)      ; {Increase #R$D495 by one.
       ab   one,@customer_state_ref    ; INC A             ;
                                       ; LD ($D495),A      ; }
       movb @customer_frame_3,a        ; LD A,($D491)      ; Grab the character frame index from #R$D491.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
customer_close_3:                      ; d540
                                       ; LD A,($D49B)      ; {Decrease #R$D49B by one, return if result is not
       sb   one,@customer_6_timer      ; DEC A             ; zero.
                                       ; LD ($D49B),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       .call @init_bandit_open         ; CALL $CEB8        ; Call #R$CEB8.
       mov  @2(ix),hl                  ; LD L,(IX+$02)     ; {Load, e.g. #R$D167 (bandit source data) into #REGhl, and
                                       ; LD H,(IX+$03)     ; write $03 to the address contained in it.
       movb @bytes+3,*hl+              ; LD (HL),$03       ; }
       inct hl                         ; INC HL            ; {Increase the pointer to the bandit source data by 3 and
                                       ; INC HL            ; write $04 to this byte.
                                       ; INC HL            ;
       movb @bytes+4,*hl               ; LD (HL),$04       ; }
       .ret                            ; RET               ; Return.
* Handle door frame 3 countdown/ transition to door frame 2.
customer_close_2:                      ; d559
                                       ; LD A,($D49C)      ; {Decrease #R$D49C by one, return if result is not
       sb   one,@customer_7_timer      ; DEC A             ; zero.
                                       ; LD ($D49C),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       li   hl,customer_state_ref      ; LD HL,$D495       ; {Increase #R$D495 by one.
       ab   one,*hl                    ; INC (HL)          ; }
       movb @customer_frame_1,a        ; LD A,($D48F)      ; Grab the character frame index from #R$D48F.
       bl   @draw_door_frame_2         ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
customer_close_1:                      ; d56c
                                       ; LD A,($D49D)      ; {Decrease #R$D49D by one, return if result is not
       sb   one,@customer_8_timer      ; DEC A             ; zero.
                                       ; LD ($D49D),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }
* Handles customer being shot.
customer_shot:                         ; d57b
       li   hl,customer_state_ref      ; LD HL,$D495       ; {If #R$D495 is zero then jump to #R$D584 else jump to
       movb *hl,a                      ; LD A,(HL)         ; #R$D58C.
       sb   one,a                      ; DEC A             ; 
       jeq  customer_shot_midair       ; JR Z,$D584        ; 
       jmp  customer_shot_floor        ; JR $D58C          ; }
customer_shot_midair:                  ; d584
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @customer_frame_4,a        ; LD A,($D492)      ; Grab the character frame index from #R$D492.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
customer_shot_floor:                   ; d58c
                                       ; LD A,($D497)      ; {Decrease #R$D497 by one, return if result is not
       sb   one,@customer_2_timer      ; DEC A             ; zero.
                                       ; LD ($D497),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       movb @customer_frame_5,a        ; LD A,($D493)      ; Grab the character frame index from #R$D493.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; Call #R$D6ED.
                                       ; LD A,$02          ; {Writes $02 to #R$D2FE.
       movb @bytes+2,@player_died_status ; LD ($D2FE),A      ; }
       .call @reset_door_routine       ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }

* Hit Detection.
* 
* Compares the #R$CE1A against the user input for a shot.
* If there isn't a shot to account for then we simply return,
* else we action a jump to the address held in #REGde on entry.
hit_detection:                         ; d5a3
                                       ; PUSH HL           ; Store #REGhl on the stack for later.
                                       ; LD A,($D300)      ; {Does a comparison of #R$D300 against #R$CE1A.
                                       ; LD HL,$CE1A       ;
       cb   @hit,@door_frame_ref       ; CP (HL)           ; }
                                       ; POP HL            ; {#HTML(Retrieve #REGhl off the stack and return if the
       jeq  !                          ; RET NZ            ; numbers compared were <em>NOT</em> the same.)}
       .ret                            ;
!      .pop af                         ; POP AF            ; Drop return address
       .ex_de_hl                       ; EX DE,HL          ; {Jumps to the address held in #REGde on entry (with
       b    *hl                        ; JP (HL)           ; TODO. 

* Character Index.
* 
* Returns the 16 bit memory location of a character from a given character
* index in #REGa.
character_addr:                        ; d5b0
       sb   h,h                        ; LD H,$00          ; {Using #R$6800 as a base address (which is the first character), this works out the character frame from a
       movb a,@l                       ; LD L,A            ; given index passed in #REGa. To give an example with $1A;
       a    hl,hl                      ; ADD HL,HL         ; #LIST
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Loads <strong>$1A</strong> as the low-order byte; #REGhl=$001A) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Times by <strong>$200</strong>; store this in #REGde=$3400) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Loads <strong>$1A</strong> as the low-order byte; #REGhl=$001A) }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Times by <strong>$10</strong>; #REGhl=$1A0) }
       a    hl,hl                      ; ADD HL,HL         ; { #REGhl+#REGde=$35A0 }
       a    hl,hl                      ; ADD HL,HL         ; { #HTML(Add <strong>$6800</strong>=#R$9DA0) }
       a    hl,hl                      ; ADD HL,HL         ; LIST#
       a    hl,hl                      ; ADD HL,HL         ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       sb   h,h                        ; LD H,$00          ; 
       movb a,@l                       ; LD L,A            ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    hl,hl                      ; ADD HL,HL         ; 
       a    de,hl                      ; ADD HL,DE         ; 
       li   de,gfx_character_00        ; LD DE,$6800       ; TODO
       a    de,hl                      ; ADD HL,DE         ; }
       .ret                            ; RET               ; Returns the address in #REGhl.

* Draw Character In Doorway.
* 
* Draws the character frame at the location of one of the three (open) doors. This is direct function, hence is
* only used when the door is open (it doesn't utilise the door buffer).
;draw_character_in_doorway:             ; d5ca
;       .call @character_addr           ; CALL $D5B0        ; Retrieve the memory location for the character frame
;                                                           ; from the passed index in #REGa.
;       .ex_de_hl                       ; EX DE,HL          ;
;       movb @bytes+88,b                ; LD B,$58          ; {Sets the height and width.
;       movb @bytes+6,@c                ; LD C,$06          ; }
;       movb @door_frame_ref,a          ; LD A,($CE1A)      ; Retrieves the currently in-focus door from #R$CE1A.
;       li   hl,zx_screen+>0082         ; LD HL,$4082       ; {Work out which screen position to use for the currently focused door;
;       sb   one,a                      ; DEC A             ; #TABLE(default,centre)
;       jeq  copy_routine               ; JR Z,$D5E6        ; { =h #REGa | =h Screen Address }
;       sb   one,a                      ; DEC A             ; { $01 | $4082 }
;       li   hl,zx_screen+>008d         ; LD HL,$408D       ; { $02 | $408D }
;       jeq  copy_routine               ; JR Z,$D5E6        ; { $03 | $4098 }
;       li   hl,zx_screen+>0098         ; LD HL,$4098       ; TABLE#
;       jmp  copy_routine               ; JR $D5E6          ; Jump to #R$D5E6 to draw the character and handle the return.
                                                           ; }

* Copy Routine.
* 
* Used by the routines at #R$5B92, #R$C300, #R$CBD0, #R$CC5A, #R$CC9B, #R$CDAE,
* #R$D5CA and #R$D664.
* 
* This routine copies bytes from #REGde TO #REGhl and uses the #REGbc register to track the number of bytes
* and the number of lines.
copy_routine:                          ; d5e6
       bl   @ti_copy_routine
;       .push bc                        ; PUSH BC           ; {Copies bytes from #REGde TO #REGhl x #REGc number of
;       .push hl                        ; PUSH HL           ; times.
;       sb   b,b                        ; LD B,$00          ;
;       .ex_de_hl                       ; EX DE,HL          ;
;       .ldir                           ; LDIR              ; }
;       .ex_de_hl                       ; EX DE,HL          ; {Restores #REGhl with the original screen buffer
;       .pop hl                         ; POP HL            ; location.}
;       ab   one,h                      ; INC H             ; {ggg
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jne  !                          ; CALL Z,$D610      ; }
;       .call @calc_attr                ;
;!
;       .pop bc                         ; POP BC            ; {Grabs #REGb and decreases it by one. Loop back round to
;       sb   one,b                      ; DJNZ $D5E6        ; #R$D5E6 if #REGb is not zero.}
;       jne  copy_routine               ;
       .ret                            ; RET               ; Return.

* Merge Gun Shot Onto Background.
* 
* Used by the routines at #R$5B95, #R$D3B4 and #R$D3CB.
merge_shot:                            ; d5fa
       .push bc                        ; PUSH BC           ; {Store #REGbc and #REGhl for later.
       .push hl                        ; PUSH HL           ; }
merge_shot_loop:                       ; d5fc
       movb *de,a                      ; LD A,(DE)         ; Loads the contents of the source address held in #REGde.
       ; XOR (HL)                      ; XOR (HL)          ; Performs a bit-by-bit XOR comparison against the contents of the destination address held by #REGhl.
                                                           ; #TABLE(default,centre,centre,centre)
                                                           ; { =h #REGa register bit | =h Comparison bit | =h #REGa bit set to }
                                                           ; { 0 | 0 | 0 }
                                                           ; { 0 | 1 | 1 }
                                                           ; { 1 | 0 | 1 }
                                                           ; { 1 | 1 | 0 }
                                                           ; TABLE#
       movb a,*hl                      ; LD (HL),A         ; Stores the result at the destination address.
       inc  hl                         ; INC HL            ; {Increase the source and destination addresses by one, decrease the counter by one. Loop back to #R$D5FC
       inc  de                         ; INC DE            ; until the #REGc counter is zero.
       sb   one,@c                     ; DEC C             ; 
       jne  merge_shot_loop            ; JR NZ,$D5FC       ; }
       .pop hl                         ; POP HL            ; Restore #REGhl with the original destination address.
       ab   one,h                      ; INC H             ; {Increase the high-order byte of #REGhl by one, if this
       movb h,a                        ; LD A,H            ; is on a screen third boundary (@todo what's the term for
       andi a,7*256                    ; AND $07           ; this?) then call #R$D610.
       jne  !                          ; CALL Z,$D610      ; }
       .call @calc_attr                ;                   
!
       .pop bc                         ; POP BC            ; {Decrease the #REGb counter by one and loop back to
       sb   one,b                      ; DJNZ $D5FA        ; #R$D5FA until it is zero.}
       jne  merge_shot                 ;                   
       .ret                            ; RET               ; Return.

* Routine at D610
* 
* Used by the routines at #R$D5E6 and #R$D5FA.
* 
* .
* 
* On entry #REGhl points to an address in the screen attribute buffer.
calc_attr:                             ; d610
       movb h,a                        ; LD A,H            ; {Let's use $58C8 as an example;
       sb   @bytes+8,a                 ; SUB $08           ; #LIST
       movb a,h                        ; LD H,A            ; { #REGa=$58 }
       movb @l,a                       ; LD A,L            ; { Subtract $08 = #REGa=$50 }
       ab   @bytes+32,a                ; ADD A,$20         ; { Write it into #REGhl=$50C8 }
       movb a,@l                       ; LD L,A            ; { #REGa=$C8 }
       joc  !                          ; RET NC            ; TODO: check code. { Add $20 = #REGa=$E8 }
       .ret                            ;                   
!
       movb h,a                        ; LD A,H            ; { Write it into #REGhl=$50E8 }
       ab   @bytes+8,a                 ; ADD A,$08         ; LIST#
       movb a,h                        ; LD H,A            ; }
       .ret                            ; RET               ; Return.

* Write Character And Door To Buffer.
* 
* Door frames 2 and 3 both contain a "section" of a game character. This is copied into a buffer by first drawing
* the game character fully to #R$EA90. Then the door frame is drawn over the top (in the correct position).
* 
* .
* 
* Draws the game character together with door frame 2.
;character_door_frame_2:                ; d61e
;       .call @character_addr           ; CALL $D5B0        ; {On entry #REGa points to a character index. The call to #R$D5B0 translates this to the memory location of
;       .call @door_buffer_copy         ; CALL $D654        ; the character frame data (held in #REGhl) and then calls #R$D654.
;                                                           ; }
;door_frame_2_copy:                     ; d624
;       li   hl,gfx_door_frame_2        ; LD HL,$BCE8       ; {Copies #R$BCE8 into the #R$EA90 (+2 bytes ~ $EA92).
;       li   de,door_buffer+2           ; LD DE,$EA92       ;
;       movb @bytes+88,b                ; LD B,$58          ;
;door_frame_2_copy_loop:                ; d62c
;       .push bc                        ; PUSH BC           ;
;       li   bc,>0005                   ; LD BC,$0005       ;
;       .ldir                           ; LDIR              ;
;       inc  de                         ; INC DE            ;
;       inc  de                         ; INC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $D62C        ; }
;       jne  door_frame_2_copy_loop     ;
;       .ret                            ; RET               ; Return.
;* Draws the game character together with door frame 3.
;character_door_frame_3:                ; d638
;       .call @character_addr           ; CALL $D5B0        ; {On entry #REGa points to a character index. The call to #R$D5B0 translates this to the memory location of
;       .call @door_buffer_copy         ; CALL $D654        ; the character frame data (held in #REGhl) and then calls #R$D654.
;                                                           ; }
;door_frame_3_copy:                     ; d63e
;       li   hl,gfx_door_frame_3        ; LD HL,$BEA0       ; {Copies #R$BEA0 into the #R$EA90 (+4 bytes ~ $EA94).
;       li   de,door_buffer+4           ; LD DE,$EA94       ;
;       movb @bytes+88,b                ; LD B,$58          ;
;door_frame_3_copy_loop:                ; d646
;       .push bc                        ; PUSH BC           ;
;       li   bc,>0003                   ; LD BC,$0003       ;
;       .ldir                           ; LDIR              ;
;       inc  de                         ; INC DE            ;
;       inc  de                         ; INC DE            ;
;       inc  de                         ; INC DE            ;
;       inc  de                         ; INC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $D646        ; }
;       jne  door_frame_3_copy_loop     ;
;       .ret                            ; RET               ; Return.
;* Draws the game character alone to the door frame buffer.
;door_buffer_copy:                      ; d654
;       li   de,door_buffer             ; LD DE,$EA90       ; {Draws a character into the #R$EA90.
;       movb @bytes+88,b                ; LD B,$58          ;
;door_buffer_copy_loop:                 ; d659
;       .push bc                        ; PUSH BC           ;
;       li   bc,>0006                   ; LD BC,$0006       ;
;       .ldir                           ; LDIR              ;
;       inc  de                         ; INC DE            ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $D659        ;
;       jne  door_buffer_copy_loop      ;
;       .ret                            ; RET               ; }

* Draw Doors.
* 
* Used by the routines at #R$CC3A, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
* 
* .
* 
* Preps door frame 1.
draw_door_frame_1:                     ; d664
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_1
       .endproc
;       li   hl,door_frame_1_attrs       ; LD HL,$D6B1       ; {Calls #R$D684 using #R$D6B1.
;       .call @door_attributes          ; CALL $D684        ; }
;       li   de,gfx_door_frame_1        ; LD DE,$BA80       ; #REGde=#R$BA80.
* Referencing the door frame index, work out the screen position and send it to
* the #R$D717 routine.
prep_door_frame:                       ; d66d
;       movb @door_frame_ref,a          ; LD A,($CE1A)      ; #REGa=#R$CE1A.
;       li   hl,zx_screen+>0082         ; LD HL,$4082       ; {Determines which screen address to use for the door reference index currently held in #REGa.
;       sb   one,a                      ; DEC A             ; #TABLE(default,centre,centre)
;       jne  !                          ; JP Z,$D717        ; { =h #REGa | =h Screen Address }
;       b    @draw_door_frame           ;
;!
;       li   hl,zx_screen+>008d         ; LD HL,$408D       ; { $01 | $4082 }
;       sb   one,a                      ; DEC A             ; { $02 | $408D }
;       jne  !                          ; JP Z,$D717        ; { $03 | $4098 }
;       b    @draw_door_frame           ;
;!
;       li   hl,zx_screen+>0098         ; LD HL,$4098       ; TABLE#
;       b    @draw_door_frame           ; JP $D717          ; Jump to #R$D717.}
;* Copies attributes for the current door frame index.
;door_attributes:                       ; d684
;       .push af                        ; PUSH AF           ; Stash the accumulator for later.
;       movb @door_frame_ref,a          ; LD A,($CE1A)      ; #REGa=#R$CE1A.
;       li   de,zx_attributes+>0082     ; LD DE,$5882       ; {#TABLE(default,centre,centre)
;       sb   one,a                      ; DEC A             ; { =h #REGa | =h Screen Address }
;       jeq  door_attributes_skip       ; JR Z,$D697        ; { $01 | $5882 }
;       li   de,zx_attributes+>008d     ; LD DE,$588D       ; { $02 | $588D }
;       sb   one,a                      ; DEC A             ; { $03 | $5898 }
;       jeq  door_attributes_skip       ; JR Z,$D697        ; TABLE#
;       li   de,zx_attributes+>0098     ; LD DE,$5898       ; ...continue from #R$D697.}
;door_attributes_skip:                  ; d697
;       movb @bytes+11,b                ; LD B,$0B          ; Sets the height of the door
;                                                           ; image.
;door_attributes_loop:                  ; d699
;       .push bc                        ; PUSH BC           ; {Stash the references for later
;       .push hl                        ; PUSH HL           ; and call #R$D6AB.
;       .push de                        ; PUSH DE           ;
;       .call @door_attributes_copy     ; CALL $D6AB        ; }
;       .pop de                         ; POP DE            ; {Moves the screen attribute
;       li   hl,>0020                   ; LD HL,$0020       ; address down to the next
;       a    de,hl                      ; ADD HL,DE         ; attribute row.
;       .ex_de_hl                       ; EX DE,HL          ; }
;       .pop hl                         ; POP HL            ; {Restore the counter and loop
;       .pop bc                         ; POP BC            ; back to #R$D699 until complete.
;       sb   one,b                      ; DJNZ $D699        ; }
;       jne  door_attributes_loop       ;
;       .pop af                         ; POP AF            ; {Restore the accumulator and
;       .ret                            ; RET               ; return.}
;* Simple helper copy routine for sending attribute data to the screen attribute
;* buffer.
;door_attributes_copy:                  ; d6ab
;       li   bc,>0007                   ; LD BC,$0007       ; {Set the door width, copy the
;       .ldir                           ; LDIR              ; attribute data to the screen and
;       .ret                            ; RET               ; return.}
* Door frame attribute data.
door_frame_1_attrs:                    ; d6b1
       byte >30,>30,>30,>30,>30,>30,>30,>30                          ; Attribute data for door frame 1.
door_frame_2_attrs:                    ; d6b9
       byte >28,>28,>30,>30,>30,>30,>30,>30                          ; Attribute data for door frame 2.
door_frame_3_attrs:                    ; d6c1
       byte >28,>28,>28,>28,>30,>30,>30,>30                          ; Attribute data for door frame 3.
door_frame_4_attrs:                    ; d6c9
       byte >28,>28,>28,>28,>28,>28,>30,>28                          ; Attribute data for door frame 4.
* Preps door frame 2.
draw_door_frame_2:                     ; d6d1
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_2
       .endproc
;       li   hl,door_frame_2_attrs       ; LD HL,$D6B9       ; {Calls #R$D684 using #R$D6B9.
;       .call @door_attributes          ; CALL $D684        ; }
;       .call @character_door_frame_2   ; CALL $D61E        ; {Prepare the character/ door image by calling #R$D61E. Then pass #R$EA90 to #R$D66D which will draw it to the
;       li   de,door_buffer             ; LD DE,$EA90       ; screen.
;       jmp  prep_door_frame            ; JR $D66D          ; }
* Preps door frame 3.
draw_door_frame_3:                     ; d6df
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_3
       .endproc
;       li   hl,door_frame_3_attrs       ; LD HL,$D6C1       ; {Calls #R$D684 using #R$D6C1.
;       .call @door_attributes          ; CALL $D684        ; }
;       .call @character_door_frame_3   ; CALL $D638        ; {Prepare the character/ door image by calling #R$D638. Then pass #R$EA90 to #R$D66D which will draw it to the
;       li   de,door_buffer             ; LD DE,$EA90       ; screen.
;       jmp  prep_door_frame            ; JR $D66D          ; }
* Preps door frame 4.
draw_door_frame_4:                     ; d6ed
       .proc
       bl   @ti_setup_draw_door_params
       bl   @ti_draw_door_frame_4
       .endproc
;       li   hl,door_frame_4_attrs       ; LD HL,$D6C9       ; {Calls #R$D684 using #R$D6C9.
;       .call @door_attributes          ; CALL $D684        ; }
;       .call @draw_character_in_doorway ; CALL $D5CA        ; The door is fully open so draw
;                                                           ; the whole character in the
;                                                           ; doorway directly.
;       movb @bytes+88,b                ; LD B,$58          ; {Reference #R$BFA8 and the
;       movb one,@c                     ; LD C,$01          ; dimensions for the copy routine.
;       li   de,gfx_door_frame_4        ; LD DE,$BFA8       ; }
;       movb @door_frame_ref,a          ; LD A,($CE1A)      ; #REGa=#R$CE1A.
;       li   hl,zx_screen+>0088         ; LD HL,$4088       ; {Determines which screen address to use for the door reference index currently held in #REGa.
;       sb   one,a                      ; DEC A             ; #TABLE(default,centre,centre)
;       jne  !                          ; JP Z,$D5E6        ; { =h #REGa | =h Screen Address }
;       b    @copy_routine              ;
;!
;       li   hl,zx_screen+>0093         ; LD HL,$4093       ; { $01 | $4088 }
;       sb   one,a                      ; DEC A             ; { $02 | $4093 }
;       jne  !                          ; JP Z,$D5E6        ; { $03 | $409E }
;       b    @copy_routine              ;
;!
;       li   hl,zx_screen+>009e         ; LD HL,$409E       ; TABLE#
;       b    @copy_routine              ; JP $D5E6          ; Jump to #R$D5E6.}
;       li   de,door_buffer             ; LD DE,$EA90       ; #REGde=#R$EA90.
;draw_door_frame:                       ; d717
;       movb @bytes+88,b                ; LD B,$58          ; {Draws the image pointed at by
;       movb @bytes+7,@c                ; LD C,$07          ; #REGde to the screen address in
;       b    @copy_routine              ; JP $D5E6          ; #REGhl using #R$D5E6.}

* Generic Bandit in Door Frame Logic.
*
* Character state variables/ flags.
bandit_state_ref:                      ; d71e
       byte >04                                                      ; The current character state.
bandit_1_timer:                        ; d71f
       byte >08                                                      ; Character timer 1.
bandit_2_timer:                        ; d720
       byte >08                                                      ; Character timer 2.
bandit_3_timer:                        ; d721
       byte >00                                                      ; Character timer 3.
bandit_4_timer:                        ; d722
       byte >55                                                      ; Character timer 4.
       byte >08                                                      ; 
       byte >08                                                      ; 
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_open_routing:                   ; d725
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_open_1              ; JR Z,$D734        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_open_2              ; JR Z,$D741        ; { $01 | #R$D734 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D741 }
       jeq  bandit_open_3              ; JR Z,$D74E        ; { $03 | #R$D74E }
       jmp  bandit_open_4              ; JR $D75B          ; { $04 | #R$D75B }
                                                           ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_open_1:                         ; d734
       movb @bandit_1_timer,a          ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_1_timer          ; LD ($D71F),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6D1 and return.}
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_open_2:                         ; d741
       movb @bandit_2_timer,a          ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_2_timer          ; LD ($D720),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6DF and return.}
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_open_3:                         ; d74e
       movb @bandit_3_timer,a          ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_3_timer          ; LD ($D721),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Pass character frame index (#R$6800(draw | $00)) to
       .ret                            ; RET               ; #R$D6ED and return.}
* Handle door frame 4 timer...
bandit_open_4:                         ; d75b
       li   de,init_bandit_close       ; LD DE,$CED8       ; {Calls #R$D5A3 with #REGde=$CED8.
       .call @hit_detection            ; CALL $D5A3        ; }
       movb @bandit_4_timer,a          ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_4_timer          ; LD ($D722),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,a                      ; INC A             ; {Writes $01 to #R$D2FE.
       movb a,@player_died_status      ; LD ($D2FE),A      ; }
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.
* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_close_routing:                  ; d771
       li   hl,bandit_state_ref        ; LD HL,$D71E       ; {#REGa=#R$D71E.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_shot_action         ; JR Z,$D783        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_close_4             ; JR Z,$D789        ; { $01 | #R$D783 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D789 }
       jeq  bandit_close_3             ; JR Z,$D798        ; { $03 | #R$D798 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D7A7 }
       jeq  bandit_close_2             ; JR Z,$D7A7        ; { $05 | #R$D7B6 }
       jmp  bandit_close_1             ; JR $D7B6          ; TABLE#}
* Handles the transition to the (#R$6A10(shot | $01)) frame in the open
* doorway.
bandit_shot_action:                    ; d783
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       ab   one,a                      ; INC A             ; Move onto next character frame (i.e. #R$6A10(shot |
                                                           ; $01)).
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle "floor frame in open doorway" countdown.
bandit_close_4:                        ; d789
       movb @bandit_1_timer,a          ; LD A,($D71F)      ; {Decrease #R$D71F by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_1_timer          ; LD ($D71F),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)) to
       bl   @draw_door_frame_4        ; CALL $D6ED        ; #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_close_3:                        ; d798
       movb @bandit_2_timer,a          ; LD A,($D720)      ; {Decrease #R$D720 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_2_timer          ; LD ($D720),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_3        ; CALL $D6DF        ; it to #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_close_2:                        ; d7a7
       movb @bandit_3_timer,a          ; LD A,($D721)      ; {Decrease #R$D721 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_3_timer          ; LD ($D721),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+2,a                 ; LD A,$02          ; {Pass character frame index (#R$6C20(floor | $02)), pass
       bl   @draw_door_frame_2        ; CALL $D6D1        ; it to #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_close_1:                        ; d7b6
       movb @bandit_4_timer,a          ; LD A,($D722)      ; {Decrease #R$D722 by one, return if result is not zero.
       sb   one,a                      ; DEC A             ; 
       movb a,@bandit_4_timer          ; LD ($D722),A      ; 
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine                 ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

* Bowie logic.
* 
* Handles all the logic around drawing Bowie and handling his "special" logic.
* 
* .
* 
* Bowie state variables/ flags.
bowie_good_bad:                        ; d7c5
       byte >01                                                      ; If this is $00 then Bowie is "good". If this is $01
                                                                     ; then he is "bad" (i.e. there's a bomb under his hat).
bowie_frame_ref:                       ; d7c6
       byte >22                                                      ; The current character frame index reference.
bowie_state_ref:                       ; d7c7
       byte >06                                                      ; The current character state.
bowie_1_timer:                         ; d7c8
       byte >00                                                      ; Character timer 1.
bowie_2_timer:                         ; d7c9
       byte >00                                                      ; Character timer 2.
bowie_3_timer:                         ; d7ca
       byte >00                                                      ; Character timer 3.
bowie_4_timer:                         ; d7cb
       byte >00                                                      ; Character timer 4.
bowie_5_timer:                         ; d7cc
       byte >00                                                      ; Character timer 5.
bowie_6_timer:                         ; d7cd
       byte >00                                                      ; Character timer 6.
* This routine looks at the current character state and routes to the correct
* subroutine.
bowie_routing:                         ; d7ce
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {#REGa=#R$D7C7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to jump to based on the current state.
       jeq  bowie_open_1               ; JR Z,$D7E3        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bowie_open_2               ; JR Z,$D7F2        ; { $01 | #R$D7E3 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D7F2 }
       jeq  bowie_open_3               ; JR Z,$D801        ; { $03 | #R$D801 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D810 }
       jeq  bowie_open_4               ; JR Z,$D810        ; { $05 | #R$D82C }
       sb   one,a                      ; DEC A             ; { $06 | #R$D83C }
       jeq  bowie_close_2              ; JR Z,$D82C        ; TABLE#
       jmp  bowie_close_1              ; JR $D83C          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
bowie_open_1:                          ; d7e3
                                       ; LD A,($D7C8)      ; {Decrease #R$D7C8 by one, return if result is not
       sb   one,@bowie_1_timer         ; DEC A             ; zero.
                                       ; LD ($D7C8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6D1 and
       bl   @draw_door_frame_2         ; CALL $D6D1        ; return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bowie_open_2:                          ; d7f2
                                       ; LD A,($D7C9)      ; {Decrease #R$D7C9 by one, return if result is not
       sb   one,@bowie_2_timer         ; DEC A             ; zero.
                                       ; LD ($D7C9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character index #R$9FB0($1B) to #R$D6DF and
       bl   @draw_door_frame_3         ; CALL $D6DF        ; return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bowie_open_3:                          ; d801
                                       ; LD A,($D7CA)      ; {Decrease #R$D7CA by one, return if result is not
       sb   one,@bowie_3_timer         ; DEC A             ; zero.
                                       ; LD ($D7CA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+27,a                ; LD A,$1B          ; {Pass character frame index #R$9FB0($1B) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bowie_open_4:                          ; d810
       mov  @4(ix),de                  ; LD E,(IX+$04)     ; {Call #R$D5A3 with a callback to either #R$D84B or
                                       ; LD D,(IX+$05)     ; #R$D85D.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D7CB)      ; {Decrease #R$D7CB by one, return if result is not
       sb   one,@bowie_4_timer         ; DEC A             ; zero.
                                       ; LD ($D7CB),A      ;
       jeq  bowie_close_3              ; RET NZ            ; }
       .ret                            ;
bowie_close_3:                         ; d821
       li   hl,bowie_state_ref         ; LD HL,$D7C7       ; {Move onto next character state (#R$D7C7).
       ab   one,*hl                    ; INC (HL)          ; }
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_3         ; CALL $D6DF        ; to #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bowie_close_2:                         ; d82c
                                       ; LD A,($D7CC)      ; {Decrease #R$D7CC by one, return if result is not
       sb   one,@bowie_5_timer         ; DEC A             ; zero.
                                       ; LD ($D7CC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bowie_frame_ref,a         ; LD A,($D7C6)      ; {Load the character frame index from #R$D7C6, pass it
       bl   @draw_door_frame_2        ; CALL $D6D1        ; to #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bowie_close_1:                         ; d83c
                                       ; LD A,($D7CD)      ; {Decrease #R$D7CD by one, return if result is not
       sb   one,@bowie_6_timer         ; DEC A             ; zero.
                                       ; LD ($D7CD),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1         ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.
* Handles marking this as something shootable.
bowie_cash_action:                     ; d84b
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; {Writes $05 to #REGix+$06 and $01 to #REGix+$07.
       movb one,@7(ix)                 ; LD (IX+$07),$01   ; } Score?
                                       ; LD A,$01          ; {Writes $01 to #REGix+$08 and #R$D190.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb one,@deposit_flag          ; LD ($D190),A      ; }
       jmp  bowie_close_3              ; JR $D821          ; Jump to #R$D821.
* Handles marking this as something unshootable.
bowie_bomb_action:                     ; d85d
       movb @bytes+5,a                 ; LD A,$05          ; {Writes $05 to #R$D2FE and return.
       movb a,@player_died_status      ; LD ($D2FE),A      ;
       .ret                            ; RET               ; }
* Handles both shooting the hats off Bowie's head, and checking/ routing on the
* last frame for the "surprise".
bowie_shot_action:                     ; d863
       li   hl,bowie_frame_ref         ; LD HL,$D7C6       ; {#REGa=#R$D7C6.
       movb *hl,a                      ; LD A,(HL)         ; }
       movb one,@6(ix)
       cb   a,@bytes+33                ; CP $21            ; Is it character frame reference (#R$AC10(1 hat |
                                                           ; $21))?
                                       ; LD (IX+$06),$01   ; Writes $01 to #REGix+$06.
       jhe  bowie_check                ; JR NC,$D875       ; TODO: check code. If Bowie is on the last frame then jump forward to
                                                           ; #R$D875.
       ab   one,a                      ; INC A             ; {Else update #R$D7C6 to point at the next frame, call
       movb a,*hl                      ; LD (HL),A         ; #R$D6ED and return.
       bl   @draw_door_frame_4         ; CALL $D6ED        ;
       .ret                            ; RET               ; }
* Checks the "good/ bad" flag and routes the gameplay accordingly.
bowie_check:                           ; d875
       movb @bowie_good_bad,a          ; LD A,($D7C5)      ; {If #R$D7C5 is zero jump to #R$D87D.
       ; AND A                         ; AND A             ; 
       jeq  bowie_state_cash           ; JR Z,$D87D        ; }
       jmp  bowie_state_bomb           ; JR $D88F          ; Jump to #R$D88F.
* Handle displaying cash character frame.
bowie_state_cash:                      ; d87d
       movb @bytes+35,a                ; LD A,$23          ; {Writes character frame reference #R$B030(cash | $23)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4         ; CALL $D6ED        ; }
       li   hl,bowie_cash_action       ; LD HL,$D84B       ; {Writes #R$D84B to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
       .ret                            ; RET               ; Return.
* Handle displaying bomb character frame.
bowie_state_bomb:                      ; d88f
       movb @bytes+34,a                ; LD A,$22          ; {Writes character frame reference #R$AE20(bomb | $22)
       movb a,@bowie_frame_ref         ; LD ($D7C6),A      ; to #R$D7C6, and pass it to #R$D6ED.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; }
       li   hl,bowie_bomb_action       ; LD HL,$D85D       ; {Writes #R$D85D to the current door flags (e.g.
       mov  hl,@4(ix)                  ; LD (IX+$04),L     ; #R$D169, #R$D177 or #R$D185).
                                       ; LD (IX+$05),H     ; }
       .ret                            ; RET               ; Return.

* Routine at D8A1
* 
* Used by the routines at #R$CD68, #R$D48F, #R$D71E, #R$D7C5, #R$D8E5 and
* #R$DA0C.
reset_door_routine:                    ; d8a1
       mov  *ix,hl                     ; LD L,(IX+$00)     ; {Blanks the 16 bit address pointed to by one of the
                                       ; LD H,(IX+$01)     ; passed door flags (i.e. writes $0000 to one of #R$CE14,
                                       ; XOR A             ; #R$CE16, #R$CE18).
       clr  *hl                        ; LD (HL),A         ;
                                       ; INC HL            ;
                                       ; LD (HL),A         ; }
       .ret                            ; RET               ; Return.

* Routine at DAEF
*
* Used by the routine at #R$CE21.
gen_random_number:                     ; daef
       bl   @random_number             ; CALL $D8B0        ;
;       movb a,@c                       ; LD C,A            ;
;       movb @>5c78,a                   ; LD A,($5C78)      ; Get FRAMES
;       src  a,3                        ; RR C              ;
;                                       ; RR C              ;
;                                       ; RR C              ;
;       ab    @c,a                      ; ADD A,C           ;
       .ret                            ; RET               ;

* Game status buffer entry at D8AC
random_seed:
       data >92ee

* Game status buffer entry at D8AE
random_flag:
       data >e51b

* Routine at D8B0
* 
* Used by the routines at #R$C7C0, #R$CE21, #R$CEB8 and #R$DAEF.
* 
random_number:                         ; d8b0
       .proc
;       bl   @ti_rnd
;       swpb tmp0
;       movb tmp0,a
       .push bc                        ; PUSH BC           ; {Stashes #REGbc and #REGhl for later.
       .push hl                        ; PUSH HL           ; }
                                       ; LD A,($D8AE)      ; {Decrease #R$D8AE by one.
       sb   one,@random_flag           ; DEC A             ;
                                       ; LD ($D8AE),A      ; }
       jne  random_number_1            ; JR NZ,$D8C8       ; If the result is not zero jump to #R$D8C8.
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       jmp  random_number_2            ; JR $D8D7          ;
random_number_1:                       ; d8c8
       mov  @random_seed,hl            ; LD HL,($D8AC)     ;
       inc  hl                         ; INC HL            ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
       a    bc,hl                      ; ADD HL,BC         ;
       sla  bc,2                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
                                       ; ADD HL,BC         ;
       a    bc,hl                      ; ADD HL,BC         ;
       .push hl                        ; PUSH HL           ;
       .pop bc                         ; POP BC            ;
       a    hl,hl                      ; ADD HL,HL         ;
random_number_2:                       ; d8d7
       a    bc,hl                      ; ADD HL,BC         ;
       dec  hl                         ; DEC HL            ;
       mov  hl,@random_seed            ; LD ($D8AC),HL     ;
       movb @l,a                       ; LD A,L            ;
       li   hl,random_flag+1           ; LD HL,$D8AF       ;
       ab   one,*hl                    ; INC (HL)          ;
       ab   *hl,a                      ; ADD A,(HL)        ;
       .pop hl                         ; POP HL            ;
       .pop bc                         ; POP BC            ;
       .endproc                         ; RET               ; 

* Julius logic.
*
* Handles all the logic around drawing Julius and handling his "special" logic.
julius_good_bad:                       ; d8e5
       byte >00                                                      ; If this is $00 then Julius is "good". If this is $01
                                                                     ; then he is "bad" (i.e. will draw on you).
julius_flag:                           ; d8e6
       byte >00                                                      ; 
julius_state_ref:                      ; d8e7
       byte >04                                                      ; The current character state.
julius_1_timer:                        ; d8e8
       byte >00                                                      ; Character timer 1.
julius_2_timer:                        ; d8e9
       byte >00                                                      ; Character timer 2.
julius_3_timer:                        ; d8ea
       byte >00                                                      ; Character timer 3.
julius_4_timer:                        ; d8eb
       byte >1B                                                      ; Character timer 4.
julius_5_timer:                        ; d8ec
       byte >08                                                      ; Character timer 5.
julius_6_timer:                        ; d8ed
       byte >08                                                      ; Character timer 6.
julius_7_timer:                        ; d8ee
       byte >80                                                      ; Character timer 7.
* This routine looks at the current character state and routes to the correct
* subroutine.
julius_open_routing:                   ; d8ef
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_open_1              ; JR Z,$D907        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_open_2              ; JR Z,$D916        ; { $01 | #R$D907 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D916 }
       jeq  julius_open_3              ; JR Z,$D925        ; { $03 | #R$D925 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D934 }
       jeq  julius_open_4              ; JR Z,$D934        ; { $05 | #R$D963 }
       sb   one,a                      ; DEC A             ; { $06 | #R$D972 }
       jeq  julius_open_5              ; JR Z,$D963        ; { $07 | #R$D981 }
       sb   one,a                      ; DEC A             ; TABLE#
       jeq  julius_open_6              ; JR Z,$D972
       jmp  julius_open_7              ; JR $D981          ; }
* Handle door frame 1 countdown/ transition to door frame 2.
julius_open_1:                         ; d907
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2        ; CALL $D6D1        ; #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
julius_open_2:                         ; d916
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3        ; CALL $D6DF        ; #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
julius_open_3:                         ; d925
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_4        ; CALL $D6ED        ; #R$D6ED and return.
       .ret                            ; RET               ; }
* Handle door frame 4 countdown.
julius_open_4:                         ; d934
       li   de,init_julius_close       ; LD DE,$CFDD       ; {Call #R$D5A3 with a callback to #R$CFDD.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @julius_good_bad,a         ; LD A,($D8E5)      ; {Jump to #R$D951 if #R$D8E5 is zero (Julius is
       ; AND A                         ; AND A             ; "good").
       jeq  julius_state_4_close       ; JR Z,$D951        ; }
* Changes the frame to show Julius drawing his pistol.
       movb @bytes+7,*hl               ; LD (HL),$07       ; Writes "07" to #R$D8E7.
       movb @bytes+37,a                ; LD A,$25          ; {Pass character index (#R$B450(draw | $25)) to #R$D6ED
       bl   @draw_door_frame_4         ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Set up (and begin) closing the door.
julius_state_4_close:                  ; d951
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_3         ; CALL $D6DF        ; #R$D6DF.}
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_open_5:                         ; d963
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+36,a                ; LD A,$24          ; {Pass character index (#R$B240(stand off | $24)) to
       bl   @draw_door_frame_2        ; CALL $D6D1        ; #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_open_6:                         ; d972
                                       ; LD A,($D8ED)      ; {Decrease #R$D8ED by one, return if result is not
       sb   one,@julius_6_timer        ; DEC A             ; zero.
                                       ; LD ($D8ED),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

julius_open_7:                         ; d981
       li   de,julius_callback         ; LD DE,$CFE2       ; {Call #R$D5A3 with a callback to #R$CFE2.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($D8EE)      ; {Decrease #R$D8EE by one, return if result is not
       sb   one,@julius_7_timer        ; DEC A             ; zero.
                                       ; LD ($D8EE),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
                                       ; INC A             ; Move onto next character state.
       movb one,@player_died_status    ; LD ($D2FE),A      ; Write $01 to #R$D2FE.
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
       .ret                            ; RET               ; Return.

* This routine looks at the current character state and routes to the correct
* subroutine.
julius_close_routing:                  ; d997
       li   hl,julius_state_ref        ; LD HL,$D8E7       ; {#REGa=#R$D8E7.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  julius_close_1             ; JR Z,$D9A9        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  julius_close_2             ; JR Z,$D9B8        ; { $01 | #R$D9A9 }
       sb   one,a                      ; DEC A             ; { $02 | #R$D9B8 }
       jeq  julius_close_3             ; JR Z,$D9D3        ; { $03 | #R$D9D3 }
       sb   one,a                      ; DEC A             ; { $04 | #R$D9E2 }
       jeq  julius_close_4             ; JR Z,$D9E2        ; { $05 | #R$D9F1 }
       jmp  julius_close_5             ; JR $D9F1          ; TABLE#}
* Handles state countdown/ transition to character frame #R$B660($26).
julius_close_1:                        ; d9a9
                                       ; LD A,($D8E8)      ; {Decrease #R$D8E8 by one, return if result is not
       sb   one,@julius_1_timer        ; DEC A             ; zero.
                                       ; LD ($D8E8),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+38,a                ; LD A,$26          ; {Pass character index #R$B660(shot | $26) to #R$D6ED
       bl   @draw_door_frame_4        ; CALL $D6ED        ; and return.
       .ret                            ; RET               ; }
* Handles state countdown/ transition to character frame #R$B870($27).
julius_close_2:                        ; d9b8
                                       ; LD A,($D8E9)      ; {Decrease #R$D8E9 by one, return if result is not
       sb   one,@julius_2_timer        ; DEC A             ; zero.
                                       ; LD ($D8E9),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6ED.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; }
       movb @julius_flag,a             ; LD A,($D8E6)      ; {Return if #R$D8E6 is zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       ab   one,a                      ; INC A             ; {Else write #R$D8E6+1 to #R$D2FE, call #R$D8A1 and
       movb a,@player_died_status      ; LD ($D2FE),A      ; return.
       .call @reset_door_routine       ; CALL $D8A1        ;
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
julius_close_3:                        ; d9d3
                                       ; LD A,($D8EA)      ; {Decrease #R$D8EA by one, return if result is not
       sb   one,@julius_3_timer        ; DEC A             ; zero.
                                       ; LD ($D8EA),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6DF
       bl   @draw_door_frame_3        ; CALL $D6DF        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
julius_close_4:                        ; d9e2
                                       ; LD A,($D8EB)      ; {Decrease #R$D8EB by one, return if result is not
       sb   one,@julius_4_timer        ; DEC A             ; zero.
                                       ; LD ($D8EB),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bytes+39,a                ; LD A,$27          ; {Pass character index #R$B870(floor | $27) to #R$D6D1
       bl   @draw_door_frame_2        ; CALL $D6D1        ; and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
julius_close_5:                        ; d9f1
                                       ; LD A,($D8EC)      ; {Decrease #R$D8EC by one, return if result is not
       sb   one,@julius_5_timer        ; DEC A             ; zero.
                                       ; LD ($D8EC),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine       ; CALL $D8A1        ; Call #R$D8A1.
                                       ; LD A,$01          ; {Writes $01 to #R$D190 and #REGix+8. Writes $05 to
       movb one,@deposit_flag          ; LD ($D190),A      ; #REGix+6 and return.
       movb one,@8(ix)                 ; LD (IX+$08),A     ;
       movb @bytes+5,@6(ix)            ; LD (IX+$06),$05   ; 
       .ret                            ; RET               ; }

* Drawing Bandit Logic.
*
* Character state variables/ flags.
bandit_draw:                           ; da0c
       byte >00                                                      ; 
bandit_draw_frame_1:                   ; da0d
       byte >08                                                      ; Character frame index 1.
bandit_draw_frame_2:                   ; da0e
       byte >08                                                      ; Character frame index 2.
bandit_draw_frame_3:                   ; da0f
       byte >09                                                      ; Character frame index 3.
bandit_draw_frame_4:                   ; da10
       byte >07                                                      ; Character frame index 4.
bandit_draw_state_ref:                 ; da11
       byte >05                                                      ; The current character state.
bandit_draw_1_timer:                   ; da12
       byte >00                                                      ; Character timer 1.
bandit_draw_2_timer:                   ; da13
       byte >00                                                      ; Character timer 2.
bandit_draw_3_timer:                   ; da14
       byte >00                                                      ; Character timer 3.
bandit_draw_4_timer:                   ; da15
       byte >00                                                      ; Character timer 4.
bandit_draw_5_timer:                   ; da16
       byte >00                                                      ; Character timer 5.

* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_open_routing:              ; da17
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_open_1         ; JR Z,$DA29        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_open_2         ; JR Z,$DA39        ; { $01 | #R$DA29 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DA39 }
       jeq  bandit_draw_open_3         ; JR Z,$DA49        ; { $03 | #R$DA49 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DA59 }
       jeq  bandit_draw_open_4         ; JR Z,$DA59        ; { $05 | #R$DA6F }
       jmp  bandit_draw_open_5         ; JR $DA6F          ; TABLE#}
* Handle door frame 1 countdown/ transition to door frame 2.
bandit_draw_open_1:                    ; da29
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 3.
bandit_draw_open_2:                    ; da39
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 4.
bandit_draw_open_3:                    ; da49
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_1,a     ; LD A,($DA0D)      ; Grab the character frame index from #R$DA0D.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_open_4:                    ; da59
       li   de,set_state_init_bandit_draw_close   ; LD DE,$D037       ; {Call #R$D5A3 with a callback to #R$D037.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_2,a     ; LD A,($DA0E)      ; Grab the character frame index from #R$DA0E.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_open_5:                    ; da6f
       li   de,init_bandit_draw_close  ; LD DE,$D040       ; {Call #R$D5A3 with a callback to #R$D040.
       .call @hit_detection            ; CALL $D5A3        ; }
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,@player_died_status    ; INC A             ; {Else write $01 to #R$D2FE, call #R$D8A1 and return.
                                       ; LD ($D2FE),A      ;
       .call @reset_door_routine       ; CALL $D8A1        ;
       .ret                            ; RET               ; }

* This routine looks at the current character state and routes to the correct
* subroutine.
bandit_draw_close_routing:             ; da85
       li   hl,bandit_draw_state_ref   ; LD HL,$DA11       ; {#REGa=#R$DA11.
       movb *hl,a                      ; LD A,(HL)         ; }
       sb   one,a                      ; DEC A             ; {Work out which routine to use based on the current state.
       jeq  bandit_draw_close_1        ; JR Z,$DA97        ; #TABLE(default,centre,centre)
       sb   one,a                      ; DEC A             ; { =h #REGa | =h Routine }
       jeq  bandit_draw_close_2        ; JR Z,$DAA7        ; { $01 | #R$DA97 }
       sb   one,a                      ; DEC A             ; { $02 | #R$DAA7 }
       jeq  bandit_draw_close_3        ; JR Z,$DAC0        ; { $03 | #R$DAC0 }
       sb   one,a                      ; DEC A             ; { $04 | #R$DAD0 }
       jeq  bandit_draw_close_4        ; JR Z,$DAD0        ; { $05 | #R$DAE0 }
       jmp  bandit_draw_close_5        ; JR $DAE0          ; TABLE#}
* Handles state countdown.
bandit_draw_close_1:                   ; da97
                                       ; LD A,($DA12)      ; {Decrease #R$DA12 by one, return if result is not zero.
       sb   one,@bandit_draw_1_timer   ; DEC A             ;
                                       ; LD ($DA12),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_3,a     ; LD A,($DA0F)      ; Grab the character frame index from #R$DA0F.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; {Call #R$D6ED and return.
       .ret                            ; RET               ; }
* Handles state countdown.
bandit_draw_close_2:                   ; daa7
                                       ; LD A,($DA13)      ; {Decrease #R$DA13 by one, return if result is not zero.
       sb   one,@bandit_draw_2_timer   ; DEC A             ;
                                       ; LD ($DA13),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_4        ; CALL $D6ED        ; Call #R$D6ED.
       movb @bandit_draw,a             ; LD A,($DA0C)      ; {Return if #R$DA0C is zero.
       ; AND A                         ; AND A             ; 
       jne  !                          ; RET Z             ; }
       .ret                            ;                   
!
       ab   one,@player_died_status    ; INC A             ; {Else write $01 to #R$D2FE and return.
                                       ; LD ($D2FE),A      ;
       .ret                            ; RET               ; }
* Handle door frame 4 countdown/ transition to door frame 3.
bandit_draw_close_3:                   ; dac0
                                       ; LD A,($DA14)      ; {Decrease #R$DA14 by one, return if result is not zero.
       sb   one,@bandit_draw_3_timer   ; DEC A             ;
                                       ; LD ($DA14),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_3        ; CALL $D6DF        ; {Call #R$D6DF and return.
       .ret                            ; RET               ; }
* Handle door frame 3 countdown/ transition to door frame 2.
bandit_draw_close_4:                   ; dad0
                                       ; LD A,($DA15)      ; {Decrease #R$DA15 by one, return if result is not zero.
       sb   one,@bandit_draw_4_timer   ; DEC A             ;
                                       ; LD ($DA15),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       ab   one,*hl                    ; INC (HL)          ; Move onto next character state.
       movb @bandit_draw_frame_4,a     ; LD A,($DA10)      ; Grab the character frame index from #R$DA10.
       bl   @draw_door_frame_2        ; CALL $D6D1        ; {Call #R$D6D1 and return.
       .ret                            ; RET               ; }
* Handle door frame 2 countdown/ transition to door frame 1.
bandit_draw_close_5:                   ; dae0
                                       ; LD A,($DA16)      ; {Decrease #R$DA16 by one, return if result is not zero.
       sb   one,@bandit_draw_5_timer   ; DEC A             ;
                                       ; LD ($DA16),A      ;
       jeq  !                          ; RET NZ            ; }
       .ret                            ;                   
!
       bl   @draw_door_frame_1        ; CALL $D664        ; Call #R$D664 (i.e. no character/ door is shut).
       .call @reset_door_routine                 ; CALL $D8A1        ; {Call #R$D8A1 and return.
       .ret                            ; RET               ; }

* Door Buffer
* 
* Used by the routines at #R$6600, #R$C300 and #R$F950.
;door_buffer:                           ; ea90
;       bss 704

*
* Used by the routine at #R$CD47.
explode_bomb:
       li   bc,12                      ; LD B,$0C          ;
explode_bomb_1:                        ; f882
       .push bc                        ; PUSH BC           ; 
       .call @explode_bomb_3           ; CALL $F894        ;
       .pop bc                         ; POP BC            ; 
       dec  bc                         ; DJNZ $F882        ;
       jne  explode_bomb_1             ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       movb @bytes+64,b                ; LD B,$40          ; 
explode_bomb_2:                        ; f890
       bl   @ti_vsync                     ; HALT              ;
       sb   one,b                      ; DJNZ $F890        ; 
       jne  explode_bomb_2             ;
       .ret                            ; RET               ;

explode_bomb_3:                        ; f894
       movb @bytes+56,a                ; LD A,$38          ; 
       .call @explode_set_attrs        ; CALL $F8B2        ;
       sb   a,a                        ; XOR A             ; 
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       li   bc,4                       ; LD B,$04          ;
explode_bomb_4:                        ; f8a0
       bl   @ti_vsync                     ; HALT              ;
       dec  bc                         ; DJNZ $F8A0        ;
       jne  explode_bomb_4             ;
       movb @bytes+7,a                 ; LD A,$07          ; 
       .call @explode_set_attrs        ; CALL $F8B2        ;
       bl   @ti_set_border_color          ; OUT ($FE),A       ;
       li   bc,3                       ; LD B,$03          ;
explode_bomb_5:                        ; f8ae
       bl   @ti_vsync                     ; HALT              ;
       dec  bc                         ; DJNZ $F8AE        ;
       jne  explode_bomb_5             ;
       .ret                            ; RET               ;

explode_set_attrs:                     ; f8b2
       bl   @ti_set_screen_color
;       li   hl,zx_attributes+>0060     ; LD HL,$5860       ;
;       li   de,zx_attributes+>0061     ; LD DE,$5861       ;
;       li   bc,>01df                   ; LD BC,$01DF       ;
;       movb a,*hl                      ; LD (HL),A         ;
;       .ldir                           ; LDIR              ;
       .ret                            ; RET               ; 

* This entry point is used by the routine at #R$C7C0.
scroll_dollar_sign:                    ; f960
       seto @graphics_bank_select
;       li   hl,buffer_at_5b00          ; LD HL,$5B00       ; {Blanks 254 bytes from #R$5B00 onwards.
;       li   de,buffer_at_5b00+1        ; LD DE,$5B01       ;
;       li   bc,>00fe                   ; LD BC,$00FE       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ; }
       li   de,gfx_dollar_image_2      ; LD DE,$F940       ; {Sends #R$F940 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>0cf8                   ; LD HL,$0CF8       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $0CF8 | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>079e                   ; LD HL,$079E       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $079E | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0006                   ; LD DE,$0006       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>029e                   ; LD HL,$029E       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $029E | $0006 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image        ; LD DE,$F900       ; {Sends #R$F900 to #R$F9C3.
       nop                             ; NOP               ; 
       nop                             ; NOP               ; 
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
; TODO: sound
;       li   de,>0020                   ; LD DE,$0020       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>0209                   ; LD HL,$0209       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; { =h Pitch | =h Duration }
                                                           ; { $0209 | $0020 }
                                                           ; TABLE#}
       li   de,gfx_dollar_image_1      ; LD DE,$F920       ; {Sends #R$F920 to #R$F9C3.
       .call @dollar_scroll_draw       ; CALL $F9C3        ; }
*      Clear
       li   de,buffer_at_5b00          ; LD DE,$5B00       ; {Sends #R$5B00 to #R$F9C3 (blanks the centrepiece).
       .call @dollar_scroll_draw       ; CALL $F9C3        ;  Needs 32 zeros }
       .ret                            ; RET               ; Return.
* Draws the image to the screen.
* de=image to draw
dollar_scroll_draw:                    ; f9c3
       li   tmp0,(1*32+15)*8
       mov  de,tmp1
       li   tmp2,>0202
       bl   @ti_draw_graphics
;       li   hl,zx_screen+>002f         ; LD HL,$402F       ;
;       li   bc,>1002                   ; LD BC,$1002       ;
;dollar_scroll_draw_loop:               ; f9c9
;       .push bc                        ; PUSH BC           ;
;       .push hl                        ; PUSH HL           ;
;       sb   b,b                        ; LD B,$00          ;
;       .ex_de_hl                       ; EX DE,HL          ;
;       .ldir                           ; LDIR              ;
;       .ex_de_hl                       ; EX DE,HL          ;
;       .pop hl                         ; POP HL            ;
;       ab   one,h                      ; INC H             ;
;       movb h,a                        ; LD A,H            ;
;       andi a,7*256                    ; AND $07           ;
;       jne  dollar_scroll_draw_1       ; JR NZ,$F9DE       ;
;       movb @bytes+64,h                ; LD H,$40          ;
;       movb @l,a                       ; LD A,L            ;
;       ab   @bytes+32,a                ; ADD A,$20         ;
;       movb a,@l                       ; LD L,A            ;
;dollar_scroll_draw_1:                  ; f9de
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $F9C9        ;
;       jne  dollar_scroll_draw_loop    ;
       movb one,b                      ; LD B,$01          ;
dollar_scroll_halt_loop:               ; f9e3
       bl   @ti_vsync
       bl   @ti_vsync
       sb   one,b                      ; DJNZ $F9E3        ;
       jne  dollar_scroll_halt_loop    ;
       .ret                            ; RET               ; Return.

* High Score Entry.
* 
* Used by the routine at #R$C7C0.
* ix=score_digit_6
draw_and_input_high_scores:            ; fa00
       .call @high_scores              ; CALL $FA06        ;
       b    @high_score_read_char      ; JP $FB62          ; Wait keypress and return
high_scores:                           ; fa06
;       li   de,buffer_at_5b80          ; LD DE,$5B80       ; {Copies $40 bytes of data from #REGhl to #R$5B80.
;       li   bc,>0040                   ; LD BC,$0040       ;
;       .ldir                           ; LDIR              ; }
       movb @bytes+48,a                ; LD A,$30          ; {Writes "0" ($30 in ASCII) to #R$FB94.
       movb a,@high_score_line_buffer  ; LD ($FB94),A      ; }
       .call @hs_clear_screen          ; CALL $FAD4        ; Call #R$FAD4.
       li   hl,zx_screen+>0040         ; LD HL,$4040       ; {Writes $4040 to #R$FBF0.
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ; }
       .push ix                        ; PUSH IX           ; 
       .call @hs_find_position         ; CALL $FC09        ; Call #R$FC09.
       movb a,@high_score_position     ; LD ($FB57),A      ;
       .pop ix                         ; POP IX            ; 
       movb a,tmp0
                                       ; CP $1F            ;
       movb one,a                      ; LD A,$01          ;
       cb   tmp0,@bytes+31             ;                   ; Is position last?
       jne  new_high_score             ; JP Z,$FAB0        ;
       b    @draw_high_scores   ;
new_high_score:
       li   hl,zx_screen               ; LD HL,$4000       ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
*      Move name entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_name_addr       ; CALL $FB19        ;
                                       ; LD DE,$61EF       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_name ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_name-1 ; POP HL            ;
       li   de,high_score_table_last_name+15 ; LD DE,$61FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Move score entries down to make room for new
       movb @high_score_position,a     ; LD A,($FB57)      ;
       sb   one,a                      ; DEC A             ; 
       .call @hs_table_score_address   ; CALL $FBFF        ;
                                       ; LD DE,$62F9       ;
                                       ; PUSH DE           ;
                                       ; EX DE,HL          ;
       li   bc,high_score_table_last_score ; AND A             ;
       s    hl,bc                      ; SBC HL,DE         ;
                                       ; PUSH HL           ;
                                       ; POP BC            ;
       li   hl,high_score_table_last_score-1 ; POP HL            ;
       li   de,high_score_table_last_score+5 ; LD DE,$62FF       ;
                                       ; INC BC            ;
       .lddr                           ; LDDR              ;
*      Copy new score into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_score_address   ; CALL $FBFF        ;
       dec  hl                         ; DEC HL            ; 
       .ex_de_hl                       ; EX DE,HL          ;
       .push ix                        ; PUSH IX           ;
       .pop hl                         ; POP HL            ;
       movb @bytes+6,b                 ; LD B,$06          ;
new_high_score_1:                      ; fa6f
       movb *hl,a                      ; LD A,(HL)         ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*de                      ; LD (DE),A         ; 
       dec  de                         ; DEC DE            ; 
       inc  hl                         ; INC HL            ; 
       sb   one,b                      ; DJNZ $FA6F        ; 
       jne  new_high_score_1           ;
*      Fill name buffer with spaces
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; TODO {Overwrites the text at #R$5BC0 with spaces to "blank"
       li   de,high_score_name_buffer+1 ; LD DE,$5BC1       ; it out ($12 characters).
       li   bc,>0011                   ; LD BC,$0011       ; 
       movb @bytes+32,*hl              ; LD (HL),$20       ; 
       .ldir                           ; LDIR              ; }
       movb @b255,*hl                  ; LD (HL),$FF       ; Set a string termination character ($FF) at the end of
* Print "Write your name please"                           ; the string.
       .call @hs_clear_screen          ; CALL $FAD4        ;
       li   hl,high_score_title        ; LD HL,$FB78       ; {Points to #R$FB78 and sends it to #R$5B80.
       li   de,zx_screen+>0802         ; LD DE,$4802       ; #TABLE(default,centre)
       li   bc,>0703                   ; LD BC,$0703       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $03 | $03 | $00 | $00 }
                                                           ; TABLE#}
* Input name
       .call @high_score_input_name    ; CALL $FB26        ;
       .call @hs_clear_screen          ; CALL $FAD4        ;
* Copy name into high score table
       movb @high_score_position,a     ; LD A,($FB57)      ;
       .call @hs_table_name_addr       ; CALL $FB19        ; a--
       .ex_de_hl                       ; EX DE,HL          ; 
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ;
       li   bc,>0010                   ; LD BC,$0010       ; 
       .ldir                           ; LDIR              ;
* Determine from which position to draw
       sb   @bytes+5,a                 ; SUB $05           ; position - 1 - 5
       jgt  draw_high_scores_2         ; JR NC,$FABD       ; If 5 or more higher scores start from position - 5
       jmp  draw_high_scores_1         ; JR $FABC          ; Otherwise start from top
draw_high_scores:                      ; _fab0
       li   hl,high_score_sub_head     ; LD HL,$FBB5       ; {Points to #R$FBB5 and sends it to #R$5B80.
       li   de,zx_screen               ; LD DE,$4000       ; #TABLE(default,centre)
       li   bc,>0706                   ; LD BC,$0706       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
                                                           ; { $06 | $06 | $00 | $00 }
                                                           ; TABLE#}
draw_high_scores_1:                    ; fabc
       sb   a,a                        ; XOR A             ; 
draw_high_scores_2:                    ; fabd
       ab   one,a                      ; INC A             ; 
       movb @bytes+10,b                ; LD B,$0A          ; 
draw_high_scores_3:                    ; fac0
       .push bc                        ; PUSH BC           ; 
       .push af                        ; PUSH AF           ; 
       .call @hs_setup_line_buffer     ; CALL $FAE2        ;
       li   de,high_score_line_buffer  ; LD DE,$FB94       ;
       .call @advance_2_rows_and_print  ; CALL $FBD5        ;
       .pop af                         ; POP AF            ; 
       .pop bc                         ; POP BC            ; 
       ab   one,a                      ; INC A             ; 
       cb   a,@bytes+32                ; CP $1F            ;
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       sb   one,b                      ; DJNZ $FAC0        ; 
       jne  draw_high_scores_3         ;
       .ret                            ; RET               ;

hs_clear_screen:                       ; fad4
       bl   @ti_clear_screen
;       li   hl,zx_screen               ; LD HL,$4000       ; {Clears the screen buffer by writing $00 to all 6912
;       li   de,zx_screen+1             ; LD DE,$4001       ; memory locations.
;       li   bc,>1aff                   ; LD BC,$1AFF       ;
;       sb   *hl,*hl                    ; LD (HL),$00       ;
;       .ldir                           ; LDIR              ;
       .ret                            ; RET               ; }

hs_setup_line_buffer:                  ; fae2
       movb a,@c                       ; LD C,A            ; 
       li   hl,high_score_line_buffer  ; LD HL,$FB94       ;
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+49,*hl              ; LD (HL),$31       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+50,*hl              ; LD (HL),$32       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
       jlt  hs_setup_line_buffer_1     ; JR C,$FAFA        ;
       movb @bytes+51,*hl              ; LD (HL),$33       ; 
       sb   @bytes+10,a                ; SUB $0A           ; 
hs_setup_line_buffer_1:                ; fafa
       ab   @bytes+10,a                ; ADD A,$0A         ; 
       inc  hl                         ; INC HL            ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
       movb a,*hl                      ; LD (HL),A         ; 
       movb @c,a                       ; LD A,C            ; 
       .call @hs_table_name_addr      ; CALL $FB19        ;
       li   de,high_score_line_buffer+6 ; LD DE,$FB9A       ;
       li   bc,>0010                   ; LD BC,$0010       ; 
       .ldir                           ; LDIR              ; 
       ai   de,4                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
                                       ; INC DE            ;
       .call @hs_table_score_address   ; CALL $FBFF        ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       .ldir                           ; LDIR              ; 
       .ret                            ; RET               ;

* Works out where in the high score table to place the score.
hs_table_name_addr:                    ; fb19
       sb   one,a                      ; DEC A             ; {Using #R$6000 as a base, work out where to place the new score.
       movb a,@l                       ; LD L,A            ; #LIST
       sb   h,h                        ; LD H,$00          ; { Decrease $1B by one... }
       sla  hl,4                       ; ADD HL,HL         ; { Loads $1A as the low-order byte; #REGhl=$001A }
                                       ; ADD HL,HL         ; { Times by $10; #REGhl=$1A0 }
                                       ; ADD HL,HL         ; { Add $6000=#R$61A0 }
                                       ; ADD HL,HL         ; LIST#
                                       ; LD DE,$6000       ;
       ai   hl,high_score_table        ; ADD HL,DE         ; }
       .ret                            ; RET               ; Return.

high_score_input_name:                 ; fb26
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Stores #R$5BC0 at #R$FB55.
high_score_input_name_1:               ; fb29
       mov  hl,@high_score_name_buffer_addr ; LD ($FB55),HL     ;
       .call @hs_print_name_buffer          ; CALL $FBF2        ; }
       .call @high_score_read_char     ; CALL $FB62        ;
       mov  @high_score_name_buffer_addr,hl ; LD HL,($FB55)     ;
       cb   a,@bytes+13                ; CP $0D            ; 
       jne  !                          ; RET Z             ; 
       .ret                            ;                   
!
       cb   a,@bytes+8                 ; CP $0C            ;
       jeq  high_score_input_name_3    ; JR Z,$FB58        ;
                                       ; LD C,A            ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer+16 ; CP $D1          ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; LD A,C            ;
       cb   a,@bytes+32                ; CP $20            ; 
       jeq  high_score_input_name_2    ; JR Z,$FB51        ;
       cb   a,@bytes+65                ; CP $61            ;
       jl   high_score_input_name_1    ; JR C,$FB29        ;
       cb   a,@bytes+91                ; CP $7B            ;
       jhe  high_score_input_name_1    ; JR NC,$FB29       ;
                                       ; SUB $20           ;
high_score_input_name_2:               ; fb51
       movb a,*hl+                     ; LD (HL),A         ;
                                       ; INC HL            ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

high_score_name_buffer_addr:           ; fb55              ;
       data 0
high_score_position:                   ; fb57
       byte 0                          ; RRA               ;

high_score_input_name_3:               ; fb58              ;
                                       ; LD A,L            ;
       ci   hl,high_score_name_buffer  ; CP $C1            ;
       jle  high_score_input_name_1    ; JR C,$FB29        ;
       dec  hl                         ; DEC HL            ;
       movb @bytes+32,*hl              ; LD (HL),$20       ;
       jmp  high_score_input_name_1    ; JR $FB29          ;

* Returns a single keypress.
high_score_read_char:                  ; fb62
       equ  $                          ; LD HL,$5C08       ; {#HTML(Keep looping around until <em>any</em> input is detected. This is achieved by writing $00 to
                                       ; LD (HL),$00       ; <a href="https://skoolkid.github.io/rom/asm/5C08.html">LAST_K</a> and looping until it's non-zero.)
high_score_read_char_loop:             ; fb67
       bl   @ti_vsync                  ; HALT              ;
       bl   @ti_keyscan                ; LD A,(HL)         ;
       movb  a,a                       ; AND A             ;
       jeq  high_score_read_char_loop  ; JR Z,$FB67        ; }
;       .push af                        ; PUSH AF           ; Store it on the stack for now.
;       li   de,>0010                   ; LD DE,$0010       ; {#HTML(Makes a noise using the <a href="https://skoolkid.github.io/rom/asm/03B5.html">BEEP</a> routine.)
;       li   hl,>00c0                   ; LD HL,$00C0       ; #TABLE(default,centre)
;       .call @>03b5                    ; CALL $03B5        ; TODO { =h Pitch | =h Duration }
                                                           ; { $00C0 | $0010 }
                                                           ; TABLE#}
;       .pop af                         ; POP AF            ; {Return with the keypress in #REGa.
       .ret                            ; RET               ; }

* High Score Table Name Entry.
high_score_title:                      ; fb78
       text '  WRITE YOUR NAME PLEASE   ',>ff
high_score_line_buffer:                ; fb94
       text '10    PANCHO VILLA        241610',>ff
high_score_sub_head:                   ; fbb5
       text '     THESE ARE THE BEST        ',>ff
high_score_name_buffer:
       bss  18

* Routine at FBD5
* 
* Used by the routine at #R$FA00.
advance_2_rows_and_print:              ; fbd5
       mov  @high_score_screen_addr,hl ; LD HL,($FBF0)     ;
       movb @l,a                       ; LD A,L            ; 
       ab   @bytes+64,a                ; ADD A,$40         ;
       jnc  !
       .call @add_8_to_h               ; CALL C,$FBEA      ;
!      movb a,@l                       ; LD L,A            ;
       mov  hl,@high_score_screen_addr ; LD ($FBF0),HL     ;
       li   bc,>0705                   ; LD BC,$0705       ; 
       .ex_de_hl                       ; EX DE,HL          ; 
       .call @print_two_tone_text_alias ; CALL $5B80        ; 
       .ret                            ; RET               ; 

add_8_to_h:                            ; fbea
       movb h,a                        ; LD A,H            ; 
       ab   @bytes+8,a                 ; ADD A,$08         ; 
       movb a,h                        ; LD H,A            ; 
       sb   a,a                        ; XOR A             ; 
       .ret                            ; RET               ; 

high_score_screen_addr:                ; fbf0:
       data >50c0                                          ; Cache

* This entry point is used by the routine at #R$FA00.
hs_print_name_buffer:                  ; fbf2
       li   hl,high_score_name_buffer  ; LD HL,$5BC0       ; {Points to #R$5BC0 and sends it to #R$5B80.
       li   de,zx_screen+>0887         ; LD DE,$4887       ; #TABLE(default,centre)
       li   bc,>0705                   ; LD BC,$0705       ; { =h Value | =h Ink | =h Paper | =h Bright }
       .call @print_two_tone_text_alias ; CALL $5B80        ; { $07 | $07 | $00 | $00 }
       .ret                            ; RET               ; { $05 | $05 | $00 | $00 }
                                                           ; TABLE#}
* This entry point is used by the routine at #R$FA00.
* Calculate hl = >6200 + 6 * a
hs_table_score_address:                ; fbff
       clr  hl
       movb a,h                        ; LD C,A            ; x1
                                       ; XOR A             ;
       sla  hl,1                       ; ADD A,C           ; x2
       ab   a,h                        ; ADD A,C           ; x3
       sla  hl,1                       ; ADD A,C           ; x6
       swpb hl                         ; ADD A,A           ;
                                       ; LD L,A            ;
       ai   hl,high_score_table_scores  ; LD H,$62          ;
       .ret                            ; RET               ; 

* This entry point is used by the routine at #R$FA00.
* ix points to new potential high score BCD low endian
* Returns position in a
hs_find_position:                      ; fc09
       li   hl,high_score_table_scores-6 ; LD HL,$61FA       ;
       li   bc,>0006                   ; LD BC,$0006       ; 
       sb   @e,@e                      ; LD E,$00          ; 
hs_find_next_digit:                    ; fc11
       ab   one,@e                     ; INC E             ; 
       movb @e,a                       ; LD A,E            ; 
       cb   a,@bytes+31                ; CP $1F            ; 
       jhe  hs_find_return             ; RET NC            ;
       a    bc,hl                      ; ADD HL,BC         ;
* hs_cmp_1st_digit:
       movb @5(ix),a                   ; LD A,(IX+$05)     ;
       ab   @bytes+48,a                ; ADD A,$30         ; 
       cb   a,*hl                      ; CP (HL)           ; 
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_2nd_digit           ; JR Z,$FC23        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_2nd_digit:                      ; fc23
       movb @4(ix),a                   ; LD A,(IX+$04)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
       cb   a,@1(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_3rd_digit           ; JR Z,$FC31        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_3rd_digit:                      ; fc31
       movb @3(ix),a                   ; LD A,(IX+$03)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@2(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_4th_digit           ; JR Z,$FC41        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_4th_digit:                      ; fc41
       movb @2(ix),a                   ; LD A,(IX+$02)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@3(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jl   hs_find_next_digit         ; JR C,$FC11        ;
       jeq  hs_cmp_5th_digit           ; JR Z,$FC53        ;
                                       ; LD A,E            ;
       jmp  hs_find_return             ; RET               ;
hs_cmp_5th_digit:                      ; fc53
       movb @1(ix),a                   ; LD A,(IX+$01)     ; 
       ab   @bytes+48,a                ; ADD A,$30         ; 
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
                                       ; INC HL            ;
       cb   a,@4(hl)                   ; CP (HL)           ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
                                       ; DEC HL            ;
       jhe  hs_find_return             ; JR NC,$FC65       ;
       jmp  hs_find_next_digit         ; JR $FC11          ;
hs_find_return:                        ; fc65
       movb @e,a                       ; LD A,E            ; 
       .ret                            ; RET               ;

;* Unused
;       byte >C3,>90,>EA
;
;* Data block at FD00
;       byte >A7,>C2,>0F,>FC,>3A,>0A,>FC
;       byte >F6,>01,>D3,>7F,>3A,>0C,>FC
;       byte >CB,>7F,>20,>06,>CD,>54,>1F
;       byte >D2,>30,>FD,>DB,>FB,>E6,>01
;       byte >20,>ED,>79,>D3,>FB,>3A,>0A
;       byte >FC,>E6,>FE,>D3,>7F,>F6,>01
;       byte >D3,>7F,>32,>0A,>FC,>C9,>3A
;       byte >0C,>FC,>E6,>40,>28,>13,>3A
;       byte >0C,>FC,>F6,>80,>32,>0C,>FC
;       byte >CD,>F5,>FE,>CD,>B8,>FE,>3E
;       byte >06,>CD,>03,>FF,>CD,>50,>FD
;       byte >C3,>0A,>0F,>3E,>FF,>32,>0A
;       byte >FC,>D3,>7F,>3A,>0C,>FC,>E6
;       byte >3E,>32,>0C,>FC,>3A,>07,>FC
;       byte >A7,>3A,>0C,>FC,>CB,>EF,>20
;       byte >02,>CB,>AF,>32,>0C,>FC,>FB
;_fd80:
;       rt
;       byte >C9,>4F,>3A,>0C,>FC,>E6,>01
;       byte >28,>1C,>3A,>0C,>FC,>CB,>87
;       byte >32,>0C,>18,>02,>18,>24,>3E
;       byte >FD,>DB,>FE,>1F,>30,>02,>18
;       byte >16,>3E,>BF,>DB,>FE,>1F,>30
;       byte >01,>C9,>11,>80,>5B,>01,>40
;       byte >00,>ED,>B0,>2A,>86,>5B,>36
;       byte >FF,>C9,>31,>F0,>5F,>18,>14
;       byte >FB,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>21,>01,>01,>22,>B0
;       byte >5C,>3E,>00,>CD,>9B,>22,>21
;       byte >00,>40,>11,>01,>40,>01,>FF
;       byte >1A,>36,>00,>ED,>B0,>CD,>C0
;       byte >C7,>18,>EE,>C3,>90,>EA,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00,>00,>00,>00,>00
;       byte >00,>00,>00
;       byte >3A

* Title Screen.
* 
* Used by the routine at #R$C7C0.
title_screen:                          ; fe00
;       li   de,buffer_at_5b80          ; LD DE,$5B80       ;
;       li   bc,>0040                   ; LD BC,$0040       ;
;       .ldir                           ; LDIR              ;
       movb one,a                      ; LD A,$01          ; 
       bl   @ts_draw_bandits           ; CALL $FEA4        ;
       li   hl,title_screen_game_name  ; LD HL,$FEEA       ; {Points to #R$FEEA and sends it to #R$5B80.
       li   de,zx_screen+>002b         ; LD DE,$402B       ;
       li   bc,>0703                   ; LD BC,$0703       ; 
       .call @print_two_tone_text_alias ; CALL $5B80        ; }
       li   hl,title_screen_play       ; LD HL,$FEF4       ; {Points to #R$FEF4 and sends it to #R$FEE4.
       li   de,zx_screen+>00cb         ; LD DE,$40CB       ;
       bl   @title_screen_print       ; CALL $FEE4        ; }
       li   hl,title_screen_keys       ; LD HL,$FEFC       ; Points to #R$FEFC and sends it to #R$FEE4.
       li   de,zx_screen+>082b         ; LD DE,$482B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_joystick   ; LD HL,$FF06       ; Points to #R$FF06 and sends it to #R$FEE4.
       li   de,zx_screen+>088b         ; LD DE,$488B       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_level      ; LD HL,$FF11       ; Points to #R$FF11 and sends it to #R$FEE4.
       li   de,zx_screen+>08eb         ; LD DE,$48EB       ;
       bl   @title_screen_print       ; CALL $FEE4        ;
       li   hl,title_screen_author     ; LD HL,$FF19       ; Points to #R$FF19 and sends it to #R$5B80.
       li   de,zx_screen+>1083         ; LD DE,$5083       ;
       li   bc,>0705                   ; LD BC,$0705       ; 
       .call @print_two_tone_text_alias ; CALL $5B80        ; 
       li   hl,title_screen_copyright  ; LD HL,$FF34       ; {Points to #R$FF34 and sends it to #R$5B80.
       li   de,zx_screen+>10c0         ; LD DE,$50C0       ;
       li   bc,>0704                   ; LD BC,$0704       ;
       .call @print_two_tone_text_alias ; CALL $5B80        ; }

* Act on input.
title_screen_input:                    ; fe58
       movb @controller,a              ; LD A,($5CB0)      ; {If #R$5CB0 is zero (joystick) then #REGde=$0787 else #REGde=$8707. Then call the subroutine at #R$FE95.
       ; AND A                         ; AND A             ; The $07/ $87 correspond to white INK and white INK flashing for the selected control method.
       jeq  ts_select_kempston         ; JR Z,$FE63        ; #TABLE(default,centre,centre,centre,centre,centre)
       li   de,>8707                   ; LD DE,$8707       ; { =h Value | =h Ink | =h Paper | =h Bright | =h Flash }
       jmp  ts_call_flash              ; JR $FE66          ; { $07 | $07 | $00 | $00 | $00 }
ts_select_kempston:                    ; fe63
       li   de,>0787                   ; LD DE,$0787       ; { $87 | $07 | $00 | $00 | $01 }
ts_call_flash:                         ; fe66
       .call @ts_flash_text            ; CALL $FE95        ; TABLE#}
       li   hl,controller              ; LD HL,$5CB0       ; Point #REGhl=#R$5CB0.
       li   tmp0,KEY_1
       bl   @ti_check_key
       jne  ts_set_keyboard
;       movb @bytes+247,a               ; LD A,$F7          ; {Read keys 1, 2, 3, 4, 5.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {Jump to #R$FE86 if "1" is pressed.
;       jnc  ts_set_keyboard            ; JR NC,$FE86       ;
       li   tmp0,KEY_2
       bl   @ti_check_key
       jne  ts_set_kempston
;       ; RRA                           ; RRA               ; {Jump to #R$FE8B if "2" is pressed.
;       jnc  ts_set_kempston            ; JR NC,$FE8B       ;
       li   tmp0,KEY_N
       bl   @ti_check_key
       jne  ts_select_level
;       movb @bytes+127,a               ; LD A,$7F          ; {Read keys SPACE, FULL-STOP, M, N, & B.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       movb a,tmp0                     ; BIT 3,A           ; {Jump to #R$FE8F if "N" is pressed.
;       andi tmp0,8*256                 ;
;       jeq  ts_select_level            ; JR Z,$FE8F        ; }
       li   tmp0,KEY_0
       bl   @ti_check_key
       jeq  !
;       movb @bytes+239,a               ; LD A,$EF          ; {Read keys 0, 9, 8, 7, 6.
;       ; IN A,($FE)                    ; IN A,($FE)        ; }
;       ; RRA                           ; RRA               ; {Return if "0" is pressed, else loop back around to
;       joc  !                          ; RET NC            ;
       .ret                            ;
;!
!      jmp  title_screen_input         ; JR $FE58          ; }
*
ts_set_keyboard:                       ; fe86
       movb one,a                      ; LD A,$01          ; {Writes $01 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ; 
       jmp  title_screen_input         ; JR $FE58          ; }
ts_set_kempston:                       ; fe8b
       sb   a,a                        ; XOR A             ; {Writes $00 to #R$5CB0 and loop back around to #R$FE58.
       movb a,*hl                      ; LD (HL),A         ; 
       jmp  title_screen_input         ; JR $FE58          ; }
ts_select_level:                       ; fe8f
;      li   hl,buffer_at_5b80          ; LD HL,$5B80       ; {Jump to #R$6380 with #REGhl=#R$5B80.
       b    @level_select              ; JP $6380          ; }
*
ts_flash_text:                         ; fe95
       li   bc,>0020                   ; LD BC,$0020       ; {ggg
       li   hl,zx_attributes+>012b     ; LD HL,$592B       ;
*      Attributes for 1 Keys
       movb d,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb d,*hl                      ; LD (HL),D         ;
*      Attributes for 2 Kempston
       a    bc,hl                      ; ADD HL,BC         ; 
       a    bc,hl                      ; ADD HL,BC         ;
       movb @e,a
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ;
       a    bc,hl                      ; ADD HL,BC         ;
       mov  hl,tmp1
       bl   @ti_draw_attribute
;       movb @e,*hl                     ; LD (HL),E         ; }
*      Return
       .ret                            ; RET               ; Return.

* Draw bandits.
ts_draw_bandits:                        ; fea4
       .proc
*      Left bandit
       li   tmp0,>00c1
       clr  tmp1
       bl   @ti_draw_character
*      Right bandit
       li   tmp0,>00d9
       clr  tmp1
       bl   @ti_draw_character
*      Left bandit bottom colors
       li   tmp0,(>00c1+(8*32))*8
       li   tmp1,>0020
       li   tmp2,>0603
       bl   @ti_draw_color_area
*      Right bandit bottom colors
       li   tmp0,(>00d9+(8*32))*8
       li   tmp1,>0020
       li   tmp2,>0603
       bl   @ti_draw_color_area
       .endproc
;*      Left bandit colors
;       li   hl,zx_attributes+>00c1     ; LD HL,$58C1       ; {Sets attributes on the left and right of the screen and
;       .call @ts_bandit_attributes     ; CALL $FEC3        ; points #REGde at #R$6800.
;*      Right bandit colors
;       li   hl,zx_attributes+>00d9     ; LD HL,$58D9       ;
;       .call @ts_bandit_attributes     ; CALL $FEC3        ;
;*      Left bandit
;       li   hl,zx_screen+>00c1         ; LD HL,$40C1       ;
;       .call @ts_draw_bandits_1        ; CALL $FEB9        ;
;*      Right bandit
;       li   hl,zx_screen+>00d9         ; LD HL,$40D9       ;
;ts_draw_bandits_1: ; feb9
;       li   de,gfx_character_00        ; LD DE,$6800       ; TODO
;       movb @bytes+88,b                ; LD B,$58          ;
;       movb @bytes+6,@c                ; LD C,$06          ; }
;       b    @draw_character            ; JP $5B92          ; Jump to #R$5B92.
;ts_bandit_attributes:                  ; fec3
;       movb @bytes+8,b                 ; LD B,$08          ; {Calls #R$FECE with #REGb=$08 and #REGa=$28.
;       movb @bytes+40,a                ; LD A,$28          ;
;       .call @ts_bandit_attr_loop      ; CALL $FECE        ; }
;       movb @bytes+3,b                 ; LD B,$03          ; {Calls #R$FEDA with #REGb=$03 and #REGa=$20.
;       movb @bytes+32,a                ; LD A,$20          ;
;
;ts_bandit_attr_loop:                   ; fece
;       .push bc                        ; PUSH BC           ; }
;       .call @ts_bandit_attr_row       ; CALL $FEDA        ;
;       li   bc,>001b                   ; LD BC,$001B       ;
;       a    bc,hl                      ; ADD HL,BC         ;
;       .pop bc                         ; POP BC            ;
;       sb   one,b                      ; DJNZ $FECE        ;
;       jne  ts_bandit_attr_loop        ;
;       .ret                            ; RET               ; Return.
;
;ts_bandit_attr_row:                    ; feda
;       .push hl                        ; PUSH HL           ;
;       .pop de                         ; POP DE            ;
;       inc  de                         ; INC DE            ;
;       li   bc,>0005                   ; LD BC,$0005       ;
;       movb a,*hl                      ; LD (HL),A         ;
;       .ldir                           ; LDIR              ;
;       .ret                            ; RET               ; Return.

title_screen_print:                    ; fee4
       .proc
       li   bc,>0702                   ; LD BC,$0702       ; {#REGb=$07, #REGc=$02 and jump to #R$5B80.
       b    @print_two_tone_text_alias ; JP $5B80          ; }

* Title Screen/ Game Options
title_screen_game_name:                ; feea
       text 'WEST BANK',>ff
* Playing Options.
title_screen_play:                     ; fef4
       text '0 PLAY ',>ff
title_screen_keys:                     ; fefc
       text '1 KEYS   ',>ff
title_screen_joystick:                 ; ff06
       text '2 JOYSTICK',>ff
title_screen_level:                    ; ff11
       text 'N LEVEL',>ff
* Credits.
title_screen_author:                   ; ff19
       text ' PROGRAM BY ALVARO MATEOS ',>ff
title_screen_copyright:                ; ff34
       text 'COPYRIGHT  DINAMIC SOFTWARE 1985',>ff
       text >00,>00,>ff

;* Gun Shot Mask.
;shot_mask_image:                       ; ff58
;       byte >00,>00,>00,>00,>00,>00,>05,>D0                          ; {#UDGARRAY2,attr=7,scale=4,step=2;(#PC)-(#PC+$01)(shot-mask)
;       byte >04,>10,>05,>D0,>00,>00,>00,>00                          ; }
;
;* Gun Shot.
;shot_image:                            ; ff68
;       byte >00,>00,>04,>90,>02,>A0,>30,>0C                          ; {#UDGARRAY2,attr=7,scale=4,step=2;(#PC)-(#PC+$01)(shot)
;       byte >04,>20,>08,>90,>00,>80,>00,>00                          ; }
