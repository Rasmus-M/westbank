*********************************************************************
*
* Draw playfield
*
ti_draw_playfield:
       .proc
       bl   @ti_display_off
       seto @graphics_bank_2_select
       li   tmp0,pattern_table
       li   tmp1,bank_screen_patterns
       li   tmp2,>1800
       bl   @vmbw
       seto @graphics_bank_3_select
       li   tmp0,color_table
       li   tmp1,bank_screen_colors
       li   tmp2,>1800
       bl   @vmbw
       bl   @ti_display_on
       .endproc
*// ti_draw_playfield

*********************************************************************
*
* Setup parameters for calling ti_draw_door_frame_1-4
*
ti_setup_draw_door_params:
       clr  tmp1
       movb a,tmp1
       swpb tmp1
       clr  tmp2
       movb @door_frame_ref,tmp2
       swpb tmp2
       dec  tmp2
       rt
*// ti_setup_draw_door_params

*********************************************************************
*
* Draw door frame 1
*
* tmp1: character index to draw
* tmp2: door index 0-2
*
ti_draw_door_frame_1:
       .proc
       sla  tmp2,1
       a    @current_door_positions,tmp2
       mov  *tmp2,tmp0
       clr  tmp2
       bl   @ti_draw_character_and_door
       .endproc
*// ti_draw_door_frame_1

*********************************************************************
*
* Draw door frame 2
*
* tmp1: character index to draw
* tmp2: door index 0-2
*
ti_draw_door_frame_2:
       .proc
       sla  tmp2,1
       a    @current_door_positions,tmp2
       mov  *tmp2,tmp0
       li   tmp2,1
       bl   @ti_draw_character_and_door
       .endproc
*// ti_draw_door_frame_2

*********************************************************************
*
* Draw door frame 3
*
* tmp1: character index to draw
* tmp2: door index 0-2
*
ti_draw_door_frame_3:
       .proc
       sla  tmp2,1
       a    @current_door_positions,tmp2
       mov  *tmp2,tmp0
       li   tmp2,2
       bl   @ti_draw_character_and_door
       .endproc
*// ti_draw_door_frame_3

*********************************************************************
*
* Draw door frame 4
*
* tmp1: character index to draw
* tmp2: door index 0-2
*
ti_draw_door_frame_4:
       .proc
       sla  tmp2,1
       a    @current_door_positions,tmp2
       mov  *tmp2,tmp0
       li   tmp2,3
       bl   @ti_draw_character_and_door
       .endproc
*// ti_draw_door_frame_4

*********************************************************************
*
* Draw a character behind a door
*
* tmp0: x position in characters (0-31)
* tmp1: character index to draw
* tmp2: door frame 0-3
*
ti_draw_character_and_door:
       .proc
       a    @scroll_position,tmp0
       andi tmp0,31
       ai   tmp0,4*32
       .push tmp2                      ; Save door frame
       mov  tmp2,tmp2                  ; Check door frame
       jeq  ti_draw_character_and_door_1 ; If door frame is 0 then don't draw any character
       .push tmp0                      ; Save screen position
       sla tmp2,1                      ; Columns to drawn = door frame * 2
       bl   @ti_draw_partical_character
       .pop tmp0                       ; Restore screen position
ti_draw_character_and_door_1:
       .pop tmp1                       ; Move door frame to tmp1
       bl   @ti_draw_door
       .endproc
*// ti_draw_character_and_door

*********************************************************************
*
* Draw a character
*
* tmp0: screen position in characters
* tmp1: character index to draw
*
ti_draw_character:
       .proc
       sla  tmp1,2                     ; 4 bytes per entry
       ai   tmp1,character_table       ; Add character table base
       mov  *tmp1+,tmp2                ; Get ROM select address
       seto *tmp2                      ; Select ROM bank
       mov  *tmp1,tmp1                 ; Get source address
       sla  tmp0,3                     ; VDP address
       li   tmp2,>060b                 ; Width/height in characters
       bl   @ti_draw_color_graphics    ; Draw graphics
       .endproc
*// ti_draw_character

*********************************************************************
*
* Draw a partial character
*
* tmp0: screen position in characters
* tmp1: character index to draw
* tmp2: number of columns to draw
*
ti_draw_partical_character:
       .proc
       sla  tmp1,2                     ; 4 bytes per entry
       ai   tmp1,character_table       ; Add character table base
       mov  *tmp1+,a                   ; Get ROM select address
       seto *a                         ; Select ROM bank
       mov  *tmp1,tmp1                 ; Get source address
       sla  tmp0,3                     ; VDP address
       li   a,6                        ; Calculate source skip
       s    tmp2,a                     ; 6 - columns to draw
       sla  a,3                        ; x 8
       mov  a,@row_src_skip            ; Set source skip
       sla  tmp2,8                     ; Width to MSB
       ori  tmp2,>000b                 ; Set height
       bl   @ti_draw_color_graphics    ; Draw graphics
       clr  @row_src_skip
       .endproc
*// ti_draw_partial_character

*********************************************************************
*
* Draw a door
*
* tmp0: screen position in characters
* tmp1: frame 0-3
*
ti_draw_door:
       .proc
       seto @graphics_bank_1_select
       sla  tmp1,1                     ; X offset in characters
       a    tmp1,tmp0                  ; Add offset to screen position
       li   tmp2,7                     ; Full door width
       s    tmp1,tmp2                  ; Subtract offset
       mov   @door_frame_table(tmp1),tmp1 ; Source address
       sla  tmp0,3                     ; VDP address
       sla  tmp2,8                     ; Width to MSB
       ori  tmp2,>000b                 ; Set height
       bl   @ti_draw_color_graphics    ; Draw graphics
       .endproc
*// ti_draw_door

*********************************************************************
*
* Scroll screen left
*
ti_scroll_left:
       .proc
       mov  @scroll_position,tmp0
       mov  @scroll_amount_ptr,tmp1
       mov  *tmp1,tmp2
ti_scroll_left_1:
       inc  tmp0
       bl   @ti_dbl_buffer_scroll_screen
       dec  tmp2
       jne  ti_scroll_left_1
*      After
       mov  tmp0,@scroll_position
       mov  @current_door_positions,tmp2
       ai   tmp2,6
       mov  @scroll_amount_ptr,tmp1
       inct tmp1
       ci   tmp1,scroll_amounts_end
       jl   ti_scroll_left_2
       li   tmp1,scroll_amounts
       li   tmp2,ti_door_positions_1
ti_scroll_left_2:
       mov  tmp1,@scroll_amount_ptr
       mov  tmp2,@current_door_positions
       .endproc
*// ti_scroll_left

*********************************************************************
*
* Scroll screen right
*
ti_scroll_right:
       .proc
       mov  @scroll_position,tmp0
       mov  @current_door_positions,tmp2
       ai   tmp2,-6
       mov  @scroll_amount_ptr,tmp1
       dect tmp1
       ci   tmp1,scroll_amounts
       jhe  ti_scroll_right_0
       li   tmp1,scroll_amounts_end-2
       li   tmp2,ti_door_positions_3
ti_scroll_right_0:
       mov  tmp1,@scroll_amount_ptr
       mov  tmp2,@current_door_positions
       mov  *tmp1,tmp2
ti_scroll_right_1:
       dec  tmp0
       bl   @ti_dbl_buffer_scroll_screen
       dec  tmp2
       jne  ti_scroll_right_1
*      After
       mov  tmp0,@scroll_position
       .endproc
*// ti_scroll_right

*********************************************************************
*
* Scroll clean-up
*
ti_scroll_cleanup:
       .proc
       mov  @double_buffer_flag,r0
       jne  ti_scroll_cleanup_1
       bl   @ti_init_2nd_name_table
       bl   @ti_select_name_table_2
       bl   @ti_init_1st_name_table
       bl   @ti_select_name_table_1
       jmp  ti_scroll_cleanup_2
ti_scroll_cleanup_1:
       bl   @ti_init_1st_name_table
       bl   @ti_select_name_table_1
       bl   @ti_init_2nd_name_table
ti_scroll_cleanup_2:
       clr  @scroll_position
       li   r0,scroll_amounts
       mov  r0,@scroll_amount_ptr
       li   r0,ti_door_positions_1
       mov  r0,@current_door_positions
       clr  @double_buffer_flag
       .endproc
*// ti_scroll_cleanup

*********************************************************************
*
* Scroll screen
*
* tmp0: offset in characters
*
ti_dbl_buffer_scroll_screen:
       .proc
       .push tmp0
       andi tmp0,31
       bl   @ti_scroll_screen
       bl   @ti_vsync
       mov  @double_buffer_flag,tmp0
       andi tmp0,1
       jeq  scroll_screen_1
       bl   @ti_select_name_table_1
       jmp  scroll_screen_2
scroll_screen_1:
       bl   @ti_select_name_table_2
scroll_screen_2:
       inv  @double_buffer_flag
       .pop tmp0
       .endproc
*// scroll_screen

*********************************************************************
*
* Scroll screen left by the given offset
*
* tmp0 (r13): offset in characters (0-31)
*
ti_scroll_screen:
       lwpi ti_wrksp
       mov  @double_buffer_flag,r0     ; Double buffer flag
       inv  r0
       andi r0,1                       ; 0 or 1
       sla  r0,10                      ; 0 or >400
       ai   r0,3*32+name_table_1+>4000   ; VDP address + write bit
       movb @ti_r0lb,@vdpwa            ; Send low byte of VDP RAM write address
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
       li   r5,3*32*256                ; Base name for row in MSB
       mov  r13,r6                     ; Offset
       swpb r6                         ; Offset to MSB
       li   r7,>0100                   ; One
       li   r8,>e0ff                   ; Mask (keep 0-31 in MSB)
       li   r4,18                      ; Row counter
ti_scroll_screen_1:
       li   r3,32                      ; Column counter
ti_scroll_screen_2:
       movb r6,r1                      ; Offset
       socb r5,r1                      ; Add base name
       movb r1,*r0                     ; Write to name table
       ab   r7,r6                      ; Increment offset
       szcb r8,r6                      ; Apply mask
       dec  r3
       jne  ti_scroll_screen_2
       movb @vdpsta,@vdp_status
       jlt  ti_scroll_sound
ti_scroll_screen_3:
       ai   r5,>2000                   ; Update base name
       dec  r4
       jne  ti_scroll_screen_1
       lwpi wrksp
       rt

*      Call the module player while scrolling
ti_scroll_sound:
       mov  r0,@save_r0
       mov  r3,@save_r3
       mov  r4,@save_r4
       mov  r5,@save_r5
       mov  r6,@save_r6
       lwpi wrksp
       .push r11
        bl  @module_player_0
       .pop r11
       lwpi ti_wrksp
       mov  @save_r0,r0
       mov  @save_r3,r3
       mov  @save_r4,r4
       mov  @save_r5,r5
       mov  @save_r6,r6
       jmp  ti_scroll_screen_3
save_r0: data 0
save_r3: data 0
save_r4: data 0
save_r5: data 0
save_r6: data 0

*// ti_scroll_screen

*********************************************************************
*
* bc (MSB): number of lines
* bc (LSB): number of bytes
* hl: zx screen address
* de: source address
*
ti_copy_routine:
       .proc
       bl   @ti_copy_routine_init
       bl   @ti_draw_graphics
       .endproc
*// ti_copy_routine

ti_copy_routine_color:
       .proc
       bl   @ti_copy_routine_init
       bl   @ti_draw_color_graphics
       .endproc
*// ti_copy_routine_color

ti_copy_routine_init:
       seto @graphics_bank_1_select
*      VDP address
       mov  hl,tmp0
       ai   tmp0,-zx_screen
       mov  tmp0,tmp1
       andi tmp0,>00ff                 ; Offset into current 3rd
       sla  tmp0,3                     ; Times 8
       andi tmp1,>1800                 ; 3rd bits same on TI and ZX
       soc  tmp1,tmp0
*      Swap width and height, and convert height to characters
       mov  bc,tmp2
       mov  bc,tmp1
       andi tmp1,>ff00
       srl  tmp1,3
       movb tmp1,tmp2
       swpb tmp2
*      Source
       mov  de,tmp1
       rt
*// ti_copy_routine_init

*********************************************************************
*
* Draw shot for door 1
*
ti_draw_door_1_shot:
       .proc
       li   tmp1,SL0
       bl   @ti_draw_and_hide_door_shot
       .endproc
*// ti_draw_door_1_shot

*********************************************************************
*
* Draw shot for door 2
*
ti_draw_door_2_shot:
       .proc
       li   tmp1,SL0+4
       bl   @ti_draw_and_hide_door_shot
       .endproc
*// ti_draw_door_2_shot

*********************************************************************
*
* Draw shot for door 3
*
ti_draw_door_3_shot:
       .proc
       li   tmp1,SL0+8
       bl   @ti_draw_and_hide_door_shot
       .endproc
*// ti_draw_door_3_shot

*********************************************************************
*
* Draw and hide shot for door
*
ti_draw_and_hide_door_shot:
       .proc
       bl   @ti_draw_door_shot
       bl   @ti_vsync
       bl   @ti_vsync
       bl   @ti_hide_door_shots
       .endproc
*// ti_draw_and_hide_door_shot

*********************************************************************
*
* Draw shot for door
*
ti_draw_door_shot:
       .proc
       li   tmp0,sprite_attr_table
       li   tmp2,4
       bl   @vmbw
       li   tmp1,>d000
       movb tmp1,@vdpwd
       .endproc
*// ti_draw_door_3_shot

*********************************************************************
*
* Hide shots
*
ti_hide_door_shots:
       .proc
       li   tmp0,sprite_attr_table
       li   tmp1,>d000
       bl   @vsbw
       .endproc
*// ti_hide_door_shots

*********************************************************************
*
* Show loading creen
*
ti_show_loading_screen:
       .proc
       bl   @ti_display_off
       seto @graphics_bank_4_select
       li   tmp0,0
       li   tmp1,splash_screen_patterns_top
       li   tmp2,>200c
       bl   @ti_draw_color_graphics
       seto @graphics_bank_5_select
       li   tmp0,>0c00
       li   tmp1,splash_screen_patterns_bottom
       li   tmp2,>200c
       bl   @ti_draw_color_graphics
       bl   @ti_display_on
       .endproc
*// ti_show_loading_screen

*********************************************************************************
*
* Draw attribute
*
* a: zx attribute
* tmp1: address in zx attribute file
*
ti_draw_striped_attribute:
*      VDP write address
       ai   tmp1,-zx_attributes
       sla  tmp1,3
       ai   tmp1,color_table+>4000
*      Set VDP write address
       movb @r1lb,@vdpwa               ; Send low byte of VDP RAM write address
       movb tmp1,@vdpwa                ; Send high byte of VDP RAM write address
*      Color
       mov  a,tmp2
       swpb tmp2
       andi tmp2,7
       sla  tmp2,1
       mov  @gradients(tmp2),tmp0
*      Draw
       li   tmp2,vdpwd
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       movb *tmp0+,*tmp2
       rt
*// ti_draw_striped_attribute

* 0  Black,    1 D Blue,   2 D Red,     3 D Magenta
* 4  D Green,  5 D Cyan,   6 D Yellow,  7 Grey
gradients:
       data gradient_black             ; Black
       data gradient_blue              ; Blue
       data gradient_red               ; Red
       data gradient_magenta           ; Magenta
       data gradient_green             ; Green
       data gradient_cyan              ; Cyan
       data gradient_yellow            ; Yellow
       data gradient_grey              ; Grey

gradient_black:
       byte >10
       byte >10
       byte >10
       byte >10
       byte >10
       byte >10
       byte >10
       byte >10

gradient_blue:
       byte >50
       byte >50
       byte >50
       byte >40
       byte >40
       byte >40
       byte >40
       byte >40

gradient_red:
       byte >90
       byte >90
       byte >80
       byte >80
       byte >60
       byte >60
       byte >60
       byte >60

gradient_magenta:
       byte >d0
       byte >d0
       byte >d0
       byte >d0
       byte >d0
       byte >d0
       byte >d0
       byte >d0

gradient_green:
       byte >30
       byte >30
       byte >20
       byte >20
       byte >c0
       byte >c0
       byte >c0
       byte >c0

gradient_cyan:
       byte >70
       byte >70
       byte >50
       byte >50
       byte >40
       byte >40
       byte >40
       byte >40

gradient_yellow:
       byte >f0
       byte >b0
       byte >b0
       byte >a0
       byte >a0
       byte >a0
       byte >a0
       byte >a0

gradient_grey:
       byte >e0
       byte >e0
       byte >e0
       byte >e0
       byte >f0
       byte >f0
       byte >e0
       byte >e0


